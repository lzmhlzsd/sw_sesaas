'use strict';

var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

(function webpackUniversalModuleDefinition(root, factory) {
    if ((typeof module === 'undefined' ? 'undefined' : _typeof2(module)) === 'object') module.exports = factory();else if (typeof define === 'function' && define.amd) define([], factory);else if ((typeof exports === 'undefined' ? 'undefined' : _typeof2(exports)) === 'object') exports["remote-redux-devtools"] = factory();else root["remote-redux-devtools"] = factory();
})(undefined, function () {
    return (/******/function (modules) {
            // webpackBootstrap
            /******/ // The module cache
            /******/var installedModules = {};

            /******/ // The require function
            /******/function __webpack_require__(moduleId) {

                /******/ // Check if module is in cache
                /******/if (installedModules[moduleId])
                    /******/return installedModules[moduleId].exports;

                /******/ // Create a new module (and put it into the cache)
                /******/var module = installedModules[moduleId] = {
                    /******/exports: {},
                    /******/id: moduleId,
                    /******/loaded: false
                    /******/
                };

                /******/ // Execute the module function
                /******/modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

                /******/ // Flag the module as loaded
                /******/module.loaded = true;

                /******/ // Return the exports of the module
                /******/return module.exports;
                /******/
            }

            /******/ // expose the modules object (__webpack_modules__)
            /******/__webpack_require__.m = modules;

            /******/ // expose the module cache
            /******/__webpack_require__.c = installedModules;

            /******/ // __webpack_public_path__
            /******/__webpack_require__.p = "";

            /******/ // Load entry module and return exports
            /******/return __webpack_require__(0);
            /******/
        }(
        /************************************************************************/
        /******/[
        /* 0 */
        /***/function (module, exports, __webpack_require__) {

            'use strict';

            exports.__esModule = true;
            exports.composeWithDevTools = exports.default = undefined;

            var _devTools = __webpack_require__(54);

            Object.defineProperty(exports, 'composeWithDevTools', {
                enumerable: true,
                get: function get() {
                    return _devTools.composeWithDevTools;
                }
            });

            var _devTools2 = _interopRequireDefault(_devTools);

            function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : { default: obj };
            }

            exports.default = _devTools2.default;

            /***/
        },
        /* 1 */
        /***/function (module, exports, __webpack_require__) {

            var freeGlobal = __webpack_require__(39);

            /** Detect free variable `self`. */
            var freeSelf = (typeof self === 'undefined' ? 'undefined' : _typeof2(self)) == 'object' && self && self.Object === Object && self;

            /** Used as a reference to the global object. */
            var root = freeGlobal || freeSelf || Function('return this')();

            module.exports = root;

            /***/
        },
        /* 2 */
        /***/function (module, exports, __webpack_require__) {

            var baseIsNative = __webpack_require__(90),
                getValue = __webpack_require__(110);

            /**
             * Gets the native function at `key` of `object`.
             *
             * @private
             * @param {Object} object The object to query.
             * @param {string} key The key of the method to get.
             * @returns {*} Returns the function if it's native, else `undefined`.
             */
            function getNative(object, key) {
                var value = getValue(object, key);
                return baseIsNative(value) ? value : undefined;
            }

            module.exports = getNative;

            /***/
        },
        /* 3 */
        /***/function (module, exports) {

            /**
             * Checks if `value` is classified as an `Array` object.
             *
             * @static
             * @memberOf _
             * @since 0.1.0
             * @category Lang
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is an array, else `false`.
             * @example
             *
             * _.isArray([1, 2, 3]);
             * // => true
             *
             * _.isArray(document.body.children);
             * // => false
             *
             * _.isArray('abc');
             * // => false
             *
             * _.isArray(_.noop);
             * // => false
             */
            var isArray = Array.isArray;

            module.exports = isArray;

            /***/
        },
        /* 4 */
        /***/function (module, exports) {

            /**
             * Checks if `value` is object-like. A value is object-like if it's not `null`
             * and has a `typeof` result of "object".
             *
             * @static
             * @memberOf _
             * @since 4.0.0
             * @category Lang
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
             * @example
             *
             * _.isObjectLike({});
             * // => true
             *
             * _.isObjectLike([1, 2, 3]);
             * // => true
             *
             * _.isObjectLike(_.noop);
             * // => false
             *
             * _.isObjectLike(null);
             * // => false
             */
            function isObjectLike(value) {
                return value != null && (typeof value === 'undefined' ? 'undefined' : _typeof2(value)) == 'object';
            }

            module.exports = isObjectLike;

            /***/
        },
        /* 5 */
        /***/function (module, exports, __webpack_require__) {

            var listCacheClear = __webpack_require__(121),
                listCacheDelete = __webpack_require__(122),
                listCacheGet = __webpack_require__(123),
                listCacheHas = __webpack_require__(124),
                listCacheSet = __webpack_require__(125);

            /**
             * Creates an list cache object.
             *
             * @private
             * @constructor
             * @param {Array} [entries] The key-value pairs to cache.
             */
            function ListCache(entries) {
                var index = -1,
                    length = entries ? entries.length : 0;

                this.clear();
                while (++index < length) {
                    var entry = entries[index];
                    this.set(entry[0], entry[1]);
                }
            }

            // Add methods to `ListCache`.
            ListCache.prototype.clear = listCacheClear;
            ListCache.prototype['delete'] = listCacheDelete;
            ListCache.prototype.get = listCacheGet;
            ListCache.prototype.has = listCacheHas;
            ListCache.prototype.set = listCacheSet;

            module.exports = ListCache;

            /***/
        },
        /* 6 */
        /***/function (module, exports, __webpack_require__) {

            var eq = __webpack_require__(45);

            /**
             * Gets the index at which the `key` is found in `array` of key-value pairs.
             *
             * @private
             * @param {Array} array The array to inspect.
             * @param {*} key The key to search for.
             * @returns {number} Returns the index of the matched value, else `-1`.
             */
            function assocIndexOf(array, key) {
                var length = array.length;
                while (length--) {
                    if (eq(array[length][0], key)) {
                        return length;
                    }
                }
                return -1;
            }

            module.exports = assocIndexOf;

            /***/
        },
        /* 7 */
        /***/function (module, exports, __webpack_require__) {

            var isKeyable = __webpack_require__(118);

            /**
             * Gets the data for `map`.
             *
             * @private
             * @param {Object} map The map to query.
             * @param {string} key The reference key.
             * @returns {*} Returns the map data.
             */
            function getMapData(map, key) {
                var data = map.__data__;
                return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
            }

            module.exports = getMapData;

            /***/
        },
        /* 8 */
        /***/function (module, exports, __webpack_require__) {

            var isArray = __webpack_require__(3),
                isSymbol = __webpack_require__(23);

            /** Used to match property names within property paths. */
            var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
                reIsPlainProp = /^\w*$/;

            /**
             * Checks if `value` is a property name and not a property path.
             *
             * @private
             * @param {*} value The value to check.
             * @param {Object} [object] The object to query keys on.
             * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
             */
            function isKey(value, object) {
                if (isArray(value)) {
                    return false;
                }
                var type = typeof value === 'undefined' ? 'undefined' : _typeof2(value);
                if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {
                    return true;
                }
                return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
            }

            module.exports = isKey;

            /***/
        },
        /* 9 */
        /***/function (module, exports, __webpack_require__) {

            var getNative = __webpack_require__(2);

            /* Built-in method references that are verified to be native. */
            var nativeCreate = getNative(Object, 'create');

            module.exports = nativeCreate;

            /***/
        },
        /* 10 */
        /***/function (module, exports, __webpack_require__) {

            var isSymbol = __webpack_require__(23);

            /** Used as references for various `Number` constants. */
            var INFINITY = 1 / 0;

            /**
             * Converts `value` to a string key if it's not a string or symbol.
             *
             * @private
             * @param {*} value The value to inspect.
             * @returns {string|symbol} Returns the key.
             */
            function toKey(value) {
                if (typeof value == 'string' || isSymbol(value)) {
                    return value;
                }
                var result = value + '';
                return result == '0' && 1 / value == -INFINITY ? '-0' : result;
            }

            module.exports = toKey;

            /***/
        },
        /* 11 */
        /***/function (module, exports) {

            /**
             * Checks if `value` is the
             * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
             * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
             *
             * @static
             * @memberOf _
             * @since 0.1.0
             * @category Lang
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is an object, else `false`.
             * @example
             *
             * _.isObject({});
             * // => true
             *
             * _.isObject([1, 2, 3]);
             * // => true
             *
             * _.isObject(_.noop);
             * // => true
             *
             * _.isObject(null);
             * // => false
             */
            function isObject(value) {
                var type = typeof value === 'undefined' ? 'undefined' : _typeof2(value);
                return value != null && (type == 'object' || type == 'function');
            }

            module.exports = isObject;

            /***/
        },
        /* 12 */
        /***/function (module, exports, __webpack_require__) {

            var Emitter = __webpack_require__(58);

            if (!Object.create) {
                Object.create = __webpack_require__(167);
            }

            var SCEmitter = function SCEmitter() {
                Emitter.call(this);
            };

            SCEmitter.prototype = Object.create(Emitter.prototype);

            SCEmitter.prototype.emit = function (event) {
                if (event == 'error' && this.domain) {
                    // Emit the error on the domain if it has one.
                    // See https://github.com/joyent/node/blob/ef4344311e19a4f73c031508252b21712b22fe8a/lib/events.js#L78-85

                    var err = arguments[1];

                    if (!err) {
                        err = new Error('Uncaught, unspecified "error" event.');
                    }
                    err.domainEmitter = this;
                    err.domain = this.domain;
                    err.domainThrown = false;
                    this.domain.emit('error', err);
                }
                Emitter.prototype.emit.apply(this, arguments);
            };

            module.exports.SCEmitter = SCEmitter;

            /***/
        },
        /* 13 */
        /***/function (module, exports, __webpack_require__) {

            var getNative = __webpack_require__(2),
                root = __webpack_require__(1);

            /* Built-in method references that are verified to be native. */
            var Map = getNative(root, 'Map');

            module.exports = Map;

            /***/
        },
        /* 14 */
        /***/function (module, exports, __webpack_require__) {

            var mapCacheClear = __webpack_require__(126),
                mapCacheDelete = __webpack_require__(127),
                mapCacheGet = __webpack_require__(128),
                mapCacheHas = __webpack_require__(129),
                mapCacheSet = __webpack_require__(130);

            /**
             * Creates a map cache object to store key-value pairs.
             *
             * @private
             * @constructor
             * @param {Array} [entries] The key-value pairs to cache.
             */
            function MapCache(entries) {
                var index = -1,
                    length = entries ? entries.length : 0;

                this.clear();
                while (++index < length) {
                    var entry = entries[index];
                    this.set(entry[0], entry[1]);
                }
            }

            // Add methods to `MapCache`.
            MapCache.prototype.clear = mapCacheClear;
            MapCache.prototype['delete'] = mapCacheDelete;
            MapCache.prototype.get = mapCacheGet;
            MapCache.prototype.has = mapCacheHas;
            MapCache.prototype.set = mapCacheSet;

            module.exports = MapCache;

            /***/
        },
        /* 15 */
        /***/function (module, exports, __webpack_require__) {

            var MapCache = __webpack_require__(14),
                setCacheAdd = __webpack_require__(137),
                setCacheHas = __webpack_require__(138);

            /**
             *
             * Creates an array cache object to store unique values.
             *
             * @private
             * @constructor
             * @param {Array} [values] The values to cache.
             */
            function SetCache(values) {
                var index = -1,
                    length = values ? values.length : 0;

                this.__data__ = new MapCache();
                while (++index < length) {
                    this.add(values[index]);
                }
            }

            // Add methods to `SetCache`.
            SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
            SetCache.prototype.has = setCacheHas;

            module.exports = SetCache;

            /***/
        },
        /* 16 */
        /***/function (module, exports, __webpack_require__) {

            var root = __webpack_require__(1);

            /** Built-in value references. */
            var _Symbol = root.Symbol;

            module.exports = _Symbol;

            /***/
        },
        /* 17 */
        /***/function (module, exports) {

            /**
             * Checks if a `cache` value for `key` exists.
             *
             * @private
             * @param {Object} cache The cache to query.
             * @param {string} key The key of the entry to check.
             * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
             */
            function cacheHas(cache, key) {
                return cache.has(key);
            }

            module.exports = cacheHas;

            /***/
        },
        /* 18 */
        /***/function (module, exports) {

            /**
             * Converts `set` to an array of its values.
             *
             * @private
             * @param {Object} set The set to convert.
             * @returns {Array} Returns the values.
             */
            function setToArray(set) {
                var index = -1,
                    result = Array(set.size);

                set.forEach(function (value) {
                    result[++index] = value;
                });
                return result;
            }

            module.exports = setToArray;

            /***/
        },
        /* 19 */
        /***/function (module, exports) {

            /**
             * This method returns the first argument it receives.
             *
             * @static
             * @since 0.1.0
             * @memberOf _
             * @category Util
             * @param {*} value Any value.
             * @returns {*} Returns `value`.
             * @example
             *
             * var object = { 'a': 1 };
             *
             * console.log(_.identity(object) === object);
             * // => true
             */
            function identity(value) {
                return value;
            }

            module.exports = identity;

            /***/
        },
        /* 20 */
        /***/function (module, exports, __webpack_require__) {

            var isArrayLikeObject = __webpack_require__(21);

            /** `Object#toString` result references. */
            var argsTag = '[object Arguments]';

            /** Used for built-in method references. */
            var objectProto = Object.prototype;

            /** Used to check objects for own properties. */
            var hasOwnProperty = objectProto.hasOwnProperty;

            /**
             * Used to resolve the
             * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
             * of values.
             */
            var objectToString = objectProto.toString;

            /** Built-in value references. */
            var propertyIsEnumerable = objectProto.propertyIsEnumerable;

            /**
             * Checks if `value` is likely an `arguments` object.
             *
             * @static
             * @memberOf _
             * @since 0.1.0
             * @category Lang
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is an `arguments` object,
             *  else `false`.
             * @example
             *
             * _.isArguments(function() { return arguments; }());
             * // => true
             *
             * _.isArguments([1, 2, 3]);
             * // => false
             */
            function isArguments(value) {
                // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
                return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') && (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
            }

            module.exports = isArguments;

            /***/
        },
        /* 21 */
        /***/function (module, exports, __webpack_require__) {

            var isArrayLike = __webpack_require__(46),
                isObjectLike = __webpack_require__(4);

            /**
             * This method is like `_.isArrayLike` except that it also checks if `value`
             * is an object.
             *
             * @static
             * @memberOf _
             * @since 4.0.0
             * @category Lang
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is an array-like object,
             *  else `false`.
             * @example
             *
             * _.isArrayLikeObject([1, 2, 3]);
             * // => true
             *
             * _.isArrayLikeObject(document.body.children);
             * // => true
             *
             * _.isArrayLikeObject('abc');
             * // => false
             *
             * _.isArrayLikeObject(_.noop);
             * // => false
             */
            function isArrayLikeObject(value) {
                return isObjectLike(value) && isArrayLike(value);
            }

            module.exports = isArrayLikeObject;

            /***/
        },
        /* 22 */
        /***/function (module, exports) {

            /** Used as references for various `Number` constants. */
            var MAX_SAFE_INTEGER = 9007199254740991;

            /**
             * Checks if `value` is a valid array-like length.
             *
             * **Note:** This method is loosely based on
             * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
             *
             * @static
             * @memberOf _
             * @since 4.0.0
             * @category Lang
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
             * @example
             *
             * _.isLength(3);
             * // => true
             *
             * _.isLength(Number.MIN_VALUE);
             * // => false
             *
             * _.isLength(Infinity);
             * // => false
             *
             * _.isLength('3');
             * // => false
             */
            function isLength(value) {
                return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
            }

            module.exports = isLength;

            /***/
        },
        /* 23 */
        /***/function (module, exports, __webpack_require__) {

            var isObjectLike = __webpack_require__(4);

            /** `Object#toString` result references. */
            var symbolTag = '[object Symbol]';

            /** Used for built-in method references. */
            var objectProto = Object.prototype;

            /**
             * Used to resolve the
             * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
             * of values.
             */
            var objectToString = objectProto.toString;

            /**
             * Checks if `value` is classified as a `Symbol` primitive or object.
             *
             * @static
             * @memberOf _
             * @since 4.0.0
             * @category Lang
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
             * @example
             *
             * _.isSymbol(Symbol.iterator);
             * // => true
             *
             * _.isSymbol('abc');
             * // => false
             */
            function isSymbol(value) {
                return (typeof value === 'undefined' ? 'undefined' : _typeof2(value)) == 'symbol' || isObjectLike(value) && objectToString.call(value) == symbolTag;
            }

            module.exports = isSymbol;

            /***/
        },
        /* 24 */
        /***/function (module, exports, __webpack_require__) {

            var arrayLikeKeys = __webpack_require__(75),
                baseKeys = __webpack_require__(93),
                isArrayLike = __webpack_require__(46);

            /**
             * Creates an array of the own enumerable property names of `object`.
             *
             * **Note:** Non-object values are coerced to objects. See the
             * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
             * for more details.
             *
             * @static
             * @since 0.1.0
             * @memberOf _
             * @category Object
             * @param {Object} object The object to query.
             * @returns {Array} Returns the array of property names.
             * @example
             *
             * function Foo() {
             *   this.a = 1;
             *   this.b = 2;
             * }
             *
             * Foo.prototype.c = 3;
             *
             * _.keys(new Foo);
             * // => ['a', 'b'] (iteration order is not guaranteed)
             *
             * _.keys('hi');
             * // => ['0', '1']
             */
            function keys(object) {
                return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
            }

            module.exports = keys;

            /***/
        },
        /* 25 */
        /***/function (module, exports, __webpack_require__) {

            var cycle = __webpack_require__(59);

            var isStrict = function () {
                return !this;
            }();

            function AuthTokenExpiredError(message, expiry) {
                if (Error.captureStackTrace && !isStrict) {
                    Error.captureStackTrace(this, arguments.callee);
                } else {
                    this.stack = new Error().stack;
                }
                this.name = 'AuthTokenExpiredError';
                this.message = message;
                this.expiry = expiry;
            };
            AuthTokenExpiredError.prototype = Object.create(Error.prototype);

            function AuthTokenInvalidError(message) {
                if (Error.captureStackTrace && !isStrict) {
                    Error.captureStackTrace(this, arguments.callee);
                } else {
                    this.stack = new Error().stack;
                }
                this.name = 'AuthTokenInvalidError';
                this.message = message;
            };
            AuthTokenInvalidError.prototype = Object.create(Error.prototype);

            function SilentMiddlewareBlockedError(message, type) {
                if (Error.captureStackTrace && !isStrict) {
                    Error.captureStackTrace(this, arguments.callee);
                } else {
                    this.stack = new Error().stack;
                }
                this.name = 'SilentMiddlewareBlockedError';
                this.message = message;
                this.type = type;
            };
            SilentMiddlewareBlockedError.prototype = Object.create(Error.prototype);

            function InvalidActionError(message) {
                if (Error.captureStackTrace && !isStrict) {
                    Error.captureStackTrace(this, arguments.callee);
                } else {
                    this.stack = new Error().stack;
                }
                this.name = 'InvalidActionError';
                this.message = message;
            };
            InvalidActionError.prototype = Object.create(Error.prototype);

            function InvalidArgumentsError(message) {
                if (Error.captureStackTrace && !isStrict) {
                    Error.captureStackTrace(this, arguments.callee);
                } else {
                    this.stack = new Error().stack;
                }
                this.name = 'InvalidArgumentsError';
                this.message = message;
            };
            InvalidArgumentsError.prototype = Object.create(Error.prototype);

            function InvalidOptionsError(message) {
                if (Error.captureStackTrace && !isStrict) {
                    Error.captureStackTrace(this, arguments.callee);
                } else {
                    this.stack = new Error().stack;
                }
                this.name = 'InvalidOptionsError';
                this.message = message;
            };
            InvalidOptionsError.prototype = Object.create(Error.prototype);

            function InvalidMessageError(message) {
                if (Error.captureStackTrace && !isStrict) {
                    Error.captureStackTrace(this, arguments.callee);
                } else {
                    this.stack = new Error().stack;
                }
                this.name = 'InvalidMessageError';
                this.message = message;
            };
            InvalidMessageError.prototype = Object.create(Error.prototype);

            function SocketProtocolError(message, code) {
                if (Error.captureStackTrace && !isStrict) {
                    Error.captureStackTrace(this, arguments.callee);
                } else {
                    this.stack = new Error().stack;
                }
                this.name = 'SocketProtocolError';
                this.message = message;
                this.code = code;
            };
            SocketProtocolError.prototype = Object.create(Error.prototype);

            function ServerProtocolError(message) {
                if (Error.captureStackTrace && !isStrict) {
                    Error.captureStackTrace(this, arguments.callee);
                } else {
                    this.stack = new Error().stack;
                }
                this.name = 'ServerProtocolError';
                this.message = message;
            };
            ServerProtocolError.prototype = Object.create(Error.prototype);

            function HTTPServerError(message) {
                if (Error.captureStackTrace && !isStrict) {
                    Error.captureStackTrace(this, arguments.callee);
                } else {
                    this.stack = new Error().stack;
                }
                this.name = 'HTTPServerError';
                this.message = message;
            };
            HTTPServerError.prototype = Object.create(Error.prototype);

            function ResourceLimitError(message) {
                if (Error.captureStackTrace && !isStrict) {
                    Error.captureStackTrace(this, arguments.callee);
                } else {
                    this.stack = new Error().stack;
                }
                this.name = 'ResourceLimitError';
                this.message = message;
            };
            ResourceLimitError.prototype = Object.create(Error.prototype);

            function TimeoutError(message) {
                if (Error.captureStackTrace && !isStrict) {
                    Error.captureStackTrace(this, arguments.callee);
                } else {
                    this.stack = new Error().stack;
                }
                this.name = 'TimeoutError';
                this.message = message;
            };
            TimeoutError.prototype = Object.create(Error.prototype);

            function BrokerError(message) {
                if (Error.captureStackTrace && !isStrict) {
                    Error.captureStackTrace(this, arguments.callee);
                } else {
                    this.stack = new Error().stack;
                }
                this.name = 'BrokerError';
                this.message = message;
            };
            BrokerError.prototype = Object.create(Error.prototype);

            function ProcessExitError(message, code) {
                if (Error.captureStackTrace && !isStrict) {
                    Error.captureStackTrace(this, arguments.callee);
                } else {
                    this.stack = new Error().stack;
                }
                this.name = 'ProcessExitError';
                this.message = message;
                this.code = code;
            };
            ProcessExitError.prototype = Object.create(Error.prototype);

            function UnknownError(message) {
                if (Error.captureStackTrace && !isStrict) {
                    Error.captureStackTrace(this, arguments.callee);
                } else {
                    this.stack = new Error().stack;
                }
                this.name = 'UnknownError';
                this.message = message;
            };
            UnknownError.prototype = Object.create(Error.prototype);

            // Expose all error types

            module.exports = {
                AuthTokenExpiredError: AuthTokenExpiredError,
                AuthTokenInvalidError: AuthTokenInvalidError,
                SilentMiddlewareBlockedError: SilentMiddlewareBlockedError,
                InvalidActionError: InvalidActionError,
                InvalidArgumentsError: InvalidArgumentsError,
                InvalidOptionsError: InvalidOptionsError,
                InvalidMessageError: InvalidMessageError,
                SocketProtocolError: SocketProtocolError,
                ServerProtocolError: ServerProtocolError,
                HTTPServerError: HTTPServerError,
                ResourceLimitError: ResourceLimitError,
                TimeoutError: TimeoutError,
                BrokerError: BrokerError,
                ProcessExitError: ProcessExitError,
                UnknownError: UnknownError
            };

            module.exports.socketProtocolErrorStatuses = {
                1001: 'Socket was disconnected',
                1002: 'A WebSocket protocol error was encountered',
                1003: 'Server terminated socket because it received invalid data',
                1005: 'Socket closed without status code',
                1006: 'Socket hung up',
                1007: 'Message format was incorrect',
                1008: 'Encountered a policy violation',
                1009: 'Message was too big to process',
                1010: 'Client ended the connection because the server did not comply with extension requirements',
                1011: 'Server encountered an unexpected fatal condition',
                4000: 'Server ping timed out',
                4001: 'Client pong timed out',
                4002: 'Server failed to sign auth token',
                4003: 'Failed to complete handshake',
                4004: 'Client failed to save auth token',
                4005: 'Did not receive #handshake from client before timeout',
                4006: 'Failed to bind socket to message broker',
                4007: 'Client connection establishment timed out'
            };

            module.exports.socketProtocolIgnoreStatuses = {
                1000: 'Socket closed normally',
                1001: 'Socket hung up'
            };

            // Properties related to error domains cannot be serialized.
            var unserializableErrorProperties = {
                domain: 1,
                domainEmitter: 1,
                domainThrown: 1
            };

            module.exports.dehydrateError = function (error, includeStackTrace) {
                var dehydratedError;
                if (typeof error == 'string') {
                    dehydratedError = error;
                } else {
                    dehydratedError = {
                        message: error.message
                    };
                    if (includeStackTrace) {
                        dehydratedError.stack = error.stack;
                    }
                    for (var i in error) {
                        if (!unserializableErrorProperties[i]) {
                            dehydratedError[i] = error[i];
                        }
                    }
                }
                return cycle.decycle(dehydratedError);
            };

            module.exports.hydrateError = function (error) {
                var hydratedError = null;
                if (error != null) {
                    if (typeof error == 'string') {
                        hydratedError = error;
                    } else {
                        hydratedError = new Error(error.message);
                        for (var i in error) {
                            if (error.hasOwnProperty(i)) {
                                hydratedError[i] = error[i];
                            }
                        }
                    }
                }
                return hydratedError;
            };

            /***/
        },
        /* 26 */
        /***/function (module, exports, __webpack_require__) {

            /* WEBPACK VAR INJECTION */(function (Buffer, global) {
                /*!
                * The buffer module from node.js, for the browser.
                *
                * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
                * @license  MIT
                */
                /* eslint-disable no-proto */

                'use strict';

                var base64 = __webpack_require__(57);
                var ieee754 = __webpack_require__(61);
                var isArray = __webpack_require__(62);

                exports.Buffer = Buffer;
                exports.SlowBuffer = SlowBuffer;
                exports.INSPECT_MAX_BYTES = 50;

                /**
                 * If `Buffer.TYPED_ARRAY_SUPPORT`:
                 *   === true    Use Uint8Array implementation (fastest)
                 *   === false   Use Object implementation (most compatible, even IE6)
                 *
                 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
                 * Opera 11.6+, iOS 4.2+.
                 *
                 * Due to various browser bugs, sometimes the Object implementation will be used even
                 * when the browser supports typed arrays.
                 *
                 * Note:
                 *
                 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
                 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
                 *
                 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
                 *
                 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
                 *     incorrect length in some situations.
                                  * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
                 * get the Object implementation, which is slower but behaves correctly.
                 */
                Buffer.TYPED_ARRAY_SUPPORT = typeof TYPED_ARRAY_SUPPORT !== 'undefined' ? TYPED_ARRAY_SUPPORT : typedArraySupport();

                /*
                 * Export kMaxLength after typed array support is determined.
                 */
                exports.kMaxLength = kMaxLength();

                function typedArraySupport() {
                    try {
                        var arr = new Uint8Array(1);
                        arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function foo() {
                                return 42;
                            } };
                        return arr.foo() === 42 && // typed array instances can be augmented
                        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
                        arr.subarray(1, 1).byteLength === 0; // ie10 has broken `subarray`
                    } catch (e) {
                        return false;
                    }
                }

                function kMaxLength() {
                    return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
                }

                function createBuffer(that, length) {
                    if (kMaxLength() < length) {
                        throw new RangeError('Invalid typed array length');
                    }
                    if (Buffer.TYPED_ARRAY_SUPPORT) {
                        // Return an augmented `Uint8Array` instance, for best performance
                        that = new Uint8Array(length);
                        that.__proto__ = Buffer.prototype;
                    } else {
                        // Fallback: Return an object instance of the Buffer class
                        if (that === null) {
                            that = new Buffer(length);
                        }
                        that.length = length;
                    }

                    return that;
                }

                /**
                 * The Buffer constructor returns instances of `Uint8Array` that have their
                 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
                 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
                 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
                 * returns a single octet.
                 *
                 * The `Uint8Array` prototype remains unmodified.
                 */

                function Buffer(arg, encodingOrOffset, length) {
                    if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
                        return new Buffer(arg, encodingOrOffset, length);
                    }

                    // Common case.
                    if (typeof arg === 'number') {
                        if (typeof encodingOrOffset === 'string') {
                            throw new Error('If encoding is specified then the first argument must be a string');
                        }
                        return allocUnsafe(this, arg);
                    }
                    return from(this, arg, encodingOrOffset, length);
                }

                Buffer.poolSize = 8192; // not used by this implementation

                // TODO: Legacy, not needed anymore. Remove in next major version.
                Buffer._augment = function (arr) {
                    arr.__proto__ = Buffer.prototype;
                    return arr;
                };

                function from(that, value, encodingOrOffset, length) {
                    if (typeof value === 'number') {
                        throw new TypeError('"value" argument must not be a number');
                    }

                    if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
                        return fromArrayBuffer(that, value, encodingOrOffset, length);
                    }

                    if (typeof value === 'string') {
                        return fromString(that, value, encodingOrOffset);
                    }

                    return fromObject(that, value);
                }

                /**
                 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
                 * if value is a number.
                 * Buffer.from(str[, encoding])
                 * Buffer.from(array)
                 * Buffer.from(buffer)
                 * Buffer.from(arrayBuffer[, byteOffset[, length]])
                 **/
                Buffer.from = function (value, encodingOrOffset, length) {
                    return from(null, value, encodingOrOffset, length);
                };

                if (Buffer.TYPED_ARRAY_SUPPORT) {
                    Buffer.prototype.__proto__ = Uint8Array.prototype;
                    Buffer.__proto__ = Uint8Array;
                    if (typeof Symbol !== 'undefined' && Symbol.species && Buffer[Symbol.species] === Buffer) {
                        // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
                        Object.defineProperty(Buffer, Symbol.species, {
                            value: null,
                            configurable: true
                        });
                    }
                }

                function assertSize(size) {
                    if (typeof size !== 'number') {
                        throw new TypeError('"size" argument must be a number');
                    } else if (size < 0) {
                        throw new RangeError('"size" argument must not be negative');
                    }
                }

                function alloc(that, size, fill, encoding) {
                    assertSize(size);
                    if (size <= 0) {
                        return createBuffer(that, size);
                    }
                    if (fill !== undefined) {
                        // Only pay attention to encoding if it's a string. This
                        // prevents accidentally sending in a number that would
                        // be interpretted as a start offset.
                        return typeof encoding === 'string' ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
                    }
                    return createBuffer(that, size);
                }

                /**
                 * Creates a new filled Buffer instance.
                 * alloc(size[, fill[, encoding]])
                 **/
                Buffer.alloc = function (size, fill, encoding) {
                    return alloc(null, size, fill, encoding);
                };

                function allocUnsafe(that, size) {
                    assertSize(size);
                    that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
                    if (!Buffer.TYPED_ARRAY_SUPPORT) {
                        for (var i = 0; i < size; ++i) {
                            that[i] = 0;
                        }
                    }
                    return that;
                }

                /**
                 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
                 * */
                Buffer.allocUnsafe = function (size) {
                    return allocUnsafe(null, size);
                };
                /**
                 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
                 */
                Buffer.allocUnsafeSlow = function (size) {
                    return allocUnsafe(null, size);
                };

                function fromString(that, string, encoding) {
                    if (typeof encoding !== 'string' || encoding === '') {
                        encoding = 'utf8';
                    }

                    if (!Buffer.isEncoding(encoding)) {
                        throw new TypeError('"encoding" must be a valid string encoding');
                    }

                    var length = byteLength(string, encoding) | 0;
                    that = createBuffer(that, length);

                    var actual = that.write(string, encoding);

                    if (actual !== length) {
                        // Writing a hex string, for example, that contains invalid characters will
                        // cause everything after the first invalid character to be ignored. (e.g.
                        // 'abxxcd' will be treated as 'ab')
                        that = that.slice(0, actual);
                    }

                    return that;
                }

                function fromArrayLike(that, array) {
                    var length = array.length < 0 ? 0 : checked(array.length) | 0;
                    that = createBuffer(that, length);
                    for (var i = 0; i < length; i += 1) {
                        that[i] = array[i] & 255;
                    }
                    return that;
                }

                function fromArrayBuffer(that, array, byteOffset, length) {
                    array.byteLength; // this throws if `array` is not a valid ArrayBuffer

                    if (byteOffset < 0 || array.byteLength < byteOffset) {
                        throw new RangeError('\'offset\' is out of bounds');
                    }

                    if (array.byteLength < byteOffset + (length || 0)) {
                        throw new RangeError('\'length\' is out of bounds');
                    }

                    if (byteOffset === undefined && length === undefined) {
                        array = new Uint8Array(array);
                    } else if (length === undefined) {
                        array = new Uint8Array(array, byteOffset);
                    } else {
                        array = new Uint8Array(array, byteOffset, length);
                    }

                    if (Buffer.TYPED_ARRAY_SUPPORT) {
                        // Return an augmented `Uint8Array` instance, for best performance
                        that = array;
                        that.__proto__ = Buffer.prototype;
                    } else {
                        // Fallback: Return an object instance of the Buffer class
                        that = fromArrayLike(that, array);
                    }
                    return that;
                }

                function fromObject(that, obj) {
                    if (Buffer.isBuffer(obj)) {
                        var len = checked(obj.length) | 0;
                        that = createBuffer(that, len);

                        if (that.length === 0) {
                            return that;
                        }

                        obj.copy(that, 0, 0, len);
                        return that;
                    }

                    if (obj) {
                        if (typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer || 'length' in obj) {
                            if (typeof obj.length !== 'number' || isnan(obj.length)) {
                                return createBuffer(that, 0);
                            }
                            return fromArrayLike(that, obj);
                        }

                        if (obj.type === 'Buffer' && isArray(obj.data)) {
                            return fromArrayLike(that, obj.data);
                        }
                    }

                    throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');
                }

                function checked(length) {
                    // Note: cannot use `length < kMaxLength()` here because that fails when
                    // length is NaN (which is otherwise coerced to zero.)
                    if (length >= kMaxLength()) {
                        throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');
                    }
                    return length | 0;
                }

                function SlowBuffer(length) {
                    if (+length != length) {
                        // eslint-disable-line eqeqeq
                        length = 0;
                    }
                    return Buffer.alloc(+length);
                }

                Buffer.isBuffer = function isBuffer(b) {
                    return !!(b != null && b._isBuffer);
                };

                Buffer.compare = function compare(a, b) {
                    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
                        throw new TypeError('Arguments must be Buffers');
                    }

                    if (a === b) return 0;

                    var x = a.length;
                    var y = b.length;

                    for (var i = 0, len = Math.min(x, y); i < len; ++i) {
                        if (a[i] !== b[i]) {
                            x = a[i];
                            y = b[i];
                            break;
                        }
                    }

                    if (x < y) return -1;
                    if (y < x) return 1;
                    return 0;
                };

                Buffer.isEncoding = function isEncoding(encoding) {
                    switch (String(encoding).toLowerCase()) {
                        case 'hex':
                        case 'utf8':
                        case 'utf-8':
                        case 'ascii':
                        case 'latin1':
                        case 'binary':
                        case 'base64':
                        case 'ucs2':
                        case 'ucs-2':
                        case 'utf16le':
                        case 'utf-16le':
                            return true;
                        default:
                            return false;
                    }
                };

                Buffer.concat = function concat(list, length) {
                    if (!isArray(list)) {
                        throw new TypeError('"list" argument must be an Array of Buffers');
                    }

                    if (list.length === 0) {
                        return Buffer.alloc(0);
                    }

                    var i;
                    if (length === undefined) {
                        length = 0;
                        for (i = 0; i < list.length; ++i) {
                            length += list[i].length;
                        }
                    }

                    var buffer = Buffer.allocUnsafe(length);
                    var pos = 0;
                    for (i = 0; i < list.length; ++i) {
                        var buf = list[i];
                        if (!Buffer.isBuffer(buf)) {
                            throw new TypeError('"list" argument must be an Array of Buffers');
                        }
                        buf.copy(buffer, pos);
                        pos += buf.length;
                    }
                    return buffer;
                };

                function byteLength(string, encoding) {
                    if (Buffer.isBuffer(string)) {
                        return string.length;
                    }
                    if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
                        return string.byteLength;
                    }
                    if (typeof string !== 'string') {
                        string = '' + string;
                    }

                    var len = string.length;
                    if (len === 0) return 0;

                    // Use a for loop to avoid recursion
                    var loweredCase = false;
                    for (;;) {
                        switch (encoding) {
                            case 'ascii':
                            case 'latin1':
                            case 'binary':
                                return len;
                            case 'utf8':
                            case 'utf-8':
                            case undefined:
                                return utf8ToBytes(string).length;
                            case 'ucs2':
                            case 'ucs-2':
                            case 'utf16le':
                            case 'utf-16le':
                                return len * 2;
                            case 'hex':
                                return len >>> 1;
                            case 'base64':
                                return base64ToBytes(string).length;
                            default:
                                if (loweredCase) return utf8ToBytes(string).length; // assume utf8
                                encoding = ('' + encoding).toLowerCase();
                                loweredCase = true;
                        }
                    }
                }
                Buffer.byteLength = byteLength;

                function slowToString(encoding, start, end) {
                    var loweredCase = false;

                    // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
                    // property of a typed array.

                    // This behaves neither like String nor Uint8Array in that we set start/end
                    // to their upper/lower bounds if the value passed is out of range.
                    // undefined is handled specially as per ECMA-262 6th Edition,
                    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
                    if (start === undefined || start < 0) {
                        start = 0;
                    }
                    // Return early if start > this.length. Done here to prevent potential uint32
                    // coercion fail below.
                    if (start > this.length) {
                        return '';
                    }

                    if (end === undefined || end > this.length) {
                        end = this.length;
                    }

                    if (end <= 0) {
                        return '';
                    }

                    // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
                    end >>>= 0;
                    start >>>= 0;

                    if (end <= start) {
                        return '';
                    }

                    if (!encoding) encoding = 'utf8';

                    while (true) {
                        switch (encoding) {
                            case 'hex':
                                return hexSlice(this, start, end);

                            case 'utf8':
                            case 'utf-8':
                                return utf8Slice(this, start, end);

                            case 'ascii':
                                return asciiSlice(this, start, end);

                            case 'latin1':
                            case 'binary':
                                return latin1Slice(this, start, end);

                            case 'base64':
                                return base64Slice(this, start, end);

                            case 'ucs2':
                            case 'ucs-2':
                            case 'utf16le':
                            case 'utf-16le':
                                return utf16leSlice(this, start, end);

                            default:
                                if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
                                encoding = (encoding + '').toLowerCase();
                                loweredCase = true;
                        }
                    }
                }

                // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
                // Buffer instances.
                Buffer.prototype._isBuffer = true;

                function swap(b, n, m) {
                    var i = b[n];
                    b[n] = b[m];
                    b[m] = i;
                }

                Buffer.prototype.swap16 = function swap16() {
                    var len = this.length;
                    if (len % 2 !== 0) {
                        throw new RangeError('Buffer size must be a multiple of 16-bits');
                    }
                    for (var i = 0; i < len; i += 2) {
                        swap(this, i, i + 1);
                    }
                    return this;
                };

                Buffer.prototype.swap32 = function swap32() {
                    var len = this.length;
                    if (len % 4 !== 0) {
                        throw new RangeError('Buffer size must be a multiple of 32-bits');
                    }
                    for (var i = 0; i < len; i += 4) {
                        swap(this, i, i + 3);
                        swap(this, i + 1, i + 2);
                    }
                    return this;
                };

                Buffer.prototype.swap64 = function swap64() {
                    var len = this.length;
                    if (len % 8 !== 0) {
                        throw new RangeError('Buffer size must be a multiple of 64-bits');
                    }
                    for (var i = 0; i < len; i += 8) {
                        swap(this, i, i + 7);
                        swap(this, i + 1, i + 6);
                        swap(this, i + 2, i + 5);
                        swap(this, i + 3, i + 4);
                    }
                    return this;
                };

                Buffer.prototype.toString = function toString() {
                    var length = this.length | 0;
                    if (length === 0) return '';
                    if (arguments.length === 0) return utf8Slice(this, 0, length);
                    return slowToString.apply(this, arguments);
                };

                Buffer.prototype.equals = function equals(b) {
                    if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
                    if (this === b) return true;
                    return Buffer.compare(this, b) === 0;
                };

                Buffer.prototype.inspect = function inspect() {
                    var str = '';
                    var max = exports.INSPECT_MAX_BYTES;
                    if (this.length > 0) {
                        str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
                        if (this.length > max) str += ' ... ';
                    }
                    return '<Buffer ' + str + '>';
                };

                Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
                    if (!Buffer.isBuffer(target)) {
                        throw new TypeError('Argument must be a Buffer');
                    }

                    if (start === undefined) {
                        start = 0;
                    }
                    if (end === undefined) {
                        end = target ? target.length : 0;
                    }
                    if (thisStart === undefined) {
                        thisStart = 0;
                    }
                    if (thisEnd === undefined) {
                        thisEnd = this.length;
                    }

                    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
                        throw new RangeError('out of range index');
                    }

                    if (thisStart >= thisEnd && start >= end) {
                        return 0;
                    }
                    if (thisStart >= thisEnd) {
                        return -1;
                    }
                    if (start >= end) {
                        return 1;
                    }

                    start >>>= 0;
                    end >>>= 0;
                    thisStart >>>= 0;
                    thisEnd >>>= 0;

                    if (this === target) return 0;

                    var x = thisEnd - thisStart;
                    var y = end - start;
                    var len = Math.min(x, y);

                    var thisCopy = this.slice(thisStart, thisEnd);
                    var targetCopy = target.slice(start, end);

                    for (var i = 0; i < len; ++i) {
                        if (thisCopy[i] !== targetCopy[i]) {
                            x = thisCopy[i];
                            y = targetCopy[i];
                            break;
                        }
                    }

                    if (x < y) return -1;
                    if (y < x) return 1;
                    return 0;
                };

                // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
                // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
                //
                // Arguments:
                // - buffer - a Buffer to search
                // - val - a string, Buffer, or number
                // - byteOffset - an index into `buffer`; will be clamped to an int32
                // - encoding - an optional encoding, relevant is val is a string
                // - dir - true for indexOf, false for lastIndexOf
                function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
                    // Empty buffer means no match
                    if (buffer.length === 0) return -1;

                    // Normalize byteOffset
                    if (typeof byteOffset === 'string') {
                        encoding = byteOffset;
                        byteOffset = 0;
                    } else if (byteOffset > 0x7fffffff) {
                        byteOffset = 0x7fffffff;
                    } else if (byteOffset < -0x80000000) {
                        byteOffset = -0x80000000;
                    }
                    byteOffset = +byteOffset; // Coerce to Number.
                    if (isNaN(byteOffset)) {
                        // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
                        byteOffset = dir ? 0 : buffer.length - 1;
                    }

                    // Normalize byteOffset: negative offsets start from the end of the buffer
                    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
                    if (byteOffset >= buffer.length) {
                        if (dir) return -1;else byteOffset = buffer.length - 1;
                    } else if (byteOffset < 0) {
                        if (dir) byteOffset = 0;else return -1;
                    }

                    // Normalize val
                    if (typeof val === 'string') {
                        val = Buffer.from(val, encoding);
                    }

                    // Finally, search either indexOf (if dir is true) or lastIndexOf
                    if (Buffer.isBuffer(val)) {
                        // Special case: looking for empty string/buffer always fails
                        if (val.length === 0) {
                            return -1;
                        }
                        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
                    } else if (typeof val === 'number') {
                        val = val & 0xFF; // Search for a byte value [0-255]
                        if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function') {
                            if (dir) {
                                return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
                            } else {
                                return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
                            }
                        }
                        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
                    }

                    throw new TypeError('val must be string, number or Buffer');
                }

                function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
                    var indexSize = 1;
                    var arrLength = arr.length;
                    var valLength = val.length;

                    if (encoding !== undefined) {
                        encoding = String(encoding).toLowerCase();
                        if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
                            if (arr.length < 2 || val.length < 2) {
                                return -1;
                            }
                            indexSize = 2;
                            arrLength /= 2;
                            valLength /= 2;
                            byteOffset /= 2;
                        }
                    }

                    function read(buf, i) {
                        if (indexSize === 1) {
                            return buf[i];
                        } else {
                            return buf.readUInt16BE(i * indexSize);
                        }
                    }

                    var i;
                    if (dir) {
                        var foundIndex = -1;
                        for (i = byteOffset; i < arrLength; i++) {
                            if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
                                if (foundIndex === -1) foundIndex = i;
                                if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
                            } else {
                                if (foundIndex !== -1) i -= i - foundIndex;
                                foundIndex = -1;
                            }
                        }
                    } else {
                        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
                        for (i = byteOffset; i >= 0; i--) {
                            var found = true;
                            for (var j = 0; j < valLength; j++) {
                                if (read(arr, i + j) !== read(val, j)) {
                                    found = false;
                                    break;
                                }
                            }
                            if (found) return i;
                        }
                    }

                    return -1;
                }

                Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
                    return this.indexOf(val, byteOffset, encoding) !== -1;
                };

                Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
                    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
                };

                Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
                    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
                };

                function hexWrite(buf, string, offset, length) {
                    offset = Number(offset) || 0;
                    var remaining = buf.length - offset;
                    if (!length) {
                        length = remaining;
                    } else {
                        length = Number(length);
                        if (length > remaining) {
                            length = remaining;
                        }
                    }

                    // must be an even number of digits
                    var strLen = string.length;
                    if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');

                    if (length > strLen / 2) {
                        length = strLen / 2;
                    }
                    for (var i = 0; i < length; ++i) {
                        var parsed = parseInt(string.substr(i * 2, 2), 16);
                        if (isNaN(parsed)) return i;
                        buf[offset + i] = parsed;
                    }
                    return i;
                }

                function utf8Write(buf, string, offset, length) {
                    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
                }

                function asciiWrite(buf, string, offset, length) {
                    return blitBuffer(asciiToBytes(string), buf, offset, length);
                }

                function latin1Write(buf, string, offset, length) {
                    return asciiWrite(buf, string, offset, length);
                }

                function base64Write(buf, string, offset, length) {
                    return blitBuffer(base64ToBytes(string), buf, offset, length);
                }

                function ucs2Write(buf, string, offset, length) {
                    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
                }

                Buffer.prototype.write = function write(string, offset, length, encoding) {
                    // Buffer#write(string)
                    if (offset === undefined) {
                        encoding = 'utf8';
                        length = this.length;
                        offset = 0;
                        // Buffer#write(string, encoding)
                    } else if (length === undefined && typeof offset === 'string') {
                        encoding = offset;
                        length = this.length;
                        offset = 0;
                        // Buffer#write(string, offset[, length][, encoding])
                    } else if (isFinite(offset)) {
                        offset = offset | 0;
                        if (isFinite(length)) {
                            length = length | 0;
                            if (encoding === undefined) encoding = 'utf8';
                        } else {
                            encoding = length;
                            length = undefined;
                        }
                        // legacy write(string, encoding, offset, length) - remove in v0.13
                    } else {
                        throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
                    }

                    var remaining = this.length - offset;
                    if (length === undefined || length > remaining) length = remaining;

                    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
                        throw new RangeError('Attempt to write outside buffer bounds');
                    }

                    if (!encoding) encoding = 'utf8';

                    var loweredCase = false;
                    for (;;) {
                        switch (encoding) {
                            case 'hex':
                                return hexWrite(this, string, offset, length);

                            case 'utf8':
                            case 'utf-8':
                                return utf8Write(this, string, offset, length);

                            case 'ascii':
                                return asciiWrite(this, string, offset, length);

                            case 'latin1':
                            case 'binary':
                                return latin1Write(this, string, offset, length);

                            case 'base64':
                                // Warning: maxLength not taken into account in base64Write
                                return base64Write(this, string, offset, length);

                            case 'ucs2':
                            case 'ucs-2':
                            case 'utf16le':
                            case 'utf-16le':
                                return ucs2Write(this, string, offset, length);

                            default:
                                if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
                                encoding = ('' + encoding).toLowerCase();
                                loweredCase = true;
                        }
                    }
                };

                Buffer.prototype.toJSON = function toJSON() {
                    return {
                        type: 'Buffer',
                        data: Array.prototype.slice.call(this._arr || this, 0)
                    };
                };

                function base64Slice(buf, start, end) {
                    if (start === 0 && end === buf.length) {
                        return base64.fromByteArray(buf);
                    } else {
                        return base64.fromByteArray(buf.slice(start, end));
                    }
                }

                function utf8Slice(buf, start, end) {
                    end = Math.min(buf.length, end);
                    var res = [];

                    var i = start;
                    while (i < end) {
                        var firstByte = buf[i];
                        var codePoint = null;
                        var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;

                        if (i + bytesPerSequence <= end) {
                            var secondByte, thirdByte, fourthByte, tempCodePoint;

                            switch (bytesPerSequence) {
                                case 1:
                                    if (firstByte < 0x80) {
                                        codePoint = firstByte;
                                    }
                                    break;
                                case 2:
                                    secondByte = buf[i + 1];
                                    if ((secondByte & 0xC0) === 0x80) {
                                        tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
                                        if (tempCodePoint > 0x7F) {
                                            codePoint = tempCodePoint;
                                        }
                                    }
                                    break;
                                case 3:
                                    secondByte = buf[i + 1];
                                    thirdByte = buf[i + 2];
                                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                                        tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
                                        if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                                            codePoint = tempCodePoint;
                                        }
                                    }
                                    break;
                                case 4:
                                    secondByte = buf[i + 1];
                                    thirdByte = buf[i + 2];
                                    fourthByte = buf[i + 3];
                                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                                        tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
                                        if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                                            codePoint = tempCodePoint;
                                        }
                                    }
                            }
                        }

                        if (codePoint === null) {
                            // we did not generate a valid codePoint so insert a
                            // replacement char (U+FFFD) and advance only 1 byte
                            codePoint = 0xFFFD;
                            bytesPerSequence = 1;
                        } else if (codePoint > 0xFFFF) {
                            // encode to utf16 (surrogate pair dance)
                            codePoint -= 0x10000;
                            res.push(codePoint >>> 10 & 0x3FF | 0xD800);
                            codePoint = 0xDC00 | codePoint & 0x3FF;
                        }

                        res.push(codePoint);
                        i += bytesPerSequence;
                    }

                    return decodeCodePointsArray(res);
                }

                // Based on http://stackoverflow.com/a/22747272/680742, the browser with
                // the lowest limit is Chrome, with 0x10000 args.
                // We go 1 magnitude less, for safety
                var MAX_ARGUMENTS_LENGTH = 0x1000;

                function decodeCodePointsArray(codePoints) {
                    var len = codePoints.length;
                    if (len <= MAX_ARGUMENTS_LENGTH) {
                        return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
                    }

                    // Decode in chunks to avoid "call stack size exceeded".
                    var res = '';
                    var i = 0;
                    while (i < len) {
                        res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
                    }
                    return res;
                }

                function asciiSlice(buf, start, end) {
                    var ret = '';
                    end = Math.min(buf.length, end);

                    for (var i = start; i < end; ++i) {
                        ret += String.fromCharCode(buf[i] & 0x7F);
                    }
                    return ret;
                }

                function latin1Slice(buf, start, end) {
                    var ret = '';
                    end = Math.min(buf.length, end);

                    for (var i = start; i < end; ++i) {
                        ret += String.fromCharCode(buf[i]);
                    }
                    return ret;
                }

                function hexSlice(buf, start, end) {
                    var len = buf.length;

                    if (!start || start < 0) start = 0;
                    if (!end || end < 0 || end > len) end = len;

                    var out = '';
                    for (var i = start; i < end; ++i) {
                        out += toHex(buf[i]);
                    }
                    return out;
                }

                function utf16leSlice(buf, start, end) {
                    var bytes = buf.slice(start, end);
                    var res = '';
                    for (var i = 0; i < bytes.length; i += 2) {
                        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
                    }
                    return res;
                }

                Buffer.prototype.slice = function slice(start, end) {
                    var len = this.length;
                    start = ~~start;
                    end = end === undefined ? len : ~~end;

                    if (start < 0) {
                        start += len;
                        if (start < 0) start = 0;
                    } else if (start > len) {
                        start = len;
                    }

                    if (end < 0) {
                        end += len;
                        if (end < 0) end = 0;
                    } else if (end > len) {
                        end = len;
                    }

                    if (end < start) end = start;

                    var newBuf;
                    if (Buffer.TYPED_ARRAY_SUPPORT) {
                        newBuf = this.subarray(start, end);
                        newBuf.__proto__ = Buffer.prototype;
                    } else {
                        var sliceLen = end - start;
                        newBuf = new Buffer(sliceLen, undefined);
                        for (var i = 0; i < sliceLen; ++i) {
                            newBuf[i] = this[i + start];
                        }
                    }

                    return newBuf;
                };

                /*
                 * Need to make sure that buffer isn't trying to write out of bounds.
                 */
                function checkOffset(offset, ext, length) {
                    if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
                    if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
                }

                Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
                    offset = offset | 0;
                    byteLength = byteLength | 0;
                    if (!noAssert) checkOffset(offset, byteLength, this.length);

                    var val = this[offset];
                    var mul = 1;
                    var i = 0;
                    while (++i < byteLength && (mul *= 0x100)) {
                        val += this[offset + i] * mul;
                    }

                    return val;
                };

                Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
                    offset = offset | 0;
                    byteLength = byteLength | 0;
                    if (!noAssert) {
                        checkOffset(offset, byteLength, this.length);
                    }

                    var val = this[offset + --byteLength];
                    var mul = 1;
                    while (byteLength > 0 && (mul *= 0x100)) {
                        val += this[offset + --byteLength] * mul;
                    }

                    return val;
                };

                Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
                    if (!noAssert) checkOffset(offset, 1, this.length);
                    return this[offset];
                };

                Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
                    if (!noAssert) checkOffset(offset, 2, this.length);
                    return this[offset] | this[offset + 1] << 8;
                };

                Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
                    if (!noAssert) checkOffset(offset, 2, this.length);
                    return this[offset] << 8 | this[offset + 1];
                };

                Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
                    if (!noAssert) checkOffset(offset, 4, this.length);

                    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
                };

                Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
                    if (!noAssert) checkOffset(offset, 4, this.length);

                    return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
                };

                Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
                    offset = offset | 0;
                    byteLength = byteLength | 0;
                    if (!noAssert) checkOffset(offset, byteLength, this.length);

                    var val = this[offset];
                    var mul = 1;
                    var i = 0;
                    while (++i < byteLength && (mul *= 0x100)) {
                        val += this[offset + i] * mul;
                    }
                    mul *= 0x80;

                    if (val >= mul) val -= Math.pow(2, 8 * byteLength);

                    return val;
                };

                Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
                    offset = offset | 0;
                    byteLength = byteLength | 0;
                    if (!noAssert) checkOffset(offset, byteLength, this.length);

                    var i = byteLength;
                    var mul = 1;
                    var val = this[offset + --i];
                    while (i > 0 && (mul *= 0x100)) {
                        val += this[offset + --i] * mul;
                    }
                    mul *= 0x80;

                    if (val >= mul) val -= Math.pow(2, 8 * byteLength);

                    return val;
                };

                Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
                    if (!noAssert) checkOffset(offset, 1, this.length);
                    if (!(this[offset] & 0x80)) return this[offset];
                    return (0xff - this[offset] + 1) * -1;
                };

                Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
                    if (!noAssert) checkOffset(offset, 2, this.length);
                    var val = this[offset] | this[offset + 1] << 8;
                    return val & 0x8000 ? val | 0xFFFF0000 : val;
                };

                Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
                    if (!noAssert) checkOffset(offset, 2, this.length);
                    var val = this[offset + 1] | this[offset] << 8;
                    return val & 0x8000 ? val | 0xFFFF0000 : val;
                };

                Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
                    if (!noAssert) checkOffset(offset, 4, this.length);

                    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
                };

                Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
                    if (!noAssert) checkOffset(offset, 4, this.length);

                    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
                };

                Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
                    if (!noAssert) checkOffset(offset, 4, this.length);
                    return ieee754.read(this, offset, true, 23, 4);
                };

                Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
                    if (!noAssert) checkOffset(offset, 4, this.length);
                    return ieee754.read(this, offset, false, 23, 4);
                };

                Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
                    if (!noAssert) checkOffset(offset, 8, this.length);
                    return ieee754.read(this, offset, true, 52, 8);
                };

                Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
                    if (!noAssert) checkOffset(offset, 8, this.length);
                    return ieee754.read(this, offset, false, 52, 8);
                };

                function checkInt(buf, value, offset, ext, max, min) {
                    if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
                    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
                    if (offset + ext > buf.length) throw new RangeError('Index out of range');
                }

                Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
                    value = +value;
                    offset = offset | 0;
                    byteLength = byteLength | 0;
                    if (!noAssert) {
                        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
                        checkInt(this, value, offset, byteLength, maxBytes, 0);
                    }

                    var mul = 1;
                    var i = 0;
                    this[offset] = value & 0xFF;
                    while (++i < byteLength && (mul *= 0x100)) {
                        this[offset + i] = value / mul & 0xFF;
                    }

                    return offset + byteLength;
                };

                Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
                    value = +value;
                    offset = offset | 0;
                    byteLength = byteLength | 0;
                    if (!noAssert) {
                        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
                        checkInt(this, value, offset, byteLength, maxBytes, 0);
                    }

                    var i = byteLength - 1;
                    var mul = 1;
                    this[offset + i] = value & 0xFF;
                    while (--i >= 0 && (mul *= 0x100)) {
                        this[offset + i] = value / mul & 0xFF;
                    }

                    return offset + byteLength;
                };

                Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
                    value = +value;
                    offset = offset | 0;
                    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
                    if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
                    this[offset] = value & 0xff;
                    return offset + 1;
                };

                function objectWriteUInt16(buf, value, offset, littleEndian) {
                    if (value < 0) value = 0xffff + value + 1;
                    for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
                        buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
                    }
                }

                Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
                    value = +value;
                    offset = offset | 0;
                    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
                    if (Buffer.TYPED_ARRAY_SUPPORT) {
                        this[offset] = value & 0xff;
                        this[offset + 1] = value >>> 8;
                    } else {
                        objectWriteUInt16(this, value, offset, true);
                    }
                    return offset + 2;
                };

                Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
                    value = +value;
                    offset = offset | 0;
                    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
                    if (Buffer.TYPED_ARRAY_SUPPORT) {
                        this[offset] = value >>> 8;
                        this[offset + 1] = value & 0xff;
                    } else {
                        objectWriteUInt16(this, value, offset, false);
                    }
                    return offset + 2;
                };

                function objectWriteUInt32(buf, value, offset, littleEndian) {
                    if (value < 0) value = 0xffffffff + value + 1;
                    for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
                        buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;
                    }
                }

                Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
                    value = +value;
                    offset = offset | 0;
                    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
                    if (Buffer.TYPED_ARRAY_SUPPORT) {
                        this[offset + 3] = value >>> 24;
                        this[offset + 2] = value >>> 16;
                        this[offset + 1] = value >>> 8;
                        this[offset] = value & 0xff;
                    } else {
                        objectWriteUInt32(this, value, offset, true);
                    }
                    return offset + 4;
                };

                Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
                    value = +value;
                    offset = offset | 0;
                    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
                    if (Buffer.TYPED_ARRAY_SUPPORT) {
                        this[offset] = value >>> 24;
                        this[offset + 1] = value >>> 16;
                        this[offset + 2] = value >>> 8;
                        this[offset + 3] = value & 0xff;
                    } else {
                        objectWriteUInt32(this, value, offset, false);
                    }
                    return offset + 4;
                };

                Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
                    value = +value;
                    offset = offset | 0;
                    if (!noAssert) {
                        var limit = Math.pow(2, 8 * byteLength - 1);

                        checkInt(this, value, offset, byteLength, limit - 1, -limit);
                    }

                    var i = 0;
                    var mul = 1;
                    var sub = 0;
                    this[offset] = value & 0xFF;
                    while (++i < byteLength && (mul *= 0x100)) {
                        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
                            sub = 1;
                        }
                        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
                    }

                    return offset + byteLength;
                };

                Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
                    value = +value;
                    offset = offset | 0;
                    if (!noAssert) {
                        var limit = Math.pow(2, 8 * byteLength - 1);

                        checkInt(this, value, offset, byteLength, limit - 1, -limit);
                    }

                    var i = byteLength - 1;
                    var mul = 1;
                    var sub = 0;
                    this[offset + i] = value & 0xFF;
                    while (--i >= 0 && (mul *= 0x100)) {
                        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
                            sub = 1;
                        }
                        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
                    }

                    return offset + byteLength;
                };

                Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
                    value = +value;
                    offset = offset | 0;
                    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
                    if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
                    if (value < 0) value = 0xff + value + 1;
                    this[offset] = value & 0xff;
                    return offset + 1;
                };

                Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
                    value = +value;
                    offset = offset | 0;
                    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
                    if (Buffer.TYPED_ARRAY_SUPPORT) {
                        this[offset] = value & 0xff;
                        this[offset + 1] = value >>> 8;
                    } else {
                        objectWriteUInt16(this, value, offset, true);
                    }
                    return offset + 2;
                };

                Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
                    value = +value;
                    offset = offset | 0;
                    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
                    if (Buffer.TYPED_ARRAY_SUPPORT) {
                        this[offset] = value >>> 8;
                        this[offset + 1] = value & 0xff;
                    } else {
                        objectWriteUInt16(this, value, offset, false);
                    }
                    return offset + 2;
                };

                Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
                    value = +value;
                    offset = offset | 0;
                    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
                    if (Buffer.TYPED_ARRAY_SUPPORT) {
                        this[offset] = value & 0xff;
                        this[offset + 1] = value >>> 8;
                        this[offset + 2] = value >>> 16;
                        this[offset + 3] = value >>> 24;
                    } else {
                        objectWriteUInt32(this, value, offset, true);
                    }
                    return offset + 4;
                };

                Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
                    value = +value;
                    offset = offset | 0;
                    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
                    if (value < 0) value = 0xffffffff + value + 1;
                    if (Buffer.TYPED_ARRAY_SUPPORT) {
                        this[offset] = value >>> 24;
                        this[offset + 1] = value >>> 16;
                        this[offset + 2] = value >>> 8;
                        this[offset + 3] = value & 0xff;
                    } else {
                        objectWriteUInt32(this, value, offset, false);
                    }
                    return offset + 4;
                };

                function checkIEEE754(buf, value, offset, ext, max, min) {
                    if (offset + ext > buf.length) throw new RangeError('Index out of range');
                    if (offset < 0) throw new RangeError('Index out of range');
                }

                function writeFloat(buf, value, offset, littleEndian, noAssert) {
                    if (!noAssert) {
                        checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
                    }
                    ieee754.write(buf, value, offset, littleEndian, 23, 4);
                    return offset + 4;
                }

                Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
                    return writeFloat(this, value, offset, true, noAssert);
                };

                Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
                    return writeFloat(this, value, offset, false, noAssert);
                };

                function writeDouble(buf, value, offset, littleEndian, noAssert) {
                    if (!noAssert) {
                        checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
                    }
                    ieee754.write(buf, value, offset, littleEndian, 52, 8);
                    return offset + 8;
                }

                Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
                    return writeDouble(this, value, offset, true, noAssert);
                };

                Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
                    return writeDouble(this, value, offset, false, noAssert);
                };

                // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
                Buffer.prototype.copy = function copy(target, targetStart, start, end) {
                    if (!start) start = 0;
                    if (!end && end !== 0) end = this.length;
                    if (targetStart >= target.length) targetStart = target.length;
                    if (!targetStart) targetStart = 0;
                    if (end > 0 && end < start) end = start;

                    // Copy 0 bytes; we're done
                    if (end === start) return 0;
                    if (target.length === 0 || this.length === 0) return 0;

                    // Fatal error conditions
                    if (targetStart < 0) {
                        throw new RangeError('targetStart out of bounds');
                    }
                    if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');
                    if (end < 0) throw new RangeError('sourceEnd out of bounds');

                    // Are we oob?
                    if (end > this.length) end = this.length;
                    if (target.length - targetStart < end - start) {
                        end = target.length - targetStart + start;
                    }

                    var len = end - start;
                    var i;

                    if (this === target && start < targetStart && targetStart < end) {
                        // descending copy from end
                        for (i = len - 1; i >= 0; --i) {
                            target[i + targetStart] = this[i + start];
                        }
                    } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
                        // ascending copy from start
                        for (i = 0; i < len; ++i) {
                            target[i + targetStart] = this[i + start];
                        }
                    } else {
                        Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
                    }

                    return len;
                };

                // Usage:
                //    buffer.fill(number[, offset[, end]])
                //    buffer.fill(buffer[, offset[, end]])
                //    buffer.fill(string[, offset[, end]][, encoding])
                Buffer.prototype.fill = function fill(val, start, end, encoding) {
                    // Handle string cases:
                    if (typeof val === 'string') {
                        if (typeof start === 'string') {
                            encoding = start;
                            start = 0;
                            end = this.length;
                        } else if (typeof end === 'string') {
                            encoding = end;
                            end = this.length;
                        }
                        if (val.length === 1) {
                            var code = val.charCodeAt(0);
                            if (code < 256) {
                                val = code;
                            }
                        }
                        if (encoding !== undefined && typeof encoding !== 'string') {
                            throw new TypeError('encoding must be a string');
                        }
                        if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
                            throw new TypeError('Unknown encoding: ' + encoding);
                        }
                    } else if (typeof val === 'number') {
                        val = val & 255;
                    }

                    // Invalid ranges are not set to a default, so can range check early.
                    if (start < 0 || this.length < start || this.length < end) {
                        throw new RangeError('Out of range index');
                    }

                    if (end <= start) {
                        return this;
                    }

                    start = start >>> 0;
                    end = end === undefined ? this.length : end >>> 0;

                    if (!val) val = 0;

                    var i;
                    if (typeof val === 'number') {
                        for (i = start; i < end; ++i) {
                            this[i] = val;
                        }
                    } else {
                        var bytes = Buffer.isBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());
                        var len = bytes.length;
                        for (i = 0; i < end - start; ++i) {
                            this[i + start] = bytes[i % len];
                        }
                    }

                    return this;
                };

                // HELPER FUNCTIONS
                // ================

                var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

                function base64clean(str) {
                    // Node strips out invalid characters like \n and \t from the string, base64-js does not
                    str = stringtrim(str).replace(INVALID_BASE64_RE, '');
                    // Node converts strings with length < 2 to ''
                    if (str.length < 2) return '';
                    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
                    while (str.length % 4 !== 0) {
                        str = str + '=';
                    }
                    return str;
                }

                function stringtrim(str) {
                    if (str.trim) return str.trim();
                    return str.replace(/^\s+|\s+$/g, '');
                }

                function toHex(n) {
                    if (n < 16) return '0' + n.toString(16);
                    return n.toString(16);
                }

                function utf8ToBytes(string, units) {
                    units = units || Infinity;
                    var codePoint;
                    var length = string.length;
                    var leadSurrogate = null;
                    var bytes = [];

                    for (var i = 0; i < length; ++i) {
                        codePoint = string.charCodeAt(i);

                        // is surrogate component
                        if (codePoint > 0xD7FF && codePoint < 0xE000) {
                            // last char was a lead
                            if (!leadSurrogate) {
                                // no lead yet
                                if (codePoint > 0xDBFF) {
                                    // unexpected trail
                                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                                    continue;
                                } else if (i + 1 === length) {
                                    // unpaired lead
                                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                                    continue;
                                }

                                // valid lead
                                leadSurrogate = codePoint;

                                continue;
                            }

                            // 2 leads in a row
                            if (codePoint < 0xDC00) {
                                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                                leadSurrogate = codePoint;
                                continue;
                            }

                            // valid surrogate pair
                            codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
                        } else if (leadSurrogate) {
                            // valid bmp char, but last char was a lead
                            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                        }

                        leadSurrogate = null;

                        // encode utf8
                        if (codePoint < 0x80) {
                            if ((units -= 1) < 0) break;
                            bytes.push(codePoint);
                        } else if (codePoint < 0x800) {
                            if ((units -= 2) < 0) break;
                            bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
                        } else if (codePoint < 0x10000) {
                            if ((units -= 3) < 0) break;
                            bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
                        } else if (codePoint < 0x110000) {
                            if ((units -= 4) < 0) break;
                            bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
                        } else {
                            throw new Error('Invalid code point');
                        }
                    }

                    return bytes;
                }

                function asciiToBytes(str) {
                    var byteArray = [];
                    for (var i = 0; i < str.length; ++i) {
                        // Node's code seems to be doing this and not & 0x7F..
                        byteArray.push(str.charCodeAt(i) & 0xFF);
                    }
                    return byteArray;
                }

                function utf16leToBytes(str, units) {
                    var c, hi, lo;
                    var byteArray = [];
                    for (var i = 0; i < str.length; ++i) {
                        if ((units -= 2) < 0) break;

                        c = str.charCodeAt(i);
                        hi = c >> 8;
                        lo = c % 256;
                        byteArray.push(lo);
                        byteArray.push(hi);
                    }

                    return byteArray;
                }

                function base64ToBytes(str) {
                    return base64.toByteArray(base64clean(str));
                }

                function blitBuffer(src, dst, offset, length) {
                    for (var i = 0; i < length; ++i) {
                        if (i + offset >= dst.length || i >= src.length) break;
                        dst[i + offset] = src[i];
                    }
                    return i;
                }

                function isnan(val) {
                    return val !== val; // eslint-disable-line no-self-compare
                }

                /* WEBPACK VAR INJECTION */
            }).call(exports, __webpack_require__(26).Buffer, function () {
                return this;
            }());

            /***/
        },
        /* 27 */
        /***/function (module, exports) {

            module.exports = pathGetter;

            function pathGetter(obj, path) {
                if (path !== '$') {
                    var paths = getPaths(path);
                    for (var i = 0; i < paths.length; i++) {
                        path = paths[i].toString().replace(/\\"/g, '"');
                        obj = obj[path];
                    }
                }
                return obj;
            }

            function getPaths(pathString) {
                var regex = /(?:\.(\w+))|(?:\[(\d+)\])|(?:\["((?:[^\\"]|\\.)*)"\])/g;
                var matches = [];
                var match;
                while (match = regex.exec(pathString)) {
                    matches.push(match[1] || match[2] || match[3]);
                }
                return matches;
            }

            /***/
        },
        /* 28 */
        /***/function (module, exports, __webpack_require__) {

            var getNative = __webpack_require__(2),
                root = __webpack_require__(1);

            /* Built-in method references that are verified to be native. */
            var Set = getNative(root, 'Set');

            module.exports = Set;

            /***/
        },
        /* 29 */
        /***/function (module, exports, __webpack_require__) {

            var ListCache = __webpack_require__(5),
                stackClear = __webpack_require__(141),
                stackDelete = __webpack_require__(142),
                stackGet = __webpack_require__(143),
                stackHas = __webpack_require__(144),
                stackSet = __webpack_require__(145);

            /**
             * Creates a stack cache object to store key-value pairs.
             *
             * @private
             * @constructor
             * @param {Array} [entries] The key-value pairs to cache.
             */
            function Stack(entries) {
                var data = this.__data__ = new ListCache(entries);
                this.size = data.size;
            }

            // Add methods to `Stack`.
            Stack.prototype.clear = stackClear;
            Stack.prototype['delete'] = stackDelete;
            Stack.prototype.get = stackGet;
            Stack.prototype.has = stackHas;
            Stack.prototype.set = stackSet;

            module.exports = Stack;

            /***/
        },
        /* 30 */
        /***/function (module, exports, __webpack_require__) {

            var baseIndexOf = __webpack_require__(86);

            /**
             * A specialized version of `_.includes` for arrays without support for
             * specifying an index to search from.
             *
             * @private
             * @param {Array} [array] The array to inspect.
             * @param {*} target The value to search for.
             * @returns {boolean} Returns `true` if `target` is found, else `false`.
             */
            function arrayIncludes(array, value) {
                var length = array ? array.length : 0;
                return !!length && baseIndexOf(array, value, 0) > -1;
            }

            module.exports = arrayIncludes;

            /***/
        },
        /* 31 */
        /***/function (module, exports) {

            /**
             * This function is like `arrayIncludes` except that it accepts a comparator.
             *
             * @private
             * @param {Array} [array] The array to inspect.
             * @param {*} target The value to search for.
             * @param {Function} comparator The comparator invoked per element.
             * @returns {boolean} Returns `true` if `target` is found, else `false`.
             */
            function arrayIncludesWith(array, value, comparator) {
                var index = -1,
                    length = array ? array.length : 0;

                while (++index < length) {
                    if (comparator(value, array[index])) {
                        return true;
                    }
                }
                return false;
            }

            module.exports = arrayIncludesWith;

            /***/
        },
        /* 32 */
        /***/function (module, exports, __webpack_require__) {

            var arrayPush = __webpack_require__(77),
                isFlattenable = __webpack_require__(117);

            /**
             * The base implementation of `_.flatten` with support for restricting flattening.
             *
             * @private
             * @param {Array} array The array to flatten.
             * @param {number} depth The maximum recursion depth.
             * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
             * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
             * @param {Array} [result=[]] The initial result value.
             * @returns {Array} Returns the new flattened array.
             */
            function baseFlatten(array, depth, predicate, isStrict, result) {
                var index = -1,
                    length = array.length;

                predicate || (predicate = isFlattenable);
                result || (result = []);

                while (++index < length) {
                    var value = array[index];
                    if (depth > 0 && predicate(value)) {
                        if (depth > 1) {
                            // Recursively flatten arrays (susceptible to call stack limits).
                            baseFlatten(value, depth - 1, predicate, isStrict, result);
                        } else {
                            arrayPush(result, value);
                        }
                    } else if (!isStrict) {
                        result[result.length] = value;
                    }
                }
                return result;
            }

            module.exports = baseFlatten;

            /***/
        },
        /* 33 */
        /***/function (module, exports, __webpack_require__) {

            var castPath = __webpack_require__(37),
                isKey = __webpack_require__(8),
                toKey = __webpack_require__(10);

            /**
             * The base implementation of `_.get` without support for default values.
             *
             * @private
             * @param {Object} object The object to query.
             * @param {Array|string} path The path of the property to get.
             * @returns {*} Returns the resolved value.
             */
            function baseGet(object, path) {
                path = isKey(path, object) ? [path] : castPath(path);

                var index = 0,
                    length = path.length;

                while (object != null && index < length) {
                    object = object[toKey(path[index++])];
                }
                return index && index == length ? object : undefined;
            }

            module.exports = baseGet;

            /***/
        },
        /* 34 */
        /***/function (module, exports, __webpack_require__) {

            var baseIsEqualDeep = __webpack_require__(87),
                isObject = __webpack_require__(11),
                isObjectLike = __webpack_require__(4);

            /**
             * The base implementation of `_.isEqual` which supports partial comparisons
             * and tracks traversed objects.
             *
             * @private
             * @param {*} value The value to compare.
             * @param {*} other The other value to compare.
             * @param {Function} [customizer] The function to customize comparisons.
             * @param {boolean} [bitmask] The bitmask of comparison flags.
             *  The bitmask may be composed of the following flags:
             *     1 - Unordered comparison
             *     2 - Partial comparison
             * @param {Object} [stack] Tracks traversed `value` and `other` objects.
             * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
             */
            function baseIsEqual(value, other, customizer, bitmask, stack) {
                if (value === other) {
                    return true;
                }
                if (value == null || other == null || !isObject(value) && !isObjectLike(other)) {
                    return value !== value && other !== other;
                }
                return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
            }

            module.exports = baseIsEqual;

            /***/
        },
        /* 35 */
        /***/function (module, exports, __webpack_require__) {

            var identity = __webpack_require__(19),
                overRest = __webpack_require__(136),
                setToString = __webpack_require__(139);

            /**
             * The base implementation of `_.rest` which doesn't validate or coerce arguments.
             *
             * @private
             * @param {Function} func The function to apply a rest parameter to.
             * @param {number} [start=func.length-1] The start position of the rest parameter.
             * @returns {Function} Returns the new function.
             */
            function baseRest(func, start) {
                return setToString(overRest(func, start, identity), func + '');
            }

            module.exports = baseRest;

            /***/
        },
        /* 36 */
        /***/function (module, exports) {

            /**
             * The base implementation of `_.unary` without support for storing metadata.
             *
             * @private
             * @param {Function} func The function to cap arguments for.
             * @returns {Function} Returns the new capped function.
             */
            function baseUnary(func) {
                return function (value) {
                    return func(value);
                };
            }

            module.exports = baseUnary;

            /***/
        },
        /* 37 */
        /***/function (module, exports, __webpack_require__) {

            var isArray = __webpack_require__(3),
                stringToPath = __webpack_require__(147);

            /**
             * Casts `value` to a path array if it's not one.
             *
             * @private
             * @param {*} value The value to inspect.
             * @returns {Array} Returns the cast property path array.
             */
            function castPath(value) {
                return isArray(value) ? value : stringToPath(value);
            }

            module.exports = castPath;

            /***/
        },
        /* 38 */
        /***/function (module, exports, __webpack_require__) {

            var SetCache = __webpack_require__(15),
                arraySome = __webpack_require__(78),
                cacheHas = __webpack_require__(17);

            /** Used to compose bitmasks for comparison styles. */
            var UNORDERED_COMPARE_FLAG = 1,
                PARTIAL_COMPARE_FLAG = 2;

            /**
             * A specialized version of `baseIsEqualDeep` for arrays with support for
             * partial deep comparisons.
             *
             * @private
             * @param {Array} array The array to compare.
             * @param {Array} other The other array to compare.
             * @param {Function} equalFunc The function to determine equivalents of values.
             * @param {Function} customizer The function to customize comparisons.
             * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
             *  for more details.
             * @param {Object} stack Tracks traversed `array` and `other` objects.
             * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
             */
            function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
                var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
                    arrLength = array.length,
                    othLength = other.length;

                if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
                    return false;
                }
                // Assume cyclic values are equal.
                var stacked = stack.get(array);
                if (stacked && stack.get(other)) {
                    return stacked == other;
                }
                var index = -1,
                    result = true,
                    seen = bitmask & UNORDERED_COMPARE_FLAG ? new SetCache() : undefined;

                stack.set(array, other);
                stack.set(other, array);

                // Ignore non-index properties.
                while (++index < arrLength) {
                    var arrValue = array[index],
                        othValue = other[index];

                    if (customizer) {
                        var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
                    }
                    if (compared !== undefined) {
                        if (compared) {
                            continue;
                        }
                        result = false;
                        break;
                    }
                    // Recursively compare arrays (susceptible to call stack limits).
                    if (seen) {
                        if (!arraySome(other, function (othValue, othIndex) {
                            if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
                                return seen.push(othIndex);
                            }
                        })) {
                            result = false;
                            break;
                        }
                    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
                        result = false;
                        break;
                    }
                }
                stack['delete'](array);
                stack['delete'](other);
                return result;
            }

            module.exports = equalArrays;

            /***/
        },
        /* 39 */
        /***/function (module, exports) {

            /* WEBPACK VAR INJECTION */(function (global) {
                /** Detect free variable `global` from Node.js. */
                var freeGlobal = (typeof global === 'undefined' ? 'undefined' : _typeof2(global)) == 'object' && global && global.Object === Object && global;

                module.exports = freeGlobal;

                /* WEBPACK VAR INJECTION */
            }).call(exports, function () {
                return this;
            }());

            /***/
        },
        /* 40 */
        /***/function (module, exports) {

            /** Used as references for various `Number` constants. */
            var MAX_SAFE_INTEGER = 9007199254740991;

            /** Used to detect unsigned integer values. */
            var reIsUint = /^(?:0|[1-9]\d*)$/;

            /**
             * Checks if `value` is a valid array-like index.
             *
             * @private
             * @param {*} value The value to check.
             * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
             * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
             */
            function isIndex(value, length) {
                length = length == null ? MAX_SAFE_INTEGER : length;
                return !!length && (typeof value == 'number' || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
            }

            module.exports = isIndex;

            /***/
        },
        /* 41 */
        /***/function (module, exports, __webpack_require__) {

            var isObject = __webpack_require__(11);

            /**
             * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
             *
             * @private
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` if suitable for strict
             *  equality comparisons, else `false`.
             */
            function isStrictComparable(value) {
                return value === value && !isObject(value);
            }

            module.exports = isStrictComparable;

            /***/
        },
        /* 42 */
        /***/function (module, exports) {

            /**
             * A specialized version of `matchesProperty` for source values suitable
             * for strict equality comparisons, i.e. `===`.
             *
             * @private
             * @param {string} key The key of the property to get.
             * @param {*} srcValue The value to match.
             * @returns {Function} Returns the new spec function.
             */
            function matchesStrictComparable(key, srcValue) {
                return function (object) {
                    if (object == null) {
                        return false;
                    }
                    return object[key] === srcValue && (srcValue !== undefined || key in Object(object));
                };
            }

            module.exports = matchesStrictComparable;

            /***/
        },
        /* 43 */
        /***/function (module, exports) {

            /**
             * Creates a unary function that invokes `func` with its argument transformed.
             *
             * @private
             * @param {Function} func The function to wrap.
             * @param {Function} transform The argument transform.
             * @returns {Function} Returns the new function.
             */
            function overArg(func, transform) {
                return function (arg) {
                    return func(transform(arg));
                };
            }

            module.exports = overArg;

            /***/
        },
        /* 44 */
        /***/function (module, exports) {

            /** Used for built-in method references. */
            var funcProto = Function.prototype;

            /** Used to resolve the decompiled source of functions. */
            var funcToString = funcProto.toString;

            /**
             * Converts `func` to its source code.
             *
             * @private
             * @param {Function} func The function to process.
             * @returns {string} Returns the source code.
             */
            function toSource(func) {
                if (func != null) {
                    try {
                        return funcToString.call(func);
                    } catch (e) {}
                    try {
                        return func + '';
                    } catch (e) {}
                }
                return '';
            }

            module.exports = toSource;

            /***/
        },
        /* 45 */
        /***/function (module, exports) {

            /**
             * Performs a
             * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
             * comparison between two values to determine if they are equivalent.
             *
             * @static
             * @memberOf _
             * @since 4.0.0
             * @category Lang
             * @param {*} value The value to compare.
             * @param {*} other The other value to compare.
             * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
             * @example
             *
             * var object = { 'a': 1 };
             * var other = { 'a': 1 };
             *
             * _.eq(object, object);
             * // => true
             *
             * _.eq(object, other);
             * // => false
             *
             * _.eq('a', 'a');
             * // => true
             *
             * _.eq('a', Object('a'));
             * // => false
             *
             * _.eq(NaN, NaN);
             * // => true
             */
            function eq(value, other) {
                return value === other || value !== value && other !== other;
            }

            module.exports = eq;

            /***/
        },
        /* 46 */
        /***/function (module, exports, __webpack_require__) {

            var isFunction = __webpack_require__(47),
                isLength = __webpack_require__(22);

            /**
             * Checks if `value` is array-like. A value is considered array-like if it's
             * not a function and has a `value.length` that's an integer greater than or
             * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
             *
             * @static
             * @memberOf _
             * @since 4.0.0
             * @category Lang
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
             * @example
             *
             * _.isArrayLike([1, 2, 3]);
             * // => true
             *
             * _.isArrayLike(document.body.children);
             * // => true
             *
             * _.isArrayLike('abc');
             * // => true
             *
             * _.isArrayLike(_.noop);
             * // => false
             */
            function isArrayLike(value) {
                return value != null && isLength(value.length) && !isFunction(value);
            }

            module.exports = isArrayLike;

            /***/
        },
        /* 47 */
        /***/function (module, exports, __webpack_require__) {

            var isObject = __webpack_require__(11);

            /** `Object#toString` result references. */
            var funcTag = '[object Function]',
                genTag = '[object GeneratorFunction]';

            /** Used for built-in method references. */
            var objectProto = Object.prototype;

            /**
             * Used to resolve the
             * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
             * of values.
             */
            var objectToString = objectProto.toString;

            /**
             * Checks if `value` is classified as a `Function` object.
             *
             * @static
             * @memberOf _
             * @since 0.1.0
             * @category Lang
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is a function, else `false`.
             * @example
             *
             * _.isFunction(_);
             * // => true
             *
             * _.isFunction(/abc/);
             * // => false
             */
            function isFunction(value) {
                // The use of `Object#toString` avoids issues with the `typeof` operator
                // in Safari 8-9 which returns 'object' for typed array and other constructors.
                var tag = isObject(value) ? objectToString.call(value) : '';
                return tag == funcTag || tag == genTag;
            }

            module.exports = isFunction;

            /***/
        },
        /* 48 */
        /***/function (module, exports, __webpack_require__) {

            'use strict';

            exports.decode = exports.parse = __webpack_require__(160);
            exports.encode = exports.stringify = __webpack_require__(161);

            /***/
        },
        /* 49 */
        /***/function (module, exports, __webpack_require__) {

            var scErrors = __webpack_require__(25);
            var InvalidActionError = scErrors.InvalidActionError;

            var Response = function Response(socket, id) {
                this.socket = socket;
                this.id = id;
                this.sent = false;
            };

            Response.prototype._respond = function (responseData) {
                if (this.sent) {
                    throw new InvalidActionError('Response ' + this.id + ' has already been sent');
                } else {
                    this.sent = true;
                    this.socket.send(this.socket.encode(responseData));
                }
            };

            Response.prototype.end = function (data) {
                if (this.id) {
                    var responseData = {
                        rid: this.id
                    };
                    if (data !== undefined) {
                        responseData.data = data;
                    }
                    this._respond(responseData);
                }
            };

            Response.prototype.error = function (error, data) {
                if (this.id) {
                    var err = scErrors.dehydrateError(error);

                    var responseData = {
                        rid: this.id,
                        error: err
                    };
                    if (data !== undefined) {
                        responseData.data = data;
                    }

                    this._respond(responseData);
                }
            };

            Response.prototype.callback = function (error, data) {
                if (error) {
                    this.error(error, data);
                } else {
                    this.end(data);
                }
            };

            module.exports.Response = Response;

            /***/
        },
        /* 50 */
        /***/function (module, exports, __webpack_require__) {

            /* WEBPACK VAR INJECTION */(function (global, Buffer) {
                var SCEmitter = __webpack_require__(12).SCEmitter;
                var SCChannel = __webpack_require__(166).SCChannel;
                var Response = __webpack_require__(49).Response;
                var AuthEngine = __webpack_require__(170).AuthEngine;
                var formatter = __webpack_require__(168);
                var SCTransport = __webpack_require__(172).SCTransport;
                var querystring = __webpack_require__(48);
                var LinkedList = __webpack_require__(68);
                var base64 = __webpack_require__(56);

                var scErrors = __webpack_require__(25);
                var InvalidArgumentsError = scErrors.InvalidArgumentsError;
                var InvalidMessageError = scErrors.InvalidMessageError;
                var SocketProtocolError = scErrors.SocketProtocolError;
                var TimeoutError = scErrors.TimeoutError;

                var isBrowser = typeof window != 'undefined';

                var SCSocket = function SCSocket(opts) {
                    var self = this;

                    SCEmitter.call(this);

                    this.id = null;
                    this.state = this.CLOSED;
                    this.authState = this.PENDING;
                    this.signedAuthToken = null;
                    this.authToken = null;
                    this.pendingReconnect = false;
                    this.pendingReconnectTimeout = null;
                    this.pendingConnectCallback = false;

                    this.connectTimeout = opts.connectTimeout;
                    this.ackTimeout = opts.ackTimeout;
                    this.channelPrefix = opts.channelPrefix || null;
                    this.disconnectOnUnload = opts.disconnectOnUnload == null ? true : opts.disconnectOnUnload;

                    // pingTimeout will be ackTimeout at the start, but it will
                    // be updated with values provided by the 'connect' event
                    this.pingTimeout = this.ackTimeout;

                    var maxTimeout = Math.pow(2, 31) - 1;

                    var verifyDuration = function verifyDuration(propertyName) {
                        if (self[propertyName] > maxTimeout) {
                            throw new InvalidArgumentsError('The ' + propertyName + ' value provided exceeded the maximum amount allowed');
                        }
                    };

                    verifyDuration('connectTimeout');
                    verifyDuration('ackTimeout');
                    verifyDuration('pingTimeout');

                    this._localEvents = {
                        'connect': 1,
                        'connectAbort': 1,
                        'disconnect': 1,
                        'message': 1,
                        'error': 1,
                        'raw': 1,
                        'fail': 1,
                        'kickOut': 1,
                        'subscribe': 1,
                        'unsubscribe': 1,
                        'subscribeStateChange': 1,
                        'authStateChange': 1,
                        'authenticate': 1,
                        'deauthenticate': 1,
                        'removeAuthToken': 1,
                        'subscribeRequest': 1
                    };

                    this.connectAttempts = 0;

                    this._emitBuffer = new LinkedList();
                    this._channels = {};

                    this.options = opts;

                    this._cid = 1;

                    this.options.callIdGenerator = function () {
                        return self._callIdGenerator();
                    };

                    if (this.options.autoReconnect) {
                        if (this.options.autoReconnectOptions == null) {
                            this.options.autoReconnectOptions = {};
                        }

                        // Add properties to the this.options.autoReconnectOptions object.
                        // We assign the reference to a reconnectOptions variable to avoid repetition.
                        var reconnectOptions = this.options.autoReconnectOptions;
                        if (reconnectOptions.initialDelay == null) {
                            reconnectOptions.initialDelay = 10000;
                        }
                        if (reconnectOptions.randomness == null) {
                            reconnectOptions.randomness = 10000;
                        }
                        if (reconnectOptions.multiplier == null) {
                            reconnectOptions.multiplier = 1.5;
                        }
                        if (reconnectOptions.maxDelay == null) {
                            reconnectOptions.maxDelay = 60000;
                        }
                    }

                    if (this.options.subscriptionRetryOptions == null) {
                        this.options.subscriptionRetryOptions = {};
                    }

                    if (this.options.authEngine) {
                        this.auth = this.options.authEngine;
                    } else {
                        this.auth = new AuthEngine();
                    }

                    if (this.options.codecEngine) {
                        this.codec = this.options.codecEngine;
                    } else {
                        // Default codec engine
                        this.codec = formatter;
                    }

                    this.options.path = this.options.path.replace(/\/$/, '') + '/';

                    this.options.query = opts.query || {};
                    if (typeof this.options.query == 'string') {
                        this.options.query = querystring.parse(this.options.query);
                    }

                    this.connect();

                    this._channelEmitter = new SCEmitter();

                    if (isBrowser && this.disconnectOnUnload) {
                        var unloadHandler = function unloadHandler() {
                            self.disconnect();
                        };

                        if (typeof attachEvent !== 'undefined') {
                            attachEvent('onunload', unloadHandler);
                        } else if (typeof addEventListener !== 'undefined') {
                            addEventListener('beforeunload', unloadHandler, false);
                        }
                    }
                };

                SCSocket.prototype = Object.create(SCEmitter.prototype);

                SCSocket.CONNECTING = SCSocket.prototype.CONNECTING = SCTransport.prototype.CONNECTING;
                SCSocket.OPEN = SCSocket.prototype.OPEN = SCTransport.prototype.OPEN;
                SCSocket.CLOSED = SCSocket.prototype.CLOSED = SCTransport.prototype.CLOSED;

                SCSocket.AUTHENTICATED = SCSocket.prototype.AUTHENTICATED = 'authenticated';
                SCSocket.UNAUTHENTICATED = SCSocket.prototype.UNAUTHENTICATED = 'unauthenticated';
                SCSocket.PENDING = SCSocket.prototype.PENDING = 'pending';

                SCSocket.ignoreStatuses = scErrors.socketProtocolIgnoreStatuses;
                SCSocket.errorStatuses = scErrors.socketProtocolErrorStatuses;

                SCSocket.prototype._privateEventHandlerMap = {
                    '#publish': function publish(data) {
                        var undecoratedChannelName = this._undecorateChannelName(data.channel);
                        var isSubscribed = this.isSubscribed(undecoratedChannelName, true);

                        if (isSubscribed) {
                            this._channelEmitter.emit(undecoratedChannelName, data.data);
                        }
                    },
                    '#kickOut': function kickOut(data) {
                        var undecoratedChannelName = this._undecorateChannelName(data.channel);
                        var channel = this._channels[undecoratedChannelName];
                        if (channel) {
                            SCEmitter.prototype.emit.call(this, 'kickOut', data.message, undecoratedChannelName);
                            channel.emit('kickOut', data.message, undecoratedChannelName);
                            this._triggerChannelUnsubscribe(channel);
                        }
                    },
                    '#setAuthToken': function setAuthToken(data, response) {
                        var self = this;

                        if (data) {
                            var triggerAuthenticate = function triggerAuthenticate(err) {
                                if (err) {
                                    // This is a non-fatal error, we don't want to close the connection
                                    // because of this but we do want to notify the server and throw an error
                                    // on the client.
                                    response.error(err);
                                    self._onSCError(err);
                                } else {
                                    self._changeToAuthenticatedState(data.token);
                                    response.end();
                                }
                            };

                            this.auth.saveToken(this.options.authTokenName, data.token, {}, triggerAuthenticate);
                        } else {
                            response.error(new InvalidMessageError('No token data provided by #setAuthToken event'));
                        }
                    },
                    '#removeAuthToken': function removeAuthToken(data, response) {
                        var self = this;

                        this.auth.removeToken(this.options.authTokenName, function (err, oldToken) {
                            if (err) {
                                // Non-fatal error - Do not close the connection
                                response.error(err);
                                self._onSCError(err);
                            } else {
                                SCEmitter.prototype.emit.call(self, 'removeAuthToken', oldToken);
                                self._changeToUnauthenticatedState();
                                response.end();
                            }
                        });
                    },
                    '#disconnect': function disconnect(data) {
                        this.transport.close(data.code, data.data);
                    }
                };

                SCSocket.prototype._callIdGenerator = function () {
                    return this._cid++;
                };

                SCSocket.prototype.getState = function () {
                    return this.state;
                };

                SCSocket.prototype.getBytesReceived = function () {
                    return this.transport.getBytesReceived();
                };

                SCSocket.prototype.deauthenticate = function (callback) {
                    var self = this;

                    this.auth.removeToken(this.options.authTokenName, function (err, oldToken) {
                        if (err) {
                            // Non-fatal error - Do not close the connection
                            self._onSCError(err);
                        } else {
                            self.emit('#removeAuthToken');
                            SCEmitter.prototype.emit.call(self, 'removeAuthToken', oldToken);
                            self._changeToUnauthenticatedState();
                        }
                        callback && callback(err);
                    });
                };

                SCSocket.prototype.connect = SCSocket.prototype.open = function () {
                    var self = this;

                    if (this.state == this.CLOSED) {
                        this.pendingReconnect = false;
                        this.pendingReconnectTimeout = null;
                        clearTimeout(this._reconnectTimeoutRef);

                        this.state = this.CONNECTING;
                        this._changeToPendingAuthState();

                        if (this.transport) {
                            this.transport.off();
                        }

                        this.transport = new SCTransport(this.auth, this.codec, this.options);

                        this.transport.on('open', function (status) {
                            self.state = self.OPEN;
                            self._onSCOpen(status);
                        });

                        this.transport.on('error', function (err) {
                            self._onSCError(err);
                        });

                        this.transport.on('close', function (code, data) {
                            self.state = self.CLOSED;
                            self._onSCClose(code, data);
                        });

                        this.transport.on('openAbort', function (code, data) {
                            self.state = self.CLOSED;
                            self._onSCClose(code, data, true);
                        });

                        this.transport.on('event', function (event, data, res) {
                            self._onSCEvent(event, data, res);
                        });
                    }
                };

                SCSocket.prototype.reconnect = function () {
                    this.disconnect();
                    this.connect();
                };

                SCSocket.prototype.disconnect = function (code, data) {
                    code = code || 1000;

                    if (this.state == this.OPEN) {
                        var packet = {
                            code: code,
                            data: data
                        };
                        this.transport.emit('#disconnect', packet);
                        this.transport.close(code, data);
                    } else if (this.state == this.CONNECTING) {
                        this.transport.close(code, data);
                    } else {
                        this.pendingReconnect = false;
                        this.pendingReconnectTimeout = null;
                        clearTimeout(this._reconnectTimeoutRef);
                    }
                };

                SCSocket.prototype._changeToPendingAuthState = function () {
                    if (this.authState != this.PENDING) {
                        var oldState = this.authState;
                        this.authState = this.PENDING;
                        var stateChangeData = {
                            oldState: oldState,
                            newState: this.authState
                        };
                        SCEmitter.prototype.emit.call(this, 'authStateChange', stateChangeData);
                    }
                };

                SCSocket.prototype._changeToUnauthenticatedState = function () {
                    if (this.authState != this.UNAUTHENTICATED) {
                        var oldState = this.authState;
                        this.authState = this.UNAUTHENTICATED;
                        this.signedAuthToken = null;
                        this.authToken = null;

                        var stateChangeData = {
                            oldState: oldState,
                            newState: this.authState
                        };
                        SCEmitter.prototype.emit.call(this, 'authStateChange', stateChangeData);
                        if (oldState == this.AUTHENTICATED) {
                            SCEmitter.prototype.emit.call(this, 'deauthenticate');
                        }
                        SCEmitter.prototype.emit.call(this, 'authTokenChange', this.signedAuthToken);
                    }
                };

                SCSocket.prototype._changeToAuthenticatedState = function (signedAuthToken) {
                    this.signedAuthToken = signedAuthToken;
                    this.authToken = this._extractAuthTokenData(signedAuthToken);

                    if (this.authState != this.AUTHENTICATED) {
                        var oldState = this.authState;
                        this.authState = this.AUTHENTICATED;
                        var stateChangeData = {
                            oldState: oldState,
                            newState: this.authState,
                            signedAuthToken: signedAuthToken,
                            authToken: this.authToken
                        };
                        this.processPendingSubscriptions();

                        SCEmitter.prototype.emit.call(this, 'authStateChange', stateChangeData);
                        SCEmitter.prototype.emit.call(this, 'authenticate', signedAuthToken);
                    }
                    SCEmitter.prototype.emit.call(this, 'authTokenChange', signedAuthToken);
                };

                SCSocket.prototype.decodeBase64 = function (encodedString) {
                    var decodedString;
                    if (typeof Buffer == 'undefined') {
                        if (typeof atob !== 'undefined') {
                            decodedString = atob(encodedString);
                        } else {
                            decodedString = base64.decode(encodedString);
                        }
                    } else {
                        var buffer = new Buffer(encodedString, 'base64');
                        decodedString = buffer.toString('utf8');
                    }
                    return decodedString;
                };

                SCSocket.prototype.encodeBase64 = function (decodedString) {
                    var encodedString;
                    if (typeof Buffer == 'undefined') {
                        if (typeof btoa !== 'undefined') {
                            encodedString = btoa(decodedString);
                        } else {
                            encodedString = base64.encode(decodedString);
                        }
                    } else {
                        var buffer = new Buffer(decodedString, 'utf8');
                        encodedString = buffer.toString('base64');
                    }
                    return encodedString;
                };

                SCSocket.prototype._extractAuthTokenData = function (signedAuthToken) {
                    var tokenParts = (signedAuthToken || '').split('.');
                    var encodedTokenData = tokenParts[1];
                    if (encodedTokenData != null) {
                        var tokenData = encodedTokenData;
                        try {
                            tokenData = this.decodeBase64(tokenData);
                            return JSON.parse(tokenData);
                        } catch (e) {
                            return tokenData;
                        }
                    }
                    return null;
                };

                SCSocket.prototype.getAuthToken = function () {
                    return this.authToken;
                };

                SCSocket.prototype.getSignedAuthToken = function () {
                    return this.signedAuthToken;
                };

                // Perform client-initiated authentication by providing an encrypted token string
                SCSocket.prototype.authenticate = function (signedAuthToken, callback) {
                    var self = this;

                    this._changeToPendingAuthState();

                    this.emit('#authenticate', signedAuthToken, function (err, authStatus) {
                        if (authStatus && authStatus.authError) {
                            authStatus.authError = scErrors.hydrateError(authStatus.authError);
                        }
                        if (err) {
                            self._changeToUnauthenticatedState();
                            callback && callback(err, authStatus);
                        } else {
                            self.auth.saveToken(self.options.authTokenName, signedAuthToken, {}, function (err) {
                                callback && callback(err, authStatus);
                                if (err) {
                                    self._changeToUnauthenticatedState();
                                    self._onSCError(err);
                                } else {
                                    if (authStatus.isAuthenticated) {
                                        self._changeToAuthenticatedState(signedAuthToken);
                                    } else {
                                        self._changeToUnauthenticatedState();
                                    }
                                }
                            });
                        }
                    });
                };

                SCSocket.prototype._tryReconnect = function (initialDelay) {
                    var self = this;

                    var exponent = this.connectAttempts++;
                    var reconnectOptions = this.options.autoReconnectOptions;
                    var timeout;

                    if (initialDelay == null || exponent > 0) {
                        var initialTimeout = Math.round(reconnectOptions.initialDelay + (reconnectOptions.randomness || 0) * Math.random());

                        timeout = Math.round(initialTimeout * Math.pow(reconnectOptions.multiplier, exponent));
                    } else {
                        timeout = initialDelay;
                    }

                    if (timeout > reconnectOptions.maxDelay) {
                        timeout = reconnectOptions.maxDelay;
                    }

                    clearTimeout(this._reconnectTimeoutRef);

                    this.pendingReconnect = true;
                    this.pendingReconnectTimeout = timeout;
                    this._reconnectTimeoutRef = setTimeout(function () {
                        self.connect();
                    }, timeout);
                };

                SCSocket.prototype._onSCOpen = function (status) {
                    var self = this;

                    if (status) {
                        this.id = status.id;
                        this.pingTimeout = status.pingTimeout;
                        this.transport.pingTimeout = this.pingTimeout;
                        if (status.isAuthenticated) {
                            this._changeToAuthenticatedState(status.authToken);
                        } else {
                            this._changeToUnauthenticatedState();
                        }
                    } else {
                        this._changeToUnauthenticatedState();
                    }

                    this.connectAttempts = 0;
                    if (this.options.autoProcessSubscriptions) {
                        this.processPendingSubscriptions();
                    } else {
                        this.pendingConnectCallback = true;
                    }

                    // If the user invokes the callback while in autoProcessSubscriptions mode, it
                    // won't break anything - The processPendingSubscriptions() call will be a no-op.
                    SCEmitter.prototype.emit.call(this, 'connect', status, function () {
                        self.processPendingSubscriptions();
                    });

                    this._flushEmitBuffer();
                };

                SCSocket.prototype._onSCError = function (err) {
                    var self = this;

                    // Throw error in different stack frame so that error handling
                    // cannot interfere with a reconnect action.
                    setTimeout(function () {
                        if (self.listeners('error').length < 1) {
                            throw err;
                        } else {
                            SCEmitter.prototype.emit.call(self, 'error', err);
                        }
                    }, 0);
                };

                SCSocket.prototype._suspendSubscriptions = function () {
                    var channel, newState;
                    for (var channelName in this._channels) {
                        if (this._channels.hasOwnProperty(channelName)) {
                            channel = this._channels[channelName];
                            if (channel.state == channel.SUBSCRIBED || channel.state == channel.PENDING) {

                                newState = channel.PENDING;
                            } else {
                                newState = channel.UNSUBSCRIBED;
                            }

                            this._triggerChannelUnsubscribe(channel, newState);
                        }
                    }
                };

                SCSocket.prototype._onSCClose = function (code, data, openAbort) {
                    var self = this;

                    this.id = null;

                    if (this.transport) {
                        this.transport.off();
                    }
                    this.pendingReconnect = false;
                    this.pendingReconnectTimeout = null;
                    clearTimeout(this._reconnectTimeoutRef);

                    this._changeToPendingAuthState();
                    this._suspendSubscriptions();

                    // Try to reconnect
                    // on server ping timeout (4000)
                    // or on client pong timeout (4001)
                    // or on close without status (1005)
                    // or on handshake failure (4003)
                    // or on socket hung up (1006)
                    if (this.options.autoReconnect) {
                        if (code == 4000 || code == 4001 || code == 1005) {
                            // If there is a ping or pong timeout or socket closes without
                            // status, don't wait before trying to reconnect - These could happen
                            // if the client wakes up after a period of inactivity and in this case we
                            // want to re-establish the connection as soon as possible.
                            this._tryReconnect(0);

                            // Codes 4500 and above will be treated as permanent disconnects.
                            // Socket will not try to auto-reconnect.
                        } else if (code != 1000 && code < 4500) {
                            this._tryReconnect();
                        }
                    }

                    if (openAbort) {
                        SCEmitter.prototype.emit.call(self, 'connectAbort', code, data);
                    } else {
                        SCEmitter.prototype.emit.call(self, 'disconnect', code, data);
                    }

                    if (!SCSocket.ignoreStatuses[code]) {
                        var failureMessage;
                        if (data) {
                            failureMessage = 'Socket connection failed: ' + data;
                        } else {
                            failureMessage = 'Socket connection failed for unknown reasons';
                        }
                        var err = new SocketProtocolError(SCSocket.errorStatuses[code] || failureMessage, code);
                        this._onSCError(err);
                    }
                };

                SCSocket.prototype._onSCEvent = function (event, data, res) {
                    var handler = this._privateEventHandlerMap[event];
                    if (handler) {
                        handler.call(this, data, res);
                    } else {
                        SCEmitter.prototype.emit.call(this, event, data, function () {
                            res && res.callback.apply(res, arguments);
                        });
                    }
                };

                SCSocket.prototype.decode = function (message) {
                    return this.transport.decode(message);
                };

                SCSocket.prototype.encode = function (object) {
                    return this.transport.encode(object);
                };

                SCSocket.prototype._flushEmitBuffer = function () {
                    var currentNode = this._emitBuffer.head;
                    var nextNode;

                    while (currentNode) {
                        nextNode = currentNode.next;
                        var eventObject = currentNode.data;
                        currentNode.detach();
                        this.transport.emitRaw(eventObject);
                        currentNode = nextNode;
                    }
                };

                SCSocket.prototype._handleEventAckTimeout = function (eventObject, eventNode) {
                    if (eventNode) {
                        eventNode.detach();
                    }
                    var error = new TimeoutError("Event response for '" + eventObject.event + "' timed out");
                    var callback = eventObject.callback;
                    if (callback) {
                        delete eventObject.callback;
                        callback.call(eventObject, error, eventObject);
                    }
                };

                SCSocket.prototype._emit = function (event, data, callback) {
                    var self = this;

                    if (this.state == this.CLOSED) {
                        this.connect();
                    }
                    var eventObject = {
                        event: event,
                        data: data,
                        callback: callback
                    };

                    var eventNode = new LinkedList.Item();
                    eventNode.data = eventObject;

                    eventObject.timeout = setTimeout(function () {
                        self._handleEventAckTimeout(eventObject, eventNode);
                    }, this.ackTimeout);

                    this._emitBuffer.append(eventNode);

                    if (this.state == this.OPEN) {
                        this._flushEmitBuffer();
                    }
                };

                SCSocket.prototype.send = function (data) {
                    this.transport.send(data);
                };

                SCSocket.prototype.emit = function (event, data, callback) {
                    if (this._localEvents[event] == null) {
                        this._emit(event, data, callback);
                    } else {
                        SCEmitter.prototype.emit.call(this, event, data);
                    }
                };

                SCSocket.prototype.publish = function (channelName, data, callback) {
                    var pubData = {
                        channel: this._decorateChannelName(channelName),
                        data: data
                    };
                    this.emit('#publish', pubData, callback);
                };

                SCSocket.prototype._triggerChannelSubscribe = function (channel, subscriptionOptions) {
                    var channelName = channel.name;

                    if (channel.state != channel.SUBSCRIBED) {
                        var oldState = channel.state;
                        channel.state = channel.SUBSCRIBED;

                        var stateChangeData = {
                            channel: channelName,
                            oldState: oldState,
                            newState: channel.state,
                            subscriptionOptions: subscriptionOptions
                        };
                        channel.emit('subscribeStateChange', stateChangeData);
                        channel.emit('subscribe', channelName, subscriptionOptions);
                        SCEmitter.prototype.emit.call(this, 'subscribeStateChange', stateChangeData);
                        SCEmitter.prototype.emit.call(this, 'subscribe', channelName, subscriptionOptions);
                    }
                };

                SCSocket.prototype._triggerChannelSubscribeFail = function (err, channel, subscriptionOptions) {
                    var channelName = channel.name;
                    var meetsAuthRequirements = !channel.waitForAuth || this.authState == this.AUTHENTICATED;

                    if (channel.state != channel.UNSUBSCRIBED && meetsAuthRequirements) {
                        channel.state = channel.UNSUBSCRIBED;

                        channel.emit('subscribeFail', err, channelName, subscriptionOptions);
                        SCEmitter.prototype.emit.call(this, 'subscribeFail', err, channelName, subscriptionOptions);
                    }
                };

                // Cancel any pending subscribe callback
                SCSocket.prototype._cancelPendingSubscribeCallback = function (channel) {
                    if (channel._pendingSubscriptionCid != null) {
                        this.transport.cancelPendingResponse(channel._pendingSubscriptionCid);
                        delete channel._pendingSubscriptionCid;
                    }
                };

                SCSocket.prototype._decorateChannelName = function (channelName) {
                    if (this.channelPrefix) {
                        channelName = this.channelPrefix + channelName;
                    }
                    return channelName;
                };

                SCSocket.prototype._undecorateChannelName = function (decoratedChannelName) {
                    if (this.channelPrefix && decoratedChannelName.indexOf(this.channelPrefix) == 0) {
                        return decoratedChannelName.replace(this.channelPrefix, '');
                    }
                    return decoratedChannelName;
                };

                SCSocket.prototype._trySubscribe = function (channel) {
                    var self = this;

                    var meetsAuthRequirements = !channel.waitForAuth || this.authState == this.AUTHENTICATED;

                    // We can only ever have one pending subscribe action at any given time on a channel
                    if (this.state == this.OPEN && !this.pendingConnectCallback && channel._pendingSubscriptionCid == null && meetsAuthRequirements) {

                        var options = {
                            noTimeout: true
                        };

                        var subscriptionOptions = {
                            channel: this._decorateChannelName(channel.name)
                        };
                        if (channel.waitForAuth) {
                            options.waitForAuth = true;
                            subscriptionOptions.waitForAuth = options.waitForAuth;
                        }
                        if (channel.data) {
                            subscriptionOptions.data = channel.data;
                        }

                        channel._pendingSubscriptionCid = this.transport.emit('#subscribe', subscriptionOptions, options, function (err) {
                            delete channel._pendingSubscriptionCid;
                            if (err) {
                                self._triggerChannelSubscribeFail(err, channel, subscriptionOptions);
                            } else {
                                self._triggerChannelSubscribe(channel, subscriptionOptions);
                            }
                        });
                        SCEmitter.prototype.emit.call(this, 'subscribeRequest', channel.name, subscriptionOptions);
                    }
                };

                SCSocket.prototype.subscribe = function (channelName, options) {
                    var channel = this._channels[channelName];

                    if (!channel) {
                        channel = new SCChannel(channelName, this, options);
                        this._channels[channelName] = channel;
                    } else if (options) {
                        channel.setOptions(options);
                    }

                    if (channel.state == channel.UNSUBSCRIBED) {
                        channel.state = channel.PENDING;
                        this._trySubscribe(channel);
                    }

                    return channel;
                };

                SCSocket.prototype._triggerChannelUnsubscribe = function (channel, newState) {
                    var channelName = channel.name;
                    var oldState = channel.state;

                    if (newState) {
                        channel.state = newState;
                    } else {
                        channel.state = channel.UNSUBSCRIBED;
                    }
                    this._cancelPendingSubscribeCallback(channel);

                    if (oldState == channel.SUBSCRIBED) {
                        var stateChangeData = {
                            channel: channelName,
                            oldState: oldState,
                            newState: channel.state
                        };
                        channel.emit('subscribeStateChange', stateChangeData);
                        channel.emit('unsubscribe', channelName);
                        SCEmitter.prototype.emit.call(this, 'subscribeStateChange', stateChangeData);
                        SCEmitter.prototype.emit.call(this, 'unsubscribe', channelName);
                    }
                };

                SCSocket.prototype._tryUnsubscribe = function (channel) {
                    var self = this;

                    if (this.state == this.OPEN) {
                        var options = {
                            noTimeout: true
                        };
                        // If there is a pending subscribe action, cancel the callback
                        this._cancelPendingSubscribeCallback(channel);

                        // This operation cannot fail because the TCP protocol guarantees delivery
                        // so long as the connection remains open. If the connection closes,
                        // the server will automatically unsubscribe the socket and thus complete
                        // the operation on the server side.
                        var decoratedChannelName = this._decorateChannelName(channel.name);
                        this.transport.emit('#unsubscribe', decoratedChannelName, options);
                    }
                };

                SCSocket.prototype.unsubscribe = function (channelName) {

                    var channel = this._channels[channelName];

                    if (channel) {
                        if (channel.state != channel.UNSUBSCRIBED) {

                            this._triggerChannelUnsubscribe(channel);
                            this._tryUnsubscribe(channel);
                        }
                    }
                };

                SCSocket.prototype.channel = function (channelName, options) {
                    var currentChannel = this._channels[channelName];

                    if (!currentChannel) {
                        currentChannel = new SCChannel(channelName, this, options);
                        this._channels[channelName] = currentChannel;
                    }
                    return currentChannel;
                };

                SCSocket.prototype.destroyChannel = function (channelName) {
                    var channel = this._channels[channelName];
                    channel.unwatch();
                    channel.unsubscribe();
                    delete this._channels[channelName];
                };

                SCSocket.prototype.subscriptions = function (includePending) {
                    var subs = [];
                    var channel, includeChannel;
                    for (var channelName in this._channels) {
                        if (this._channels.hasOwnProperty(channelName)) {
                            channel = this._channels[channelName];

                            if (includePending) {
                                includeChannel = channel && (channel.state == channel.SUBSCRIBED || channel.state == channel.PENDING);
                            } else {
                                includeChannel = channel && channel.state == channel.SUBSCRIBED;
                            }

                            if (includeChannel) {
                                subs.push(channelName);
                            }
                        }
                    }
                    return subs;
                };

                SCSocket.prototype.isSubscribed = function (channelName, includePending) {
                    var channel = this._channels[channelName];
                    if (includePending) {
                        return !!channel && (channel.state == channel.SUBSCRIBED || channel.state == channel.PENDING);
                    }
                    return !!channel && channel.state == channel.SUBSCRIBED;
                };

                SCSocket.prototype.processPendingSubscriptions = function () {
                    var self = this;

                    this.pendingConnectCallback = false;

                    for (var i in this._channels) {
                        if (this._channels.hasOwnProperty(i)) {
                            (function (channel) {
                                if (channel.state == channel.PENDING) {
                                    self._trySubscribe(channel);
                                }
                            })(this._channels[i]);
                        }
                    }
                };

                SCSocket.prototype.watch = function (channelName, handler) {
                    if (typeof handler != 'function') {
                        throw new InvalidArgumentsError('No handler function was provided');
                    }
                    this._channelEmitter.on(channelName, handler);
                };

                SCSocket.prototype.unwatch = function (channelName, handler) {
                    if (handler) {
                        this._channelEmitter.removeListener(channelName, handler);
                    } else {
                        this._channelEmitter.removeAllListeners(channelName);
                    }
                };

                SCSocket.prototype.watchers = function (channelName) {
                    return this._channelEmitter.listeners(channelName);
                };

                module.exports = SCSocket;

                /* WEBPACK VAR INJECTION */
            }).call(exports, function () {
                return this;
            }(), __webpack_require__(26).Buffer);

            /***/
        },
        /* 51 */
        /***/function (module, exports) {

            module.exports = function (module) {
                if (!module.webpackPolyfill) {
                    module.deprecate = function () {};
                    module.paths = [];
                    // module.parent = undefined by default
                    module.children = [];
                    module.webpackPolyfill = 1;
                }
                return module;
            };

            /***/
        },
        /* 52 */
        /***/function (module, exports, __webpack_require__) {

            'use strict';

            exports.__esModule = true;
            exports.default = configureStore;

            var _reduxDevtoolsInstrument = __webpack_require__(162);

            var _reduxDevtoolsInstrument2 = _interopRequireDefault(_reduxDevtoolsInstrument);

            function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : { default: obj };
            }

            function configureStore(next, subscriber, options) {
                return (0, _reduxDevtoolsInstrument2.default)(subscriber, options)(next);
            }

            /***/
        },
        /* 53 */
        /***/function (module, exports) {

            'use strict';

            exports.__esModule = true;
            var defaultSocketOptions = exports.defaultSocketOptions = {
                secure: true,
                hostname: 'remotedev.io',
                port: 443,
                autoReconnect: true,
                autoReconnectOptions: {
                    randomness: 30000
                }
            };

            /***/
        },
        /* 54 */
        /***/function (module, exports, __webpack_require__) {

            'use strict';

            exports.__esModule = true;

            var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
                return typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
            } : function (obj) {
                return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
            };

            var _extends = Object.assign || function (target) {
                for (var i = 1; i < arguments.length; i++) {
                    var source = arguments[i];for (var key in source) {
                        if (Object.prototype.hasOwnProperty.call(source, key)) {
                            target[key] = source[key];
                        }
                    }
                }return target;
            };

            exports.default = devTools;
            exports.preDevTools = preDevTools;
            exports.composeWithDevTools = composeWithDevTools;

            var _jsan = __webpack_require__(63);

            var _socketclusterClient = __webpack_require__(169);

            var _socketclusterClient2 = _interopRequireDefault(_socketclusterClient);

            var _configureStore = __webpack_require__(52);

            var _configureStore2 = _interopRequireDefault(_configureStore);

            var _constants = __webpack_require__(53);

            var _reactNative = __webpack_require__(55);

            var _remotedevUtils = __webpack_require__(165);

            var _catchErrors = __webpack_require__(163);

            var _catchErrors2 = _interopRequireDefault(_catchErrors);

            var _filters = __webpack_require__(164);

            function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : { default: obj };
            }

            var instanceId = void 0;
            var instanceName = void 0;
            var socketOptions = void 0;
            var socket = void 0;
            var channel = void 0;
            var store = {};
            var lastAction = void 0;
            var filters = void 0;
            var isExcess = void 0;
            var isMonitored = void 0;
            var started = void 0;
            var startOn = void 0;
            var stopOn = void 0;
            var sendOn = void 0;
            var sendOnError = void 0;
            var sendTo = void 0;
            var lastErrorMsg = void 0;
            var locked = void 0;
            var paused = void 0;
            var actionCreators = void 0;
            var stateSanitizer = void 0;
            var actionSanitizer = void 0;

            function getLiftedState() {
                return (0, _filters.filterStagedActions)(store.liftedStore.getState(), filters);
            }

            function send() {
                if (!instanceId) instanceId = socket && socket.id || Math.random().toString(36).substr(2);
                try {
                    fetch(sendTo, {
                        method: 'POST',
                        headers: {
                            'content-type': 'application/json'
                        },
                        body: JSON.stringify({
                            type: 'STATE',
                            id: instanceId,
                            name: instanceName,
                            payload: (0, _jsan.stringify)(getLiftedState())
                        })
                    }).catch(function (err) {
                        console.log(err);
                    });
                } catch (err) {
                    console.log(err);
                }
            }

            function relay(type, state, action, nextActionId) {
                if ((0, _filters.isFiltered)(action, filters)) return;
                var message = {
                    type: type,
                    id: socket.id,
                    name: instanceName
                };
                if (state) {
                    message.payload = type === 'ERROR' ? state : (0, _jsan.stringify)((0, _filters.filterState)(state, type, filters, stateSanitizer, actionSanitizer, nextActionId));
                }
                if (type === 'ACTION') {
                    message.action = (0, _jsan.stringify)(!actionSanitizer ? action : actionSanitizer(action.action, nextActionId - 1));
                    message.isExcess = isExcess;
                    message.nextActionId = nextActionId;
                } else if (action) {
                    message.action = action;
                }
                socket.emit(socket.id ? 'log' : 'log-noid', message);
            }

            function dispatchRemotely(action) {
                try {
                    var result = (0, _remotedevUtils.evalAction)(action, actionCreators);
                    store.dispatch(result);
                } catch (e) {
                    relay('ERROR', e.message);
                }
            }

            function handleMessages(message) {
                if (message.type === 'IMPORT' || message.type === 'SYNC' && socket.id && message.id !== socket.id) {
                    store.liftedStore.dispatch({
                        type: 'IMPORT_STATE', nextLiftedState: (0, _jsan.parse)(message.state)
                    });
                } else if (message.type === 'UPDATE') {
                    relay('STATE', getLiftedState());
                } else if (message.type === 'START') {
                    isMonitored = true;
                    if (typeof actionCreators === 'function') actionCreators = actionCreators();
                    relay('STATE', getLiftedState(), actionCreators);
                } else if (message.type === 'STOP' || message.type === 'DISCONNECTED') {
                    isMonitored = false;
                    relay('STOP');
                } else if (message.type === 'ACTION') {
                    dispatchRemotely(message.action);
                } else if (message.type === 'DISPATCH') {
                    store.liftedStore.dispatch(message.action);
                }
            }

            function async(fn) {
                setTimeout(fn, 0);
            }

            function sendError(errorAction) {
                // Prevent flooding
                if (errorAction.message && errorAction.message === lastErrorMsg) return;
                lastErrorMsg = errorAction.message;

                async(function () {
                    store.dispatch(errorAction);
                    if (!started) send();
                });
            }

            function str2array(str) {
                return typeof str === 'string' ? [str] : str && str.length;
            }

            function init(options) {
                instanceName = options.name;
                if (options.filters) {
                    filters = options.filters;
                }
                if (options.port) {
                    socketOptions = {
                        port: options.port,
                        hostname: options.hostname || 'localhost',
                        secure: options.secure
                    };
                } else socketOptions = _constants.defaultSocketOptions;

                startOn = str2array(options.startOn);
                stopOn = str2array(options.stopOn);
                sendOn = str2array(options.sendOn);
                sendOnError = options.sendOnError;
                if (sendOn || sendOnError) {
                    sendTo = options.sendTo || (socketOptions.secure ? 'https' : 'http') + '://' + socketOptions.hostname + ':' + socketOptions.port;
                    instanceId = options.id;
                }
                if (sendOnError === 1) (0, _catchErrors2.default)(sendError);

                if (options.actionCreators) actionCreators = function actionCreators() {
                    return (0, _remotedevUtils.getActionsArray)(options.actionCreators);
                };
                stateSanitizer = options.stateSanitizer;
                actionSanitizer = options.actionSanitizer;
            }

            function login() {
                socket.emit('login', 'master', function (err, channelName) {
                    if (err) {
                        console.log(err);return;
                    }
                    channel = channelName;
                    socket.subscribe(channelName).watch(handleMessages);
                    socket.on(channelName, handleMessages);
                });
                started = true;
                relay('START');
            }

            function stop(keepConnected) {
                started = false;
                isMonitored = false;
                if (!socket) return;
                socket.destroyChannel(channel);
                if (keepConnected) {
                    socket.off(channel, handleMessages);
                } else {
                    socket.off();
                    socket.disconnect();
                }
            }

            function start() {
                if (started || socket && socket.getState() === socket.CONNECTING) return;

                socket = _socketclusterClient2.default.connect(socketOptions);
                socket.on('error', function (err) {
                    console.log(err);
                });
                socket.on('connect', function () {
                    login();
                });
                socket.on('disconnect', function () {
                    stop(true);
                });
            }

            function checkForReducerErrors() {
                var liftedState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : store.liftedStore.getState();

                if (liftedState.computedStates[liftedState.currentStateIndex].error) {
                    if (started) relay('STATE', (0, _filters.filterStagedActions)(liftedState, filters));else send();
                    return true;
                }
                return false;
            }

            function monitorReducer() {
                var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
                var action = arguments[1];

                lastAction = action.type;
                if (!started && sendOnError === 2 && store.liftedStore) async(checkForReducerErrors);else if (action.action) {
                    if (startOn && !started && startOn.indexOf(action.action.type) !== -1) async(start);else if (stopOn && started && stopOn.indexOf(action.action.type) !== -1) async(stop);else if (sendOn && !started && sendOn.indexOf(action.action.type) !== -1) async(send);
                }
                return state;
            }

            function handleChange(state, liftedState, maxAge) {
                if (checkForReducerErrors(liftedState)) return;

                if (lastAction === 'PERFORM_ACTION') {
                    var nextActionId = liftedState.nextActionId;
                    var liftedAction = liftedState.actionsById[nextActionId - 1];
                    relay('ACTION', state, liftedAction, nextActionId);
                    if (!isExcess && maxAge) isExcess = liftedState.stagedActionIds.length >= maxAge;
                } else {
                    if (lastAction === 'JUMP_TO_STATE') return;
                    if (lastAction === 'PAUSE_RECORDING') {
                        paused = liftedState.isPaused;
                    } else if (lastAction === 'LOCK_CHANGES') {
                        locked = liftedState.isLocked;
                    }
                    if (paused) {
                        if (lastAction) lastAction = undefined;else return;
                    }
                    relay('STATE', (0, _filters.filterStagedActions)(liftedState, filters));
                }
            }

            function devTools() {
                var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

                init(_extends({}, options, {
                    hostname: (0, _reactNative.getHostForRN)(options.hostname)
                }));
                var realtime = typeof options.realtime === 'undefined' ? "development" === 'development' : options.realtime;
                if (!realtime && !(startOn || sendOn || sendOnError)) return function (f) {
                    return f;
                };

                var maxAge = options.maxAge || 30;
                return function (next) {
                    return function (reducer, initialState) {
                        store = (0, _configureStore2.default)(next, monitorReducer, {
                            maxAge: maxAge,
                            shouldCatchErrors: !!sendOnError,
                            shouldHotReload: options.shouldHotReload,
                            shouldRecordChanges: options.shouldRecordChanges,
                            shouldStartLocked: options.shouldStartLocked,
                            pauseActionType: options.pauseActionType || '@@PAUSED'
                        })(reducer, initialState);

                        if (realtime) start();
                        store.subscribe(function () {
                            if (isMonitored) handleChange(store.getState(), store.liftedStore.getState(), maxAge);
                        });
                        return store;
                    };
                };
            }

            function preDevTools(createStore) {
                return function (reducer, preloadedState, enhancer) {
                    store = createStore(reducer, preloadedState, enhancer);
                    return _extends({}, store, {
                        dispatch: function dispatch(action) {
                            return locked ? action : store.dispatch(action);
                        }
                    });
                };
            }

            devTools.updateStore = function (newStore) {
                store = newStore;
            };

            function composeWithDevTools() {
                for (var _len = arguments.length, funcs = Array(_len), _key = 0; _key < _len; _key++) {
                    funcs[_key] = arguments[_key];
                }

                if (funcs.length === 0) {
                    return devTools;
                }

                if (funcs.length === 1 && _typeof(funcs[0]) === 'object') {
                    return devTools(funcs[0]);
                }

                return function (options) {
                    return function () {
                        return [preDevTools].concat(funcs).reduceRight(function (composed, f) {
                            return f(composed);
                        }, devTools(options).apply(undefined, arguments));
                    };
                };
            }

            /***/
        },
        /* 55 */
        /***/function (module, exports) {

            'use strict';

            exports.__esModule = true;
            exports.getHostForRN = getHostForRN;
            /*
             * Get React Native server IP if hostname is `localhost`
             * On Android emulator, the IP of host is `10.0.2.2` (Genymotion: 10.0.3.2)
             */
            function getHostForRN(hostname) {
                if ((hostname === 'localhost' || hostname === '127.0.0.1') && typeof window !== 'undefined' && window.__fbBatchedBridge && window.__fbBatchedBridge.RemoteModules && window.__fbBatchedBridge.RemoteModules.AndroidConstants) {
                    var _window$__fbBatchedBr = window.__fbBatchedBridge.RemoteModules.AndroidConstants.ServerHost;
                    var ServerHost = _window$__fbBatchedBr === undefined ? hostname : _window$__fbBatchedBr;

                    return ServerHost.split(':')[0];
                }

                return hostname;
            }

            /***/
        },
        /* 56 */
        /***/function (module, exports, __webpack_require__) {

            var __WEBPACK_AMD_DEFINE_RESULT__; /* WEBPACK VAR INJECTION */(function (module, global) {
                /*! http://mths.be/base64 v0.1.0 by @mathias | MIT license */
                ;(function (root) {

                    // Detect free variables `exports`.
                    var freeExports = (typeof exports === 'undefined' ? 'undefined' : _typeof2(exports)) == 'object' && exports;

                    // Detect free variable `module`.
                    var freeModule = (typeof module === 'undefined' ? 'undefined' : _typeof2(module)) == 'object' && module && module.exports == freeExports && module;

                    // Detect free variable `global`, from Node.js or Browserified code, and use
                    // it as `root`.
                    var freeGlobal = (typeof global === 'undefined' ? 'undefined' : _typeof2(global)) == 'object' && global;
                    if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
                        root = freeGlobal;
                    }

                    /*--------------------------------------------------------------------------*/

                    var InvalidCharacterError = function InvalidCharacterError(message) {
                        this.message = message;
                    };
                    InvalidCharacterError.prototype = new Error();
                    InvalidCharacterError.prototype.name = 'InvalidCharacterError';

                    var error = function error(message) {
                        // Note: the error messages used throughout this file match those used by
                        // the native `atob`/`btoa` implementation in Chromium.
                        throw new InvalidCharacterError(message);
                    };

                    var TABLE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
                    // http://whatwg.org/html/common-microsyntaxes.html#space-character
                    var REGEX_SPACE_CHARACTERS = /[\t\n\f\r ]/g;

                    // `decode` is designed to be fully compatible with `atob` as described in the
                    // HTML Standard. http://whatwg.org/html/webappapis.html#dom-windowbase64-atob
                    // The optimized base64-decoding algorithm used is based on @atks excellent
                    // implementation. https://gist.github.com/atk/1020396
                    var decode = function decode(input) {
                        input = String(input).replace(REGEX_SPACE_CHARACTERS, '');
                        var length = input.length;
                        if (length % 4 == 0) {
                            input = input.replace(/==?$/, '');
                            length = input.length;
                        }
                        if (length % 4 == 1 ||
                        // http://whatwg.org/C#alphanumeric-ascii-characters
                        /[^+a-zA-Z0-9/]/.test(input)) {
                            error('Invalid character: the string to be decoded is not correctly encoded.');
                        }
                        var bitCounter = 0;
                        var bitStorage;
                        var buffer;
                        var output = '';
                        var position = -1;
                        while (++position < length) {
                            buffer = TABLE.indexOf(input.charAt(position));
                            bitStorage = bitCounter % 4 ? bitStorage * 64 + buffer : buffer;
                            // Unless this is the first of a group of 4 characters
                            if (bitCounter++ % 4) {
                                // convert the first 8 bits to a single ASCII character.
                                output += String.fromCharCode(0xFF & bitStorage >> (-2 * bitCounter & 6));
                            }
                        }
                        return output;
                    };

                    // `encode` is designed to be fully compatible with `btoa` as described in the
                    // HTML Standard: http://whatwg.org/html/webappapis.html#dom-windowbase64-btoa
                    var encode = function encode(input) {
                        input = String(input);
                        if (/[^\0-\xFF]/.test(input)) {
                            // Note: no need to special-case astral symbols here, as surrogates are
                            // matched, and the input is supposed to only contain ASCII anyway.
                            error('The string to be encoded contains characters outside of the ' + 'Latin1 range.');
                        }
                        var padding = input.length % 3;
                        var output = '';
                        var position = -1;
                        var a;
                        var b;
                        var c;
                        var d;
                        var buffer;
                        // Make sure any padding is handled outside of the loop.
                        var length = input.length - padding;

                        while (++position < length) {
                            // Read three bytes, i.e. 24 bits.
                            a = input.charCodeAt(position) << 16;
                            b = input.charCodeAt(++position) << 8;
                            c = input.charCodeAt(++position);
                            buffer = a + b + c;
                            // Turn the 24 bits into four chunks of 6 bits each, and append the
                            // matching character for each of them to the output.
                            output += TABLE.charAt(buffer >> 18 & 0x3F) + TABLE.charAt(buffer >> 12 & 0x3F) + TABLE.charAt(buffer >> 6 & 0x3F) + TABLE.charAt(buffer & 0x3F);
                        }

                        if (padding == 2) {
                            a = input.charCodeAt(position) << 8;
                            b = input.charCodeAt(++position);
                            buffer = a + b;
                            output += TABLE.charAt(buffer >> 10) + TABLE.charAt(buffer >> 4 & 0x3F) + TABLE.charAt(buffer << 2 & 0x3F) + '=';
                        } else if (padding == 1) {
                            buffer = input.charCodeAt(position);
                            output += TABLE.charAt(buffer >> 2) + TABLE.charAt(buffer << 4 & 0x3F) + '==';
                        }

                        return output;
                    };

                    var base64 = {
                        'encode': encode,
                        'decode': decode,
                        'version': '0.1.0'
                    };

                    // Some AMD build optimizers, like r.js, check for specific condition patterns
                    // like the following:
                    if (true) {
                        !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
                            return base64;
                        }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                    } else if (freeExports && !freeExports.nodeType) {
                        if (freeModule) {
                            // in Node.js or RingoJS v0.8.0+
                            freeModule.exports = base64;
                        } else {
                            // in Narwhal or RingoJS v0.7.0-
                            for (var key in base64) {
                                base64.hasOwnProperty(key) && (freeExports[key] = base64[key]);
                            }
                        }
                    } else {
                        // in Rhino or a web browser
                        root.base64 = base64;
                    }
                })(this);

                /* WEBPACK VAR INJECTION */
            }).call(exports, __webpack_require__(51)(module), function () {
                return this;
            }());

            /***/
        },
        /* 57 */
        /***/function (module, exports) {

            'use strict';

            exports.byteLength = byteLength;
            exports.toByteArray = toByteArray;
            exports.fromByteArray = fromByteArray;

            var lookup = [];
            var revLookup = [];
            var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;

            var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
            for (var i = 0, len = code.length; i < len; ++i) {
                lookup[i] = code[i];
                revLookup[code.charCodeAt(i)] = i;
            }

            revLookup['-'.charCodeAt(0)] = 62;
            revLookup['_'.charCodeAt(0)] = 63;

            function placeHoldersCount(b64) {
                var len = b64.length;
                if (len % 4 > 0) {
                    throw new Error('Invalid string. Length must be a multiple of 4');
                }

                // the number of equal signs (place holders)
                // if there are two placeholders, than the two characters before it
                // represent one byte
                // if there is only one, then the three characters before it represent 2 bytes
                // this is just a cheap hack to not do indexOf twice
                return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;
            }

            function byteLength(b64) {
                // base64 is 4/3 + up to two characters of the original data
                return b64.length * 3 / 4 - placeHoldersCount(b64);
            }

            function toByteArray(b64) {
                var i, j, l, tmp, placeHolders, arr;
                var len = b64.length;
                placeHolders = placeHoldersCount(b64);

                arr = new Arr(len * 3 / 4 - placeHolders);

                // if there are placeholders, only get up to the last complete 4 chars
                l = placeHolders > 0 ? len - 4 : len;

                var L = 0;

                for (i = 0, j = 0; i < l; i += 4, j += 3) {
                    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
                    arr[L++] = tmp >> 16 & 0xFF;
                    arr[L++] = tmp >> 8 & 0xFF;
                    arr[L++] = tmp & 0xFF;
                }

                if (placeHolders === 2) {
                    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
                    arr[L++] = tmp & 0xFF;
                } else if (placeHolders === 1) {
                    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
                    arr[L++] = tmp >> 8 & 0xFF;
                    arr[L++] = tmp & 0xFF;
                }

                return arr;
            }

            function tripletToBase64(num) {
                return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
            }

            function encodeChunk(uint8, start, end) {
                var tmp;
                var output = [];
                for (var i = start; i < end; i += 3) {
                    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
                    output.push(tripletToBase64(tmp));
                }
                return output.join('');
            }

            function fromByteArray(uint8) {
                var tmp;
                var len = uint8.length;
                var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
                var output = '';
                var parts = [];
                var maxChunkLength = 16383; // must be multiple of 3

                // go through the array every three bytes, we'll deal with trailing stuff later
                for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
                    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
                }

                // pad the end with zeros, but make sure to not forget the extra bytes
                if (extraBytes === 1) {
                    tmp = uint8[len - 1];
                    output += lookup[tmp >> 2];
                    output += lookup[tmp << 4 & 0x3F];
                    output += '==';
                } else if (extraBytes === 2) {
                    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
                    output += lookup[tmp >> 10];
                    output += lookup[tmp >> 4 & 0x3F];
                    output += lookup[tmp << 2 & 0x3F];
                    output += '=';
                }

                parts.push(output);

                return parts.join('');
            }

            /***/
        },
        /* 58 */
        /***/function (module, exports) {

            /**
             * Expose `Emitter`.
             */

            module.exports = Emitter;

            /**
             * Initialize a new `Emitter`.
             *
             * @api public
             */

            function Emitter(obj) {
                if (obj) return mixin(obj);
            };

            /**
             * Mixin the emitter properties.
             *
             * @param {Object} obj
             * @return {Object}
             * @api private
             */

            function mixin(obj) {
                for (var key in Emitter.prototype) {
                    obj[key] = Emitter.prototype[key];
                }
                return obj;
            }

            /**
             * Listen on the given `event` with `fn`.
             *
             * @param {String} event
             * @param {Function} fn
             * @return {Emitter}
             * @api public
             */

            Emitter.prototype.on = Emitter.prototype.addEventListener = function (event, fn) {
                this._callbacks = this._callbacks || {};
                (this._callbacks['$' + event] = this._callbacks['$' + event] || []).push(fn);
                return this;
            };

            /**
             * Adds an `event` listener that will be invoked a single
             * time then automatically removed.
             *
             * @param {String} event
             * @param {Function} fn
             * @return {Emitter}
             * @api public
             */

            Emitter.prototype.once = function (event, fn) {
                function on() {
                    this.off(event, on);
                    fn.apply(this, arguments);
                }

                on.fn = fn;
                this.on(event, on);
                return this;
            };

            /**
             * Remove the given callback for `event` or all
             * registered callbacks.
             *
             * @param {String} event
             * @param {Function} fn
             * @return {Emitter}
             * @api public
             */

            Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function (event, fn) {
                this._callbacks = this._callbacks || {};

                // all
                if (0 == arguments.length) {
                    this._callbacks = {};
                    return this;
                }

                // specific event
                var callbacks = this._callbacks['$' + event];
                if (!callbacks) return this;

                // remove all handlers
                if (1 == arguments.length) {
                    delete this._callbacks['$' + event];
                    return this;
                }

                // remove specific handler
                var cb;
                for (var i = 0; i < callbacks.length; i++) {
                    cb = callbacks[i];
                    if (cb === fn || cb.fn === fn) {
                        callbacks.splice(i, 1);
                        break;
                    }
                }
                return this;
            };

            /**
             * Emit `event` with the given args.
             *
             * @param {String} event
             * @param {Mixed} ...
             * @return {Emitter}
             */

            Emitter.prototype.emit = function (event) {
                this._callbacks = this._callbacks || {};
                var args = [].slice.call(arguments, 1),
                    callbacks = this._callbacks['$' + event];

                if (callbacks) {
                    callbacks = callbacks.slice(0);
                    for (var i = 0, len = callbacks.length; i < len; ++i) {
                        callbacks[i].apply(this, args);
                    }
                }

                return this;
            };

            /**
             * Return array of callbacks for `event`.
             *
             * @param {String} event
             * @return {Array}
             * @api public
             */

            Emitter.prototype.listeners = function (event) {
                this._callbacks = this._callbacks || {};
                return this._callbacks['$' + event] || [];
            };

            /**
             * Check if this emitter has `event` handlers.
             *
             * @param {String} event
             * @return {Boolean}
             * @api public
             */

            Emitter.prototype.hasListeners = function (event) {
                return !!this.listeners(event).length;
            };

            /***/
        },
        /* 59 */
        /***/function (module, exports) {

            /*
                cycle.js
                2013-02-19
                             Public Domain.
                             NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.
                             This code should be minified before deployment.
                See http://javascript.crockford.com/jsmin.html
                             USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO
                NOT CONTROL.
            */

            /*jslint evil: true, regexp: true */

            /*members $ref, apply, call, decycle, hasOwnProperty, length, prototype, push,
                retrocycle, stringify, test, toString
            */

            var cycle = exports;

            cycle.decycle = function decycle(object) {
                'use strict';

                // Make a deep copy of an object or array, assuring that there is at most
                // one instance of each object or array in the resulting structure. The
                // duplicate references (which might be forming cycles) are replaced with
                // an object of the form
                //      {$ref: PATH}
                // where the PATH is a JSONPath string that locates the first occurance.
                // So,
                //      var a = [];
                //      a[0] = a;
                //      return JSON.stringify(JSON.decycle(a));
                // produces the string '[{"$ref":"$"}]'.

                // JSONPath is used to locate the unique object. $ indicates the top level of
                // the object or array. [NUMBER] or [STRING] indicates a child member or
                // property.

                var objects = [],
                    // Keep a reference to each unique object or array
                paths = []; // Keep the path to each unique object or array

                return function derez(value, path) {

                    // The derez recurses through the object, producing the deep copy.

                    var i, // The loop counter
                    name, // Property name
                    nu; // The new object or array

                    // typeof null === 'object', so go on if this value is really an object but not
                    // one of the weird builtin objects.

                    if ((typeof value === 'undefined' ? 'undefined' : _typeof2(value)) === 'object' && value !== null && !(value instanceof Boolean) && !(value instanceof Date) && !(value instanceof Number) && !(value instanceof RegExp) && !(value instanceof String)) {

                        // If the value is an object or array, look to see if we have already
                        // encountered it. If so, return a $ref/path object. This is a hard way,
                        // linear search that will get slower as the number of unique objects grows.

                        for (i = 0; i < objects.length; i += 1) {
                            if (objects[i] === value) {
                                return { $ref: paths[i] };
                            }
                        }

                        // Otherwise, accumulate the unique value and its path.

                        objects.push(value);
                        paths.push(path);

                        // If it is an array, replicate the array.

                        if (Object.prototype.toString.apply(value) === '[object Array]') {
                            nu = [];
                            for (i = 0; i < value.length; i += 1) {
                                nu[i] = derez(value[i], path + '[' + i + ']');
                            }
                        } else {

                            // If it is an object, replicate the object.

                            nu = {};
                            for (name in value) {
                                if (Object.prototype.hasOwnProperty.call(value, name)) {
                                    nu[name] = derez(value[name], path + '[' + JSON.stringify(name) + ']');
                                }
                            }
                        }
                        return nu;
                    }
                    return value;
                }(object, '$');
            };

            cycle.retrocycle = function retrocycle($) {
                'use strict';

                // Restore an object that was reduced by decycle. Members whose values are
                // objects of the form
                //      {$ref: PATH}
                // are replaced with references to the value found by the PATH. This will
                // restore cycles. The object will be mutated.

                // The eval function is used to locate the values described by a PATH. The
                // root object is kept in a $ variable. A regular expression is used to
                // assure that the PATH is extremely well formed. The regexp contains nested
                // * quantifiers. That has been known to have extremely bad performance
                // problems on some browsers for very long strings. A PATH is expected to be
                // reasonably short. A PATH is allowed to belong to a very restricted subset of
                // Goessner's JSONPath.

                // So,
                //      var s = '[{"$ref":"$"}]';
                //      return JSON.retrocycle(JSON.parse(s));
                // produces an array containing a single element which is the array itself.

                var px = /^\$(?:\[(?:\d+|\"(?:[^\\\"\u0000-\u001f]|\\([\\\"\/bfnrt]|u[0-9a-zA-Z]{4}))*\")\])*$/;

                (function rez(value) {

                    // The rez function walks recursively through the object looking for $ref
                    // properties. When it finds one that has a value that is a path, then it
                    // replaces the $ref object with a reference to the value that is found by
                    // the path.

                    var i, item, name, path;

                    if (value && (typeof value === 'undefined' ? 'undefined' : _typeof2(value)) === 'object') {
                        if (Object.prototype.toString.apply(value) === '[object Array]') {
                            for (i = 0; i < value.length; i += 1) {
                                item = value[i];
                                if (item && (typeof item === 'undefined' ? 'undefined' : _typeof2(item)) === 'object') {
                                    path = item.$ref;
                                    if (typeof path === 'string' && px.test(path)) {
                                        value[i] = eval(path);
                                    } else {
                                        rez(item);
                                    }
                                }
                            }
                        } else {
                            for (name in value) {
                                if (_typeof2(value[name]) === 'object') {
                                    item = value[name];
                                    if (item) {
                                        path = item.$ref;
                                        if (typeof path === 'string' && px.test(path)) {
                                            value[name] = eval(path);
                                        } else {
                                            rez(item);
                                        }
                                    }
                                }
                            }
                        }
                    }
                })($);
                return $;
            };

            /***/
        },
        /* 60 */
        /***/function (module, exports) {

            /* global window */
            var GetParams = function GetParams(func) {
                'use strict';

                if (typeof func !== 'function') {
                    return [];
                }

                var patternComments = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
                var patternArguments = /([^\s,]+)/g;

                var funcString = func.toString().replace(patternComments, '');

                var result = funcString.slice(funcString.indexOf('(') + 1, funcString.indexOf(')')).match(patternArguments);

                if (result === null) {
                    return [];
                }

                return result;
            };

            if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
                module.exports = GetParams;
            }

            if (typeof window !== 'undefined') {
                window.GetParams = GetParams;
            }

            /***/
        },
        /* 61 */
        /***/function (module, exports) {

            exports.read = function (buffer, offset, isLE, mLen, nBytes) {
                var e, m;
                var eLen = nBytes * 8 - mLen - 1;
                var eMax = (1 << eLen) - 1;
                var eBias = eMax >> 1;
                var nBits = -7;
                var i = isLE ? nBytes - 1 : 0;
                var d = isLE ? -1 : 1;
                var s = buffer[offset + i];

                i += d;

                e = s & (1 << -nBits) - 1;
                s >>= -nBits;
                nBits += eLen;
                for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

                m = e & (1 << -nBits) - 1;
                e >>= -nBits;
                nBits += mLen;
                for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

                if (e === 0) {
                    e = 1 - eBias;
                } else if (e === eMax) {
                    return m ? NaN : (s ? -1 : 1) * Infinity;
                } else {
                    m = m + Math.pow(2, mLen);
                    e = e - eBias;
                }
                return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
            };

            exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
                var e, m, c;
                var eLen = nBytes * 8 - mLen - 1;
                var eMax = (1 << eLen) - 1;
                var eBias = eMax >> 1;
                var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
                var i = isLE ? 0 : nBytes - 1;
                var d = isLE ? 1 : -1;
                var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;

                value = Math.abs(value);

                if (isNaN(value) || value === Infinity) {
                    m = isNaN(value) ? 1 : 0;
                    e = eMax;
                } else {
                    e = Math.floor(Math.log(value) / Math.LN2);
                    if (value * (c = Math.pow(2, -e)) < 1) {
                        e--;
                        c *= 2;
                    }
                    if (e + eBias >= 1) {
                        value += rt / c;
                    } else {
                        value += rt * Math.pow(2, 1 - eBias);
                    }
                    if (value * c >= 2) {
                        e++;
                        c /= 2;
                    }

                    if (e + eBias >= eMax) {
                        m = 0;
                        e = eMax;
                    } else if (e + eBias >= 1) {
                        m = (value * c - 1) * Math.pow(2, mLen);
                        e = e + eBias;
                    } else {
                        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
                        e = 0;
                    }
                }

                for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

                e = e << mLen | m;
                eLen += mLen;
                for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

                buffer[offset + i - d] |= s * 128;
            };

            /***/
        },
        /* 62 */
        /***/function (module, exports) {

            var toString = {}.toString;

            module.exports = Array.isArray || function (arr) {
                return toString.call(arr) == '[object Array]';
            };

            /***/
        },
        /* 63 */
        /***/function (module, exports, __webpack_require__) {

            module.exports = __webpack_require__(65);

            /***/
        },
        /* 64 */
        /***/function (module, exports, __webpack_require__) {

            var pathGetter = __webpack_require__(27);
            var utils = __webpack_require__(66);

            // Based on https://github.com/douglascrockford/JSON-js/blob/master/cycle.js

            exports.decycle = function decycle(object, options, replacer) {
                'use strict';

                var objects = [],
                    // Keep a reference to each unique object or array
                paths = []; // Keep the path to each unique object or array

                return function derez(_value, path, key) {

                    // The derez recurses through the object, producing the deep copy.

                    var i, // The loop counter
                    name, // Property name
                    nu; // The new object or array

                    // typeof null === 'object', so go on if this value is really an object but not
                    // one of the weird builtin objects.

                    var value = replacer ? replacer(key || '', _value) : _value;

                    if (options.date && value instanceof Date) {
                        return { $jsan: 'd' + value.getTime() };
                    }
                    if (options.regex && value instanceof RegExp) {
                        return { $jsan: 'r' + utils.getRegexFlags(value) + ',' + value.source };
                    }
                    if (options['function'] && typeof value === 'function') {
                        return { $jsan: 'f' + utils.stringifyFunction(value, options['function']) };
                    }
                    if (options['undefined'] && value === undefined) {
                        return { $jsan: 'u' };
                    }
                    if (options['error'] && value instanceof Error) {
                        return { $jsan: 'e' + value.message };
                    }

                    if (value && typeof value.toJSON === 'function') {
                        value = value.toJSON();
                    }

                    if ((typeof value === 'undefined' ? 'undefined' : _typeof2(value)) === 'object' && value !== null && !(value instanceof Boolean) && !(value instanceof Date) && !(value instanceof Number) && !(value instanceof RegExp) && !(value instanceof String) && !(value instanceof Error)) {

                        // If the value is an object or array, look to see if we have already
                        // encountered it. If so, return a $ref/path object. This is a hard way,
                        // linear search that will get slower as the number of unique objects grows.

                        for (i = 0; i < objects.length; i += 1) {
                            if (objects[i] === value) {
                                return { $jsan: paths[i] };
                            }
                        }

                        // Otherwise, accumulate the unique value and its path.

                        objects.push(value);
                        paths.push(path);

                        // If it is an array, replicate the array.

                        if (Object.prototype.toString.apply(value) === '[object Array]') {
                            nu = [];
                            for (i = 0; i < value.length; i += 1) {
                                nu[i] = derez(value[i], path + '[' + i + ']', i);
                            }
                        } else {

                            // If it is an object, replicate the object.

                            nu = {};
                            for (name in value) {
                                if (Object.prototype.hasOwnProperty.call(value, name)) {
                                    var nextPath = /^\w+$/.test(name) ? '.' + name : '[' + JSON.stringify(name) + ']';
                                    nu[name] = name === '$jsan' ? [derez(value[name], path + nextPath)] : derez(value[name], path + nextPath, name);
                                }
                            }
                        }
                        return nu;
                    }
                    return value;
                }(object, '$');
            };

            exports.retrocycle = function retrocycle($) {
                'use strict';

                (function rez(value) {

                    // The rez function walks recursively through the object looking for $jsan
                    // properties. When it finds one that has a value that is a path, then it
                    // replaces the $jsan object with a reference to the value that is found by
                    // the path.

                    var i, item, name, path;

                    if (value && (typeof value === 'undefined' ? 'undefined' : _typeof2(value)) === 'object') {
                        if (Object.prototype.toString.apply(value) === '[object Array]') {
                            for (i = 0; i < value.length; i += 1) {
                                item = value[i];
                                if (item && (typeof item === 'undefined' ? 'undefined' : _typeof2(item)) === 'object') {
                                    if (item.$jsan) {
                                        value[i] = utils.restore(item.$jsan, $);
                                    } else {
                                        rez(item);
                                    }
                                }
                            }
                        } else {
                            for (name in value) {
                                if (name === '$jsan') {
                                    value[name] = value[name][0];
                                }
                                if (_typeof2(value[name]) === 'object') {
                                    item = value[name];
                                    if (item && (typeof item === 'undefined' ? 'undefined' : _typeof2(item)) === 'object') {
                                        if (item.$jsan) {
                                            value[name] = utils.restore(item.$jsan, $);
                                        } else {
                                            rez(item);
                                        }
                                    }
                                }
                            }
                        }
                    }
                })($);
                return $;
            };

            /***/
        },
        /* 65 */
        /***/function (module, exports, __webpack_require__) {

            var cycle = __webpack_require__(64);

            exports.stringify = function stringify(value, replacer, space, _options) {

                if (arguments.length < 4) {
                    try {
                        if (arguments.length === 1) {
                            return JSON.stringify(value);
                        } else {
                            return JSON.stringify.apply(JSON, arguments);
                        }
                    } catch (e) {}
                }

                var options = _options || false;
                if (typeof options === 'boolean') {
                    options = {
                        'date': options,
                        'function': options,
                        'regex': options,
                        'undefined': options,
                        'error': options
                    };
                }

                var decycled = cycle.decycle(value, options, replacer);
                if (arguments.length === 1) {
                    return JSON.stringify(decycled);
                } else {
                    return JSON.stringify(decycled, replacer, space);
                }
            };

            exports.parse = function parse(text, reviver) {
                var needsRetrocycle = /"\$jsan"/.test(text);
                var parsed;
                if (arguments.length === 1) {
                    parsed = JSON.parse(text);
                } else {
                    parsed = JSON.parse(text, reviver);
                }
                if (needsRetrocycle) {
                    parsed = cycle.retrocycle(parsed);
                }
                return parsed;
            };

            /***/
        },
        /* 66 */
        /***/function (module, exports, __webpack_require__) {

            var pathGetter = __webpack_require__(27);

            exports.getRegexFlags = function getRegexFlags(regex) {
                var flags = '';
                if (regex.ignoreCase) flags += 'i';
                if (regex.global) flags += 'g';
                if (regex.multiline) flags += 'm';
                return flags;
            };

            exports.stringifyFunction = function stringifyFunction(fn, customToString) {
                if (typeof customToString === 'function') {
                    return customToString(fn);
                }
                var str = fn.toString();
                var match = str.match(/^[^{]*{|^[^=]*=>/);
                var start = match ? match[0] : '<function> ';
                var end = str[str.length - 1] === '}' ? '}' : '';
                return start.replace(/\r\n|\n/g, ' ').replace(/\s+/g, ' ') + ' /* ... */ ' + end;
            };

            exports.restore = function restore(obj, root) {
                var type = obj[0];
                var rest = obj.slice(1);
                switch (type) {
                    case '$':
                        return pathGetter(root, obj);
                    case 'r':
                        var comma = rest.indexOf(',');
                        var flags = rest.slice(0, comma);
                        var source = rest.slice(comma + 1);
                        return RegExp(source, flags);
                    case 'd':
                        return new Date(+rest);
                    case 'f':
                        var fn = function fn() {
                            throw new Error("can't run jsan parsed function");
                        };
                        fn.toString = function () {
                            return rest;
                        };
                        return fn;
                    case 'u':
                        return undefined;
                    case 'e':
                        var error = new Error(rest);
                        error.stack = 'Stack is unavailable for jsan parsed errors';
                        return error;
                    default:
                        console.warn('unknown type', obj);
                        return obj;
                }
            };

            /***/
        },
        /* 67 */
        /***/function (module, exports) {

            'use strict';

            /**
             * Constants.
             */

            var errorMessage;

            errorMessage = 'An argument without append, prepend, ' + 'or detach methods was given to `List';

            /**
             * Creates a new List: A linked list is a bit like an Array, but
             * knows nothing about how many items are in it, and knows only about its
             * first (`head`) and last (`tail`) items. Each item (e.g. `head`, `tail`,
             * &c.) knows which item comes before or after it (its more like the
             * implementation of the DOM in JavaScript).
             * @global
             * @private
             * @constructor
             * @class Represents an instance of List.
             */

            function List() /*items...*/{
                if (arguments.length) {
                    return List.from(arguments);
                }
            }

            var ListPrototype;

            ListPrototype = List.prototype;

            /**
             * Creates a new list from the arguments (each a list item) passed in.
             * @name List.of
             * @param {...ListItem} [items] - Zero or more items to attach.
             * @returns {list} - A new instance of List.
             */

            List.of = function () /*items...*/{
                return List.from.call(this, arguments);
            };

            /**
             * Creates a new list from the given array-like object (each a list item)
             * passed in.
             * @name List.from
             * @param {ListItem[]} [items] - The items to append.
             * @returns {list} - A new instance of List.
             */
            List.from = function (items) {
                var list = new this(),
                    length,
                    iterator,
                    item;

                if (items && (length = items.length)) {
                    iterator = -1;

                    while (++iterator < length) {
                        item = items[iterator];

                        if (item !== null && item !== undefined) {
                            list.append(item);
                        }
                    }
                }

                return list;
            };

            /**
             * List#head
             * Default to `null`.
             */
            ListPrototype.head = null;

            /**
             * List#tail
             * Default to `null`.
             */
            ListPrototype.tail = null;

            /**
             * Returns the list's items as an array. This does *not* detach the items.
             * @name List#toArray
             * @returns {ListItem[]} - An array of (still attached) ListItems.
             */
            ListPrototype.toArray = function () {
                var item = this.head,
                    result = [];

                while (item) {
                    result.push(item);
                    item = item.next;
                }

                return result;
            };

            /**
             * Prepends the given item to the list: Item will be the new first item
             * (`head`).
             * @name List#prepend
             * @param {ListItem} item - The item to prepend.
             * @returns {ListItem} - An instance of ListItem (the given item).
             */
            ListPrototype.prepend = function (item) {
                if (!item) {
                    return false;
                }

                if (!item.append || !item.prepend || !item.detach) {
                    throw new Error(errorMessage + '#prepend`.');
                }

                var self, head;

                // Cache self.
                self = this;

                // If self has a first item, defer prepend to the first items prepend
                // method, and return the result.
                head = self.head;

                if (head) {
                    return head.prepend(item);
                }

                // ...otherwise, there is no `head` (or `tail`) item yet.

                // Detach the prependee.
                item.detach();

                // Set the prependees parent list to reference self.
                item.list = self;

                // Set self's first item to the prependee, and return the item.
                self.head = item;

                return item;
            };

            /**
             * Appends the given item to the list: Item will be the new last item (`tail`)
             * if the list had a first item, and its first item (`head`) otherwise.
             * @name List#append
             * @param {ListItem} item - The item to append.
             * @returns {ListItem} - An instance of ListItem (the given item).
             */

            ListPrototype.append = function (item) {
                if (!item) {
                    return false;
                }

                if (!item.append || !item.prepend || !item.detach) {
                    throw new Error(errorMessage + '#append`.');
                }

                var self, head, tail;

                // Cache self.
                self = this;

                // If self has a last item, defer appending to the last items append
                // method, and return the result.
                tail = self.tail;

                if (tail) {
                    return tail.append(item);
                }

                // If self has a first item, defer appending to the first items append
                // method, and return the result.
                head = self.head;

                if (head) {
                    return head.append(item);
                }

                // ...otherwise, there is no `tail` or `head` item yet.

                // Detach the appendee.
                item.detach();

                // Set the appendees parent list to reference self.
                item.list = self;

                // Set self's first item to the appendee, and return the item.
                self.head = item;

                return item;
            };

            /**
             * Creates a new ListItem: A linked list item is a bit like DOM node:
             * It knows only about its "parent" (`list`), the item before it (`prev`),
             * and the item after it (`next`).
             * @global
             * @private
             * @constructor
             * @class Represents an instance of ListItem.
             */

            function ListItem() {}

            List.Item = ListItem;

            var ListItemPrototype = ListItem.prototype;

            ListItemPrototype.next = null;

            ListItemPrototype.prev = null;

            ListItemPrototype.list = null;

            /**
             * Detaches the item operated on from its parent list.
             * @name ListItem#detach
             * @returns {ListItem} - The item operated on.
             */
            ListItemPrototype.detach = function () {
                // Cache self, the parent list, and the previous and next items.
                var self = this,
                    list = self.list,
                    prev = self.prev,
                    next = self.next;

                // If the item is already detached, return self.
                if (!list) {
                    return self;
                }

                // If self is the last item in the parent list, link the lists last item
                // to the previous item.
                if (list.tail === self) {
                    list.tail = prev;
                }

                // If self is the first item in the parent list, link the lists first item
                // to the next item.
                if (list.head === self) {
                    list.head = next;
                }

                // If both the last and first items in the parent list are the same,
                // remove the link to the last item.
                if (list.tail === list.head) {
                    list.tail = null;
                }

                // If a previous item exists, link its next item to selfs next item.
                if (prev) {
                    prev.next = next;
                }

                // If a next item exists, link its previous item to selfs previous item.
                if (next) {
                    next.prev = prev;
                }

                // Remove links from self to both the next and previous items, and to the
                // parent list.
                self.prev = self.next = self.list = null;

                // Return self.
                return self;
            };

            /**
             * Prepends the given item *before* the item operated on.
             * @name ListItem#prepend
             * @param {ListItem} item - The item to prepend.
             * @returns {ListItem} - The item operated on, or false when that item is not
             * attached.
             */
            ListItemPrototype.prepend = function (item) {
                if (!item || !item.append || !item.prepend || !item.detach) {
                    throw new Error(errorMessage + 'Item#prepend`.');
                }

                // Cache self, the parent list, and the previous item.
                var self = this,
                    list = self.list,
                    prev = self.prev;

                // If self is detached, return false.
                if (!list) {
                    return false;
                }

                // Detach the prependee.
                item.detach();

                // If self has a previous item...
                if (prev) {
                    // ...link the prependees previous item, to selfs previous item.
                    item.prev = prev;

                    // ...link the previous items next item, to self.
                    prev.next = item;
                }

                // Set the prependees next item to self.
                item.next = self;

                // Set the prependees parent list to selfs parent list.
                item.list = list;

                // Set the previous item of self to the prependee.
                self.prev = item;

                // If self is the first item in the parent list, link the lists first item
                // to the prependee.
                if (self === list.head) {
                    list.head = item;
                }

                // If the the parent list has no last item, link the lists last item to
                // self.
                if (!list.tail) {
                    list.tail = self;
                }

                // Return the prependee.
                return item;
            };

            /**
             * Appends the given item *after* the item operated on.
             * @name ListItem#append
             * @param {ListItem} item - The item to append.
             * @returns {ListItem} - The item operated on, or false when that item is not
             * attached.
             */
            ListItemPrototype.append = function (item) {
                // If item is falsey, return false.
                if (!item || !item.append || !item.prepend || !item.detach) {
                    throw new Error(errorMessage + 'Item#append`.');
                }

                // Cache self, the parent list, and the next item.
                var self = this,
                    list = self.list,
                    next = self.next;

                // If self is detached, return false.
                if (!list) {
                    return false;
                }

                // Detach the appendee.
                item.detach();

                // If self has a next item...
                if (next) {
                    // ...link the appendees next item, to selfs next item.
                    item.next = next;

                    // ...link the next items previous item, to the appendee.
                    next.prev = item;
                }

                // Set the appendees previous item to self.
                item.prev = self;

                // Set the appendees parent list to selfs parent list.
                item.list = list;

                // Set the next item of self to the appendee.
                self.next = item;

                // If the the parent list has no last item or if self is the parent lists
                // last item, link the lists last item to the appendee.
                if (self === list.tail || !list.tail) {
                    list.tail = item;
                }

                // Return the appendee.
                return item;
            };

            /**
             * Expose `List`.
             */

            module.exports = List;

            /***/
        },
        /* 68 */
        /***/function (module, exports, __webpack_require__) {

            'use strict';

            module.exports = __webpack_require__(67);

            /***/
        },
        /* 69 */
        /***/function (module, exports, __webpack_require__) {

            var getNative = __webpack_require__(2),
                root = __webpack_require__(1);

            /* Built-in method references that are verified to be native. */
            var DataView = getNative(root, 'DataView');

            module.exports = DataView;

            /***/
        },
        /* 70 */
        /***/function (module, exports, __webpack_require__) {

            var hashClear = __webpack_require__(112),
                hashDelete = __webpack_require__(113),
                hashGet = __webpack_require__(114),
                hashHas = __webpack_require__(115),
                hashSet = __webpack_require__(116);

            /**
             * Creates a hash object.
             *
             * @private
             * @constructor
             * @param {Array} [entries] The key-value pairs to cache.
             */
            function Hash(entries) {
                var index = -1,
                    length = entries ? entries.length : 0;

                this.clear();
                while (++index < length) {
                    var entry = entries[index];
                    this.set(entry[0], entry[1]);
                }
            }

            // Add methods to `Hash`.
            Hash.prototype.clear = hashClear;
            Hash.prototype['delete'] = hashDelete;
            Hash.prototype.get = hashGet;
            Hash.prototype.has = hashHas;
            Hash.prototype.set = hashSet;

            module.exports = Hash;

            /***/
        },
        /* 71 */
        /***/function (module, exports, __webpack_require__) {

            var getNative = __webpack_require__(2),
                root = __webpack_require__(1);

            /* Built-in method references that are verified to be native. */
            var Promise = getNative(root, 'Promise');

            module.exports = Promise;

            /***/
        },
        /* 72 */
        /***/function (module, exports, __webpack_require__) {

            var root = __webpack_require__(1);

            /** Built-in value references. */
            var Uint8Array = root.Uint8Array;

            module.exports = Uint8Array;

            /***/
        },
        /* 73 */
        /***/function (module, exports, __webpack_require__) {

            var getNative = __webpack_require__(2),
                root = __webpack_require__(1);

            /* Built-in method references that are verified to be native. */
            var WeakMap = getNative(root, 'WeakMap');

            module.exports = WeakMap;

            /***/
        },
        /* 74 */
        /***/function (module, exports) {

            /**
             * A faster alternative to `Function#apply`, this function invokes `func`
             * with the `this` binding of `thisArg` and the arguments of `args`.
             *
             * @private
             * @param {Function} func The function to invoke.
             * @param {*} thisArg The `this` binding of `func`.
             * @param {Array} args The arguments to invoke `func` with.
             * @returns {*} Returns the result of `func`.
             */
            function apply(func, thisArg, args) {
                switch (args.length) {
                    case 0:
                        return func.call(thisArg);
                    case 1:
                        return func.call(thisArg, args[0]);
                    case 2:
                        return func.call(thisArg, args[0], args[1]);
                    case 3:
                        return func.call(thisArg, args[0], args[1], args[2]);
                }
                return func.apply(thisArg, args);
            }

            module.exports = apply;

            /***/
        },
        /* 75 */
        /***/function (module, exports, __webpack_require__) {

            var baseTimes = __webpack_require__(99),
                isArguments = __webpack_require__(20),
                isArray = __webpack_require__(3),
                isIndex = __webpack_require__(40);

            /** Used for built-in method references. */
            var objectProto = Object.prototype;

            /** Used to check objects for own properties. */
            var hasOwnProperty = objectProto.hasOwnProperty;

            /**
             * Creates an array of the enumerable property names of the array-like `value`.
             *
             * @private
             * @param {*} value The value to query.
             * @param {boolean} inherited Specify returning inherited property names.
             * @returns {Array} Returns the array of property names.
             */
            function arrayLikeKeys(value, inherited) {
                // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
                // Safari 9 makes `arguments.length` enumerable in strict mode.
                var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];

                var length = result.length,
                    skipIndexes = !!length;

                for (var key in value) {
                    if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
                        result.push(key);
                    }
                }
                return result;
            }

            module.exports = arrayLikeKeys;

            /***/
        },
        /* 76 */
        /***/function (module, exports) {

            /**
             * A specialized version of `_.map` for arrays without support for iteratee
             * shorthands.
             *
             * @private
             * @param {Array} [array] The array to iterate over.
             * @param {Function} iteratee The function invoked per iteration.
             * @returns {Array} Returns the new mapped array.
             */
            function arrayMap(array, iteratee) {
                var index = -1,
                    length = array ? array.length : 0,
                    result = Array(length);

                while (++index < length) {
                    result[index] = iteratee(array[index], index, array);
                }
                return result;
            }

            module.exports = arrayMap;

            /***/
        },
        /* 77 */
        /***/function (module, exports) {

            /**
             * Appends the elements of `values` to `array`.
             *
             * @private
             * @param {Array} array The array to modify.
             * @param {Array} values The values to append.
             * @returns {Array} Returns `array`.
             */
            function arrayPush(array, values) {
                var index = -1,
                    length = values.length,
                    offset = array.length;

                while (++index < length) {
                    array[offset + index] = values[index];
                }
                return array;
            }

            module.exports = arrayPush;

            /***/
        },
        /* 78 */
        /***/function (module, exports) {

            /**
             * A specialized version of `_.some` for arrays without support for iteratee
             * shorthands.
             *
             * @private
             * @param {Array} [array] The array to iterate over.
             * @param {Function} predicate The function invoked per iteration.
             * @returns {boolean} Returns `true` if any element passes the predicate check,
             *  else `false`.
             */
            function arraySome(array, predicate) {
                var index = -1,
                    length = array ? array.length : 0;

                while (++index < length) {
                    if (predicate(array[index], index, array)) {
                        return true;
                    }
                }
                return false;
            }

            module.exports = arraySome;

            /***/
        },
        /* 79 */
        /***/function (module, exports) {

            /** Built-in value references. */
            var defineProperty = Object.defineProperty;

            /**
             * The base implementation of `assignValue` and `assignMergeValue` without
             * value checks.
             *
             * @private
             * @param {Object} object The object to modify.
             * @param {string} key The key of the property to assign.
             * @param {*} value The value to assign.
             */
            function baseAssignValue(object, key, value) {
                if (key == '__proto__' && defineProperty) {
                    defineProperty(object, key, {
                        'configurable': true,
                        'enumerable': true,
                        'value': value,
                        'writable': true
                    });
                } else {
                    object[key] = value;
                }
            }

            module.exports = baseAssignValue;

            /***/
        },
        /* 80 */
        /***/function (module, exports, __webpack_require__) {

            var SetCache = __webpack_require__(15),
                arrayIncludes = __webpack_require__(30),
                arrayIncludesWith = __webpack_require__(31),
                arrayMap = __webpack_require__(76),
                baseUnary = __webpack_require__(36),
                cacheHas = __webpack_require__(17);

            /** Used as the size to enable large array optimizations. */
            var LARGE_ARRAY_SIZE = 200;

            /**
             * The base implementation of methods like `_.difference` without support
             * for excluding multiple arrays or iteratee shorthands.
             *
             * @private
             * @param {Array} array The array to inspect.
             * @param {Array} values The values to exclude.
             * @param {Function} [iteratee] The iteratee invoked per element.
             * @param {Function} [comparator] The comparator invoked per element.
             * @returns {Array} Returns the new array of filtered values.
             */
            function baseDifference(array, values, iteratee, comparator) {
                var index = -1,
                    includes = arrayIncludes,
                    isCommon = true,
                    length = array.length,
                    result = [],
                    valuesLength = values.length;

                if (!length) {
                    return result;
                }
                if (iteratee) {
                    values = arrayMap(values, baseUnary(iteratee));
                }
                if (comparator) {
                    includes = arrayIncludesWith;
                    isCommon = false;
                } else if (values.length >= LARGE_ARRAY_SIZE) {
                    includes = cacheHas;
                    isCommon = false;
                    values = new SetCache(values);
                }
                outer: while (++index < length) {
                    var value = array[index],
                        computed = iteratee ? iteratee(value) : value;

                    value = comparator || value !== 0 ? value : 0;
                    if (isCommon && computed === computed) {
                        var valuesIndex = valuesLength;
                        while (valuesIndex--) {
                            if (values[valuesIndex] === computed) {
                                continue outer;
                            }
                        }
                        result.push(value);
                    } else if (!includes(values, computed, comparator)) {
                        result.push(value);
                    }
                }
                return result;
            }

            module.exports = baseDifference;

            /***/
        },
        /* 81 */
        /***/function (module, exports) {

            /**
             * The base implementation of `_.findIndex` and `_.findLastIndex` without
             * support for iteratee shorthands.
             *
             * @private
             * @param {Array} array The array to inspect.
             * @param {Function} predicate The function invoked per iteration.
             * @param {number} fromIndex The index to search from.
             * @param {boolean} [fromRight] Specify iterating from right to left.
             * @returns {number} Returns the index of the matched value, else `-1`.
             */
            function baseFindIndex(array, predicate, fromIndex, fromRight) {
                var length = array.length,
                    index = fromIndex + (fromRight ? 1 : -1);

                while (fromRight ? index-- : ++index < length) {
                    if (predicate(array[index], index, array)) {
                        return index;
                    }
                }
                return -1;
            }

            module.exports = baseFindIndex;

            /***/
        },
        /* 82 */
        /***/function (module, exports, __webpack_require__) {

            var createBaseFor = __webpack_require__(103);

            /**
             * The base implementation of `baseForOwn` which iterates over `object`
             * properties returned by `keysFunc` and invokes `iteratee` for each property.
             * Iteratee functions may exit iteration early by explicitly returning `false`.
             *
             * @private
             * @param {Object} object The object to iterate over.
             * @param {Function} iteratee The function invoked per iteration.
             * @param {Function} keysFunc The function to get the keys of `object`.
             * @returns {Object} Returns `object`.
             */
            var baseFor = createBaseFor();

            module.exports = baseFor;

            /***/
        },
        /* 83 */
        /***/function (module, exports, __webpack_require__) {

            var baseFor = __webpack_require__(82),
                keys = __webpack_require__(24);

            /**
             * The base implementation of `_.forOwn` without support for iteratee shorthands.
             *
             * @private
             * @param {Object} object The object to iterate over.
             * @param {Function} iteratee The function invoked per iteration.
             * @returns {Object} Returns `object`.
             */
            function baseForOwn(object, iteratee) {
                return object && baseFor(object, iteratee, keys);
            }

            module.exports = baseForOwn;

            /***/
        },
        /* 84 */
        /***/function (module, exports) {

            /** Used for built-in method references. */
            var objectProto = Object.prototype;

            /**
             * Used to resolve the
             * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
             * of values.
             */
            var objectToString = objectProto.toString;

            /**
             * The base implementation of `getTag`.
             *
             * @private
             * @param {*} value The value to query.
             * @returns {string} Returns the `toStringTag`.
             */
            function baseGetTag(value) {
                return objectToString.call(value);
            }

            module.exports = baseGetTag;

            /***/
        },
        /* 85 */
        /***/function (module, exports) {

            /**
             * The base implementation of `_.hasIn` without support for deep paths.
             *
             * @private
             * @param {Object} [object] The object to query.
             * @param {Array|string} key The key to check.
             * @returns {boolean} Returns `true` if `key` exists, else `false`.
             */
            function baseHasIn(object, key) {
                return object != null && key in Object(object);
            }

            module.exports = baseHasIn;

            /***/
        },
        /* 86 */
        /***/function (module, exports, __webpack_require__) {

            var baseFindIndex = __webpack_require__(81),
                baseIsNaN = __webpack_require__(89),
                strictIndexOf = __webpack_require__(146);

            /**
             * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
             *
             * @private
             * @param {Array} array The array to inspect.
             * @param {*} value The value to search for.
             * @param {number} fromIndex The index to search from.
             * @returns {number} Returns the index of the matched value, else `-1`.
             */
            function baseIndexOf(array, value, fromIndex) {
                return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
            }

            module.exports = baseIndexOf;

            /***/
        },
        /* 87 */
        /***/function (module, exports, __webpack_require__) {

            var Stack = __webpack_require__(29),
                equalArrays = __webpack_require__(38),
                equalByTag = __webpack_require__(105),
                equalObjects = __webpack_require__(106),
                getTag = __webpack_require__(109),
                isArray = __webpack_require__(3),
                isTypedArray = __webpack_require__(153);

            /** Used to compose bitmasks for comparison styles. */
            var PARTIAL_COMPARE_FLAG = 2;

            /** `Object#toString` result references. */
            var argsTag = '[object Arguments]',
                arrayTag = '[object Array]',
                objectTag = '[object Object]';

            /** Used for built-in method references. */
            var objectProto = Object.prototype;

            /** Used to check objects for own properties. */
            var hasOwnProperty = objectProto.hasOwnProperty;

            /**
             * A specialized version of `baseIsEqual` for arrays and objects which performs
             * deep comparisons and tracks traversed objects enabling objects with circular
             * references to be compared.
             *
             * @private
             * @param {Object} object The object to compare.
             * @param {Object} other The other object to compare.
             * @param {Function} equalFunc The function to determine equivalents of values.
             * @param {Function} [customizer] The function to customize comparisons.
             * @param {number} [bitmask] The bitmask of comparison flags. See `baseIsEqual`
             *  for more details.
             * @param {Object} [stack] Tracks traversed `object` and `other` objects.
             * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
             */
            function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
                var objIsArr = isArray(object),
                    othIsArr = isArray(other),
                    objTag = arrayTag,
                    othTag = arrayTag;

                if (!objIsArr) {
                    objTag = getTag(object);
                    objTag = objTag == argsTag ? objectTag : objTag;
                }
                if (!othIsArr) {
                    othTag = getTag(other);
                    othTag = othTag == argsTag ? objectTag : othTag;
                }
                var objIsObj = objTag == objectTag,
                    othIsObj = othTag == objectTag,
                    isSameTag = objTag == othTag;

                if (isSameTag && !objIsObj) {
                    stack || (stack = new Stack());
                    return objIsArr || isTypedArray(object) ? equalArrays(object, other, equalFunc, customizer, bitmask, stack) : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
                }
                if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
                    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
                        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

                    if (objIsWrapped || othIsWrapped) {
                        var objUnwrapped = objIsWrapped ? object.value() : object,
                            othUnwrapped = othIsWrapped ? other.value() : other;

                        stack || (stack = new Stack());
                        return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
                    }
                }
                if (!isSameTag) {
                    return false;
                }
                stack || (stack = new Stack());
                return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
            }

            module.exports = baseIsEqualDeep;

            /***/
        },
        /* 88 */
        /***/function (module, exports, __webpack_require__) {

            var Stack = __webpack_require__(29),
                baseIsEqual = __webpack_require__(34);

            /** Used to compose bitmasks for comparison styles. */
            var UNORDERED_COMPARE_FLAG = 1,
                PARTIAL_COMPARE_FLAG = 2;

            /**
             * The base implementation of `_.isMatch` without support for iteratee shorthands.
             *
             * @private
             * @param {Object} object The object to inspect.
             * @param {Object} source The object of property values to match.
             * @param {Array} matchData The property names, values, and compare flags to match.
             * @param {Function} [customizer] The function to customize comparisons.
             * @returns {boolean} Returns `true` if `object` is a match, else `false`.
             */
            function baseIsMatch(object, source, matchData, customizer) {
                var index = matchData.length,
                    length = index,
                    noCustomizer = !customizer;

                if (object == null) {
                    return !length;
                }
                object = Object(object);
                while (index--) {
                    var data = matchData[index];
                    if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
                        return false;
                    }
                }
                while (++index < length) {
                    data = matchData[index];
                    var key = data[0],
                        objValue = object[key],
                        srcValue = data[1];

                    if (noCustomizer && data[2]) {
                        if (objValue === undefined && !(key in object)) {
                            return false;
                        }
                    } else {
                        var stack = new Stack();
                        if (customizer) {
                            var result = customizer(objValue, srcValue, key, object, source, stack);
                        }
                        if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack) : result)) {
                            return false;
                        }
                    }
                }
                return true;
            }

            module.exports = baseIsMatch;

            /***/
        },
        /* 89 */
        /***/function (module, exports) {

            /**
             * The base implementation of `_.isNaN` without support for number objects.
             *
             * @private
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
             */
            function baseIsNaN(value) {
                return value !== value;
            }

            module.exports = baseIsNaN;

            /***/
        },
        /* 90 */
        /***/function (module, exports, __webpack_require__) {

            var isFunction = __webpack_require__(47),
                isMasked = __webpack_require__(119),
                isObject = __webpack_require__(11),
                toSource = __webpack_require__(44);

            /**
             * Used to match `RegExp`
             * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
             */
            var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

            /** Used to detect host constructors (Safari). */
            var reIsHostCtor = /^\[object .+?Constructor\]$/;

            /** Used for built-in method references. */
            var funcProto = Function.prototype,
                objectProto = Object.prototype;

            /** Used to resolve the decompiled source of functions. */
            var funcToString = funcProto.toString;

            /** Used to check objects for own properties. */
            var hasOwnProperty = objectProto.hasOwnProperty;

            /** Used to detect if a method is native. */
            var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');

            /**
             * The base implementation of `_.isNative` without bad shim checks.
             *
             * @private
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is a native function,
             *  else `false`.
             */
            function baseIsNative(value) {
                if (!isObject(value) || isMasked(value)) {
                    return false;
                }
                var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
                return pattern.test(toSource(value));
            }

            module.exports = baseIsNative;

            /***/
        },
        /* 91 */
        /***/function (module, exports, __webpack_require__) {

            var isLength = __webpack_require__(22),
                isObjectLike = __webpack_require__(4);

            /** `Object#toString` result references. */
            var argsTag = '[object Arguments]',
                arrayTag = '[object Array]',
                boolTag = '[object Boolean]',
                dateTag = '[object Date]',
                errorTag = '[object Error]',
                funcTag = '[object Function]',
                mapTag = '[object Map]',
                numberTag = '[object Number]',
                objectTag = '[object Object]',
                regexpTag = '[object RegExp]',
                setTag = '[object Set]',
                stringTag = '[object String]',
                weakMapTag = '[object WeakMap]';

            var arrayBufferTag = '[object ArrayBuffer]',
                dataViewTag = '[object DataView]',
                float32Tag = '[object Float32Array]',
                float64Tag = '[object Float64Array]',
                int8Tag = '[object Int8Array]',
                int16Tag = '[object Int16Array]',
                int32Tag = '[object Int32Array]',
                uint8Tag = '[object Uint8Array]',
                uint8ClampedTag = '[object Uint8ClampedArray]',
                uint16Tag = '[object Uint16Array]',
                uint32Tag = '[object Uint32Array]';

            /** Used to identify `toStringTag` values of typed arrays. */
            var typedArrayTags = {};
            typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
            typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;

            /** Used for built-in method references. */
            var objectProto = Object.prototype;

            /**
             * Used to resolve the
             * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
             * of values.
             */
            var objectToString = objectProto.toString;

            /**
             * The base implementation of `_.isTypedArray` without Node.js optimizations.
             *
             * @private
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
             */
            function baseIsTypedArray(value) {
                return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
            }

            module.exports = baseIsTypedArray;

            /***/
        },
        /* 92 */
        /***/function (module, exports, __webpack_require__) {

            var baseMatches = __webpack_require__(94),
                baseMatchesProperty = __webpack_require__(95),
                identity = __webpack_require__(19),
                isArray = __webpack_require__(3),
                property = __webpack_require__(157);

            /**
             * The base implementation of `_.iteratee`.
             *
             * @private
             * @param {*} [value=_.identity] The value to convert to an iteratee.
             * @returns {Function} Returns the iteratee.
             */
            function baseIteratee(value) {
                // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
                // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
                if (typeof value == 'function') {
                    return value;
                }
                if (value == null) {
                    return identity;
                }
                if ((typeof value === 'undefined' ? 'undefined' : _typeof2(value)) == 'object') {
                    return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
                }
                return property(value);
            }

            module.exports = baseIteratee;

            /***/
        },
        /* 93 */
        /***/function (module, exports, __webpack_require__) {

            var isPrototype = __webpack_require__(120),
                nativeKeys = __webpack_require__(134);

            /** Used for built-in method references. */
            var objectProto = Object.prototype;

            /** Used to check objects for own properties. */
            var hasOwnProperty = objectProto.hasOwnProperty;

            /**
             * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
             *
             * @private
             * @param {Object} object The object to query.
             * @returns {Array} Returns the array of property names.
             */
            function baseKeys(object) {
                if (!isPrototype(object)) {
                    return nativeKeys(object);
                }
                var result = [];
                for (var key in Object(object)) {
                    if (hasOwnProperty.call(object, key) && key != 'constructor') {
                        result.push(key);
                    }
                }
                return result;
            }

            module.exports = baseKeys;

            /***/
        },
        /* 94 */
        /***/function (module, exports, __webpack_require__) {

            var baseIsMatch = __webpack_require__(88),
                getMatchData = __webpack_require__(107),
                matchesStrictComparable = __webpack_require__(42);

            /**
             * The base implementation of `_.matches` which doesn't clone `source`.
             *
             * @private
             * @param {Object} source The object of property values to match.
             * @returns {Function} Returns the new spec function.
             */
            function baseMatches(source) {
                var matchData = getMatchData(source);
                if (matchData.length == 1 && matchData[0][2]) {
                    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
                }
                return function (object) {
                    return object === source || baseIsMatch(object, source, matchData);
                };
            }

            module.exports = baseMatches;

            /***/
        },
        /* 95 */
        /***/function (module, exports, __webpack_require__) {

            var baseIsEqual = __webpack_require__(34),
                get = __webpack_require__(150),
                hasIn = __webpack_require__(151),
                isKey = __webpack_require__(8),
                isStrictComparable = __webpack_require__(41),
                matchesStrictComparable = __webpack_require__(42),
                toKey = __webpack_require__(10);

            /** Used to compose bitmasks for comparison styles. */
            var UNORDERED_COMPARE_FLAG = 1,
                PARTIAL_COMPARE_FLAG = 2;

            /**
             * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
             *
             * @private
             * @param {string} path The path of the property to get.
             * @param {*} srcValue The value to match.
             * @returns {Function} Returns the new spec function.
             */
            function baseMatchesProperty(path, srcValue) {
                if (isKey(path) && isStrictComparable(srcValue)) {
                    return matchesStrictComparable(toKey(path), srcValue);
                }
                return function (object) {
                    var objValue = get(object, path);
                    return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, undefined, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);
                };
            }

            module.exports = baseMatchesProperty;

            /***/
        },
        /* 96 */
        /***/function (module, exports) {

            /**
             * The base implementation of `_.property` without support for deep paths.
             *
             * @private
             * @param {string} key The key of the property to get.
             * @returns {Function} Returns the new accessor function.
             */
            function baseProperty(key) {
                return function (object) {
                    return object == null ? undefined : object[key];
                };
            }

            module.exports = baseProperty;

            /***/
        },
        /* 97 */
        /***/function (module, exports, __webpack_require__) {

            var baseGet = __webpack_require__(33);

            /**
             * A specialized version of `baseProperty` which supports deep paths.
             *
             * @private
             * @param {Array|string} path The path of the property to get.
             * @returns {Function} Returns the new accessor function.
             */
            function basePropertyDeep(path) {
                return function (object) {
                    return baseGet(object, path);
                };
            }

            module.exports = basePropertyDeep;

            /***/
        },
        /* 98 */
        /***/function (module, exports, __webpack_require__) {

            var constant = __webpack_require__(148),
                identity = __webpack_require__(19),
                nativeDefineProperty = __webpack_require__(133);

            /**
             * The base implementation of `setToString` without support for hot loop shorting.
             *
             * @private
             * @param {Function} func The function to modify.
             * @param {Function} string The `toString` result.
             * @returns {Function} Returns `func`.
             */
            var baseSetToString = !nativeDefineProperty ? identity : function (func, string) {
                return nativeDefineProperty(func, 'toString', {
                    'configurable': true,
                    'enumerable': false,
                    'value': constant(string),
                    'writable': true
                });
            };

            module.exports = baseSetToString;

            /***/
        },
        /* 99 */
        /***/function (module, exports) {

            /**
             * The base implementation of `_.times` without support for iteratee shorthands
             * or max array length checks.
             *
             * @private
             * @param {number} n The number of times to invoke `iteratee`.
             * @param {Function} iteratee The function invoked per iteration.
             * @returns {Array} Returns the array of results.
             */
            function baseTimes(n, iteratee) {
                var index = -1,
                    result = Array(n);

                while (++index < n) {
                    result[index] = iteratee(index);
                }
                return result;
            }

            module.exports = baseTimes;

            /***/
        },
        /* 100 */
        /***/function (module, exports, __webpack_require__) {

            var _Symbol2 = __webpack_require__(16),
                isSymbol = __webpack_require__(23);

            /** Used as references for various `Number` constants. */
            var INFINITY = 1 / 0;

            /** Used to convert symbols to primitives and strings. */
            var symbolProto = _Symbol2 ? _Symbol2.prototype : undefined,
                symbolToString = symbolProto ? symbolProto.toString : undefined;

            /**
             * The base implementation of `_.toString` which doesn't convert nullish
             * values to empty strings.
             *
             * @private
             * @param {*} value The value to process.
             * @returns {string} Returns the string.
             */
            function baseToString(value) {
                // Exit early for strings to avoid a performance hit in some environments.
                if (typeof value == 'string') {
                    return value;
                }
                if (isSymbol(value)) {
                    return symbolToString ? symbolToString.call(value) : '';
                }
                var result = value + '';
                return result == '0' && 1 / value == -INFINITY ? '-0' : result;
            }

            module.exports = baseToString;

            /***/
        },
        /* 101 */
        /***/function (module, exports, __webpack_require__) {

            var SetCache = __webpack_require__(15),
                arrayIncludes = __webpack_require__(30),
                arrayIncludesWith = __webpack_require__(31),
                cacheHas = __webpack_require__(17),
                createSet = __webpack_require__(104),
                setToArray = __webpack_require__(18);

            /** Used as the size to enable large array optimizations. */
            var LARGE_ARRAY_SIZE = 200;

            /**
             * The base implementation of `_.uniqBy` without support for iteratee shorthands.
             *
             * @private
             * @param {Array} array The array to inspect.
             * @param {Function} [iteratee] The iteratee invoked per element.
             * @param {Function} [comparator] The comparator invoked per element.
             * @returns {Array} Returns the new duplicate free array.
             */
            function baseUniq(array, iteratee, comparator) {
                var index = -1,
                    includes = arrayIncludes,
                    length = array.length,
                    isCommon = true,
                    result = [],
                    seen = result;

                if (comparator) {
                    isCommon = false;
                    includes = arrayIncludesWith;
                } else if (length >= LARGE_ARRAY_SIZE) {
                    var set = iteratee ? null : createSet(array);
                    if (set) {
                        return setToArray(set);
                    }
                    isCommon = false;
                    includes = cacheHas;
                    seen = new SetCache();
                } else {
                    seen = iteratee ? [] : result;
                }
                outer: while (++index < length) {
                    var value = array[index],
                        computed = iteratee ? iteratee(value) : value;

                    value = comparator || value !== 0 ? value : 0;
                    if (isCommon && computed === computed) {
                        var seenIndex = seen.length;
                        while (seenIndex--) {
                            if (seen[seenIndex] === computed) {
                                continue outer;
                            }
                        }
                        if (iteratee) {
                            seen.push(computed);
                        }
                        result.push(value);
                    } else if (!includes(seen, computed, comparator)) {
                        if (seen !== result) {
                            seen.push(computed);
                        }
                        result.push(value);
                    }
                }
                return result;
            }

            module.exports = baseUniq;

            /***/
        },
        /* 102 */
        /***/function (module, exports, __webpack_require__) {

            var root = __webpack_require__(1);

            /** Used to detect overreaching core-js shims. */
            var coreJsData = root['__core-js_shared__'];

            module.exports = coreJsData;

            /***/
        },
        /* 103 */
        /***/function (module, exports) {

            /**
             * Creates a base function for methods like `_.forIn` and `_.forOwn`.
             *
             * @private
             * @param {boolean} [fromRight] Specify iterating from right to left.
             * @returns {Function} Returns the new base function.
             */
            function createBaseFor(fromRight) {
                return function (object, iteratee, keysFunc) {
                    var index = -1,
                        iterable = Object(object),
                        props = keysFunc(object),
                        length = props.length;

                    while (length--) {
                        var key = props[fromRight ? length : ++index];
                        if (iteratee(iterable[key], key, iterable) === false) {
                            break;
                        }
                    }
                    return object;
                };
            }

            module.exports = createBaseFor;

            /***/
        },
        /* 104 */
        /***/function (module, exports, __webpack_require__) {

            var Set = __webpack_require__(28),
                noop = __webpack_require__(156),
                setToArray = __webpack_require__(18);

            /** Used as references for various `Number` constants. */
            var INFINITY = 1 / 0;

            /**
             * Creates a set object of `values`.
             *
             * @private
             * @param {Array} values The values to add to the set.
             * @returns {Object} Returns the new set.
             */
            var createSet = !(Set && 1 / setToArray(new Set([, -0]))[1] == INFINITY) ? noop : function (values) {
                return new Set(values);
            };

            module.exports = createSet;

            /***/
        },
        /* 105 */
        /***/function (module, exports, __webpack_require__) {

            var _Symbol3 = __webpack_require__(16),
                Uint8Array = __webpack_require__(72),
                eq = __webpack_require__(45),
                equalArrays = __webpack_require__(38),
                mapToArray = __webpack_require__(131),
                setToArray = __webpack_require__(18);

            /** Used to compose bitmasks for comparison styles. */
            var UNORDERED_COMPARE_FLAG = 1,
                PARTIAL_COMPARE_FLAG = 2;

            /** `Object#toString` result references. */
            var boolTag = '[object Boolean]',
                dateTag = '[object Date]',
                errorTag = '[object Error]',
                mapTag = '[object Map]',
                numberTag = '[object Number]',
                regexpTag = '[object RegExp]',
                setTag = '[object Set]',
                stringTag = '[object String]',
                symbolTag = '[object Symbol]';

            var arrayBufferTag = '[object ArrayBuffer]',
                dataViewTag = '[object DataView]';

            /** Used to convert symbols to primitives and strings. */
            var symbolProto = _Symbol3 ? _Symbol3.prototype : undefined,
                symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

            /**
             * A specialized version of `baseIsEqualDeep` for comparing objects of
             * the same `toStringTag`.
             *
             * **Note:** This function only supports comparing values with tags of
             * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
             *
             * @private
             * @param {Object} object The object to compare.
             * @param {Object} other The other object to compare.
             * @param {string} tag The `toStringTag` of the objects to compare.
             * @param {Function} equalFunc The function to determine equivalents of values.
             * @param {Function} customizer The function to customize comparisons.
             * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
             *  for more details.
             * @param {Object} stack Tracks traversed `object` and `other` objects.
             * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
             */
            function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
                switch (tag) {
                    case dataViewTag:
                        if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                            return false;
                        }
                        object = object.buffer;
                        other = other.buffer;

                    case arrayBufferTag:
                        if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
                            return false;
                        }
                        return true;

                    case boolTag:
                    case dateTag:
                    case numberTag:
                        // Coerce booleans to `1` or `0` and dates to milliseconds.
                        // Invalid dates are coerced to `NaN`.
                        return eq(+object, +other);

                    case errorTag:
                        return object.name == other.name && object.message == other.message;

                    case regexpTag:
                    case stringTag:
                        // Coerce regexes to strings and treat strings, primitives and objects,
                        // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
                        // for more details.
                        return object == other + '';

                    case mapTag:
                        var convert = mapToArray;

                    case setTag:
                        var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
                        convert || (convert = setToArray);

                        if (object.size != other.size && !isPartial) {
                            return false;
                        }
                        // Assume cyclic values are equal.
                        var stacked = stack.get(object);
                        if (stacked) {
                            return stacked == other;
                        }
                        bitmask |= UNORDERED_COMPARE_FLAG;

                        // Recursively compare objects (susceptible to call stack limits).
                        stack.set(object, other);
                        var result = equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);
                        stack['delete'](object);
                        return result;

                    case symbolTag:
                        if (symbolValueOf) {
                            return symbolValueOf.call(object) == symbolValueOf.call(other);
                        }
                }
                return false;
            }

            module.exports = equalByTag;

            /***/
        },
        /* 106 */
        /***/function (module, exports, __webpack_require__) {

            var keys = __webpack_require__(24);

            /** Used to compose bitmasks for comparison styles. */
            var PARTIAL_COMPARE_FLAG = 2;

            /** Used for built-in method references. */
            var objectProto = Object.prototype;

            /** Used to check objects for own properties. */
            var hasOwnProperty = objectProto.hasOwnProperty;

            /**
             * A specialized version of `baseIsEqualDeep` for objects with support for
             * partial deep comparisons.
             *
             * @private
             * @param {Object} object The object to compare.
             * @param {Object} other The other object to compare.
             * @param {Function} equalFunc The function to determine equivalents of values.
             * @param {Function} customizer The function to customize comparisons.
             * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
             *  for more details.
             * @param {Object} stack Tracks traversed `object` and `other` objects.
             * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
             */
            function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
                var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
                    objProps = keys(object),
                    objLength = objProps.length,
                    othProps = keys(other),
                    othLength = othProps.length;

                if (objLength != othLength && !isPartial) {
                    return false;
                }
                var index = objLength;
                while (index--) {
                    var key = objProps[index];
                    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
                        return false;
                    }
                }
                // Assume cyclic values are equal.
                var stacked = stack.get(object);
                if (stacked && stack.get(other)) {
                    return stacked == other;
                }
                var result = true;
                stack.set(object, other);
                stack.set(other, object);

                var skipCtor = isPartial;
                while (++index < objLength) {
                    key = objProps[index];
                    var objValue = object[key],
                        othValue = other[key];

                    if (customizer) {
                        var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
                    }
                    // Recursively compare objects (susceptible to call stack limits).
                    if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack) : compared)) {
                        result = false;
                        break;
                    }
                    skipCtor || (skipCtor = key == 'constructor');
                }
                if (result && !skipCtor) {
                    var objCtor = object.constructor,
                        othCtor = other.constructor;

                    // Non `Object` object instances with different constructors are not equal.
                    if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
                        result = false;
                    }
                }
                stack['delete'](object);
                stack['delete'](other);
                return result;
            }

            module.exports = equalObjects;

            /***/
        },
        /* 107 */
        /***/function (module, exports, __webpack_require__) {

            var isStrictComparable = __webpack_require__(41),
                keys = __webpack_require__(24);

            /**
             * Gets the property names, values, and compare flags of `object`.
             *
             * @private
             * @param {Object} object The object to query.
             * @returns {Array} Returns the match data of `object`.
             */
            function getMatchData(object) {
                var result = keys(object),
                    length = result.length;

                while (length--) {
                    var key = result[length],
                        value = object[key];

                    result[length] = [key, value, isStrictComparable(value)];
                }
                return result;
            }

            module.exports = getMatchData;

            /***/
        },
        /* 108 */
        /***/function (module, exports, __webpack_require__) {

            var overArg = __webpack_require__(43);

            /** Built-in value references. */
            var getPrototype = overArg(Object.getPrototypeOf, Object);

            module.exports = getPrototype;

            /***/
        },
        /* 109 */
        /***/function (module, exports, __webpack_require__) {

            var DataView = __webpack_require__(69),
                Map = __webpack_require__(13),
                Promise = __webpack_require__(71),
                Set = __webpack_require__(28),
                WeakMap = __webpack_require__(73),
                baseGetTag = __webpack_require__(84),
                toSource = __webpack_require__(44);

            /** `Object#toString` result references. */
            var mapTag = '[object Map]',
                objectTag = '[object Object]',
                promiseTag = '[object Promise]',
                setTag = '[object Set]',
                weakMapTag = '[object WeakMap]';

            var dataViewTag = '[object DataView]';

            /** Used for built-in method references. */
            var objectProto = Object.prototype;

            /**
             * Used to resolve the
             * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
             * of values.
             */
            var objectToString = objectProto.toString;

            /** Used to detect maps, sets, and weakmaps. */
            var dataViewCtorString = toSource(DataView),
                mapCtorString = toSource(Map),
                promiseCtorString = toSource(Promise),
                setCtorString = toSource(Set),
                weakMapCtorString = toSource(WeakMap);

            /**
             * Gets the `toStringTag` of `value`.
             *
             * @private
             * @param {*} value The value to query.
             * @returns {string} Returns the `toStringTag`.
             */
            var getTag = baseGetTag;

            // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
            if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
                getTag = function getTag(value) {
                    var result = objectToString.call(value),
                        Ctor = result == objectTag ? value.constructor : undefined,
                        ctorString = Ctor ? toSource(Ctor) : undefined;

                    if (ctorString) {
                        switch (ctorString) {
                            case dataViewCtorString:
                                return dataViewTag;
                            case mapCtorString:
                                return mapTag;
                            case promiseCtorString:
                                return promiseTag;
                            case setCtorString:
                                return setTag;
                            case weakMapCtorString:
                                return weakMapTag;
                        }
                    }
                    return result;
                };
            }

            module.exports = getTag;

            /***/
        },
        /* 110 */
        /***/function (module, exports) {

            /**
             * Gets the value at `key` of `object`.
             *
             * @private
             * @param {Object} [object] The object to query.
             * @param {string} key The key of the property to get.
             * @returns {*} Returns the property value.
             */
            function getValue(object, key) {
                return object == null ? undefined : object[key];
            }

            module.exports = getValue;

            /***/
        },
        /* 111 */
        /***/function (module, exports, __webpack_require__) {

            var castPath = __webpack_require__(37),
                isArguments = __webpack_require__(20),
                isArray = __webpack_require__(3),
                isIndex = __webpack_require__(40),
                isKey = __webpack_require__(8),
                isLength = __webpack_require__(22),
                toKey = __webpack_require__(10);

            /**
             * Checks if `path` exists on `object`.
             *
             * @private
             * @param {Object} object The object to query.
             * @param {Array|string} path The path to check.
             * @param {Function} hasFunc The function to check properties.
             * @returns {boolean} Returns `true` if `path` exists, else `false`.
             */
            function hasPath(object, path, hasFunc) {
                path = isKey(path, object) ? [path] : castPath(path);

                var index = -1,
                    length = path.length,
                    result = false;

                while (++index < length) {
                    var key = toKey(path[index]);
                    if (!(result = object != null && hasFunc(object, key))) {
                        break;
                    }
                    object = object[key];
                }
                if (result || ++index != length) {
                    return result;
                }
                length = object ? object.length : 0;
                return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
            }

            module.exports = hasPath;

            /***/
        },
        /* 112 */
        /***/function (module, exports, __webpack_require__) {

            var nativeCreate = __webpack_require__(9);

            /**
             * Removes all key-value entries from the hash.
             *
             * @private
             * @name clear
             * @memberOf Hash
             */
            function hashClear() {
                this.__data__ = nativeCreate ? nativeCreate(null) : {};
                this.size = 0;
            }

            module.exports = hashClear;

            /***/
        },
        /* 113 */
        /***/function (module, exports) {

            /**
             * Removes `key` and its value from the hash.
             *
             * @private
             * @name delete
             * @memberOf Hash
             * @param {Object} hash The hash to modify.
             * @param {string} key The key of the value to remove.
             * @returns {boolean} Returns `true` if the entry was removed, else `false`.
             */
            function hashDelete(key) {
                var result = this.has(key) && delete this.__data__[key];
                this.size -= result ? 1 : 0;
                return result;
            }

            module.exports = hashDelete;

            /***/
        },
        /* 114 */
        /***/function (module, exports, __webpack_require__) {

            var nativeCreate = __webpack_require__(9);

            /** Used to stand-in for `undefined` hash values. */
            var HASH_UNDEFINED = '__lodash_hash_undefined__';

            /** Used for built-in method references. */
            var objectProto = Object.prototype;

            /** Used to check objects for own properties. */
            var hasOwnProperty = objectProto.hasOwnProperty;

            /**
             * Gets the hash value for `key`.
             *
             * @private
             * @name get
             * @memberOf Hash
             * @param {string} key The key of the value to get.
             * @returns {*} Returns the entry value.
             */
            function hashGet(key) {
                var data = this.__data__;
                if (nativeCreate) {
                    var result = data[key];
                    return result === HASH_UNDEFINED ? undefined : result;
                }
                return hasOwnProperty.call(data, key) ? data[key] : undefined;
            }

            module.exports = hashGet;

            /***/
        },
        /* 115 */
        /***/function (module, exports, __webpack_require__) {

            var nativeCreate = __webpack_require__(9);

            /** Used for built-in method references. */
            var objectProto = Object.prototype;

            /** Used to check objects for own properties. */
            var hasOwnProperty = objectProto.hasOwnProperty;

            /**
             * Checks if a hash value for `key` exists.
             *
             * @private
             * @name has
             * @memberOf Hash
             * @param {string} key The key of the entry to check.
             * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
             */
            function hashHas(key) {
                var data = this.__data__;
                return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
            }

            module.exports = hashHas;

            /***/
        },
        /* 116 */
        /***/function (module, exports, __webpack_require__) {

            var nativeCreate = __webpack_require__(9);

            /** Used to stand-in for `undefined` hash values. */
            var HASH_UNDEFINED = '__lodash_hash_undefined__';

            /**
             * Sets the hash `key` to `value`.
             *
             * @private
             * @name set
             * @memberOf Hash
             * @param {string} key The key of the value to set.
             * @param {*} value The value to set.
             * @returns {Object} Returns the hash instance.
             */
            function hashSet(key, value) {
                var data = this.__data__;
                this.size += this.has(key) ? 0 : 1;
                data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
                return this;
            }

            module.exports = hashSet;

            /***/
        },
        /* 117 */
        /***/function (module, exports, __webpack_require__) {

            var _Symbol4 = __webpack_require__(16),
                isArguments = __webpack_require__(20),
                isArray = __webpack_require__(3);

            /** Built-in value references. */
            var spreadableSymbol = _Symbol4 ? _Symbol4.isConcatSpreadable : undefined;

            /**
             * Checks if `value` is a flattenable `arguments` object or array.
             *
             * @private
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
             */
            function isFlattenable(value) {
                return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
            }

            module.exports = isFlattenable;

            /***/
        },
        /* 118 */
        /***/function (module, exports) {

            /**
             * Checks if `value` is suitable for use as unique object key.
             *
             * @private
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
             */
            function isKeyable(value) {
                var type = typeof value === 'undefined' ? 'undefined' : _typeof2(value);
                return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
            }

            module.exports = isKeyable;

            /***/
        },
        /* 119 */
        /***/function (module, exports, __webpack_require__) {

            var coreJsData = __webpack_require__(102);

            /** Used to detect methods masquerading as native. */
            var maskSrcKey = function () {
                var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
                return uid ? 'Symbol(src)_1.' + uid : '';
            }();

            /**
             * Checks if `func` has its source masked.
             *
             * @private
             * @param {Function} func The function to check.
             * @returns {boolean} Returns `true` if `func` is masked, else `false`.
             */
            function isMasked(func) {
                return !!maskSrcKey && maskSrcKey in func;
            }

            module.exports = isMasked;

            /***/
        },
        /* 120 */
        /***/function (module, exports) {

            /** Used for built-in method references. */
            var objectProto = Object.prototype;

            /**
             * Checks if `value` is likely a prototype object.
             *
             * @private
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
             */
            function isPrototype(value) {
                var Ctor = value && value.constructor,
                    proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;

                return value === proto;
            }

            module.exports = isPrototype;

            /***/
        },
        /* 121 */
        /***/function (module, exports) {

            /**
             * Removes all key-value entries from the list cache.
             *
             * @private
             * @name clear
             * @memberOf ListCache
             */
            function listCacheClear() {
                this.__data__ = [];
                this.size = 0;
            }

            module.exports = listCacheClear;

            /***/
        },
        /* 122 */
        /***/function (module, exports, __webpack_require__) {

            var assocIndexOf = __webpack_require__(6);

            /** Used for built-in method references. */
            var arrayProto = Array.prototype;

            /** Built-in value references. */
            var splice = arrayProto.splice;

            /**
             * Removes `key` and its value from the list cache.
             *
             * @private
             * @name delete
             * @memberOf ListCache
             * @param {string} key The key of the value to remove.
             * @returns {boolean} Returns `true` if the entry was removed, else `false`.
             */
            function listCacheDelete(key) {
                var data = this.__data__,
                    index = assocIndexOf(data, key);

                if (index < 0) {
                    return false;
                }
                var lastIndex = data.length - 1;
                if (index == lastIndex) {
                    data.pop();
                } else {
                    splice.call(data, index, 1);
                }
                --this.size;
                return true;
            }

            module.exports = listCacheDelete;

            /***/
        },
        /* 123 */
        /***/function (module, exports, __webpack_require__) {

            var assocIndexOf = __webpack_require__(6);

            /**
             * Gets the list cache value for `key`.
             *
             * @private
             * @name get
             * @memberOf ListCache
             * @param {string} key The key of the value to get.
             * @returns {*} Returns the entry value.
             */
            function listCacheGet(key) {
                var data = this.__data__,
                    index = assocIndexOf(data, key);

                return index < 0 ? undefined : data[index][1];
            }

            module.exports = listCacheGet;

            /***/
        },
        /* 124 */
        /***/function (module, exports, __webpack_require__) {

            var assocIndexOf = __webpack_require__(6);

            /**
             * Checks if a list cache value for `key` exists.
             *
             * @private
             * @name has
             * @memberOf ListCache
             * @param {string} key The key of the entry to check.
             * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
             */
            function listCacheHas(key) {
                return assocIndexOf(this.__data__, key) > -1;
            }

            module.exports = listCacheHas;

            /***/
        },
        /* 125 */
        /***/function (module, exports, __webpack_require__) {

            var assocIndexOf = __webpack_require__(6);

            /**
             * Sets the list cache `key` to `value`.
             *
             * @private
             * @name set
             * @memberOf ListCache
             * @param {string} key The key of the value to set.
             * @param {*} value The value to set.
             * @returns {Object} Returns the list cache instance.
             */
            function listCacheSet(key, value) {
                var data = this.__data__,
                    index = assocIndexOf(data, key);

                if (index < 0) {
                    ++this.size;
                    data.push([key, value]);
                } else {
                    data[index][1] = value;
                }
                return this;
            }

            module.exports = listCacheSet;

            /***/
        },
        /* 126 */
        /***/function (module, exports, __webpack_require__) {

            var Hash = __webpack_require__(70),
                ListCache = __webpack_require__(5),
                Map = __webpack_require__(13);

            /**
             * Removes all key-value entries from the map.
             *
             * @private
             * @name clear
             * @memberOf MapCache
             */
            function mapCacheClear() {
                this.size = 0;
                this.__data__ = {
                    'hash': new Hash(),
                    'map': new (Map || ListCache)(),
                    'string': new Hash()
                };
            }

            module.exports = mapCacheClear;

            /***/
        },
        /* 127 */
        /***/function (module, exports, __webpack_require__) {

            var getMapData = __webpack_require__(7);

            /**
             * Removes `key` and its value from the map.
             *
             * @private
             * @name delete
             * @memberOf MapCache
             * @param {string} key The key of the value to remove.
             * @returns {boolean} Returns `true` if the entry was removed, else `false`.
             */
            function mapCacheDelete(key) {
                var result = getMapData(this, key)['delete'](key);
                this.size -= result ? 1 : 0;
                return result;
            }

            module.exports = mapCacheDelete;

            /***/
        },
        /* 128 */
        /***/function (module, exports, __webpack_require__) {

            var getMapData = __webpack_require__(7);

            /**
             * Gets the map value for `key`.
             *
             * @private
             * @name get
             * @memberOf MapCache
             * @param {string} key The key of the value to get.
             * @returns {*} Returns the entry value.
             */
            function mapCacheGet(key) {
                return getMapData(this, key).get(key);
            }

            module.exports = mapCacheGet;

            /***/
        },
        /* 129 */
        /***/function (module, exports, __webpack_require__) {

            var getMapData = __webpack_require__(7);

            /**
             * Checks if a map value for `key` exists.
             *
             * @private
             * @name has
             * @memberOf MapCache
             * @param {string} key The key of the entry to check.
             * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
             */
            function mapCacheHas(key) {
                return getMapData(this, key).has(key);
            }

            module.exports = mapCacheHas;

            /***/
        },
        /* 130 */
        /***/function (module, exports, __webpack_require__) {

            var getMapData = __webpack_require__(7);

            /**
             * Sets the map `key` to `value`.
             *
             * @private
             * @name set
             * @memberOf MapCache
             * @param {string} key The key of the value to set.
             * @param {*} value The value to set.
             * @returns {Object} Returns the map cache instance.
             */
            function mapCacheSet(key, value) {
                var data = getMapData(this, key),
                    size = data.size;

                data.set(key, value);
                this.size += data.size == size ? 0 : 1;
                return this;
            }

            module.exports = mapCacheSet;

            /***/
        },
        /* 131 */
        /***/function (module, exports) {

            /**
             * Converts `map` to its key-value pairs.
             *
             * @private
             * @param {Object} map The map to convert.
             * @returns {Array} Returns the key-value pairs.
             */
            function mapToArray(map) {
                var index = -1,
                    result = Array(map.size);

                map.forEach(function (value, key) {
                    result[++index] = [key, value];
                });
                return result;
            }

            module.exports = mapToArray;

            /***/
        },
        /* 132 */
        /***/function (module, exports, __webpack_require__) {

            var memoize = __webpack_require__(155);

            /** Used as the maximum memoize cache size. */
            var MAX_MEMOIZE_SIZE = 500;

            /**
             * A specialized version of `_.memoize` which clears the memoized function's
             * cache when it exceeds `MAX_MEMOIZE_SIZE`.
             *
             * @private
             * @param {Function} func The function to have its output memoized.
             * @returns {Function} Returns the new memoized function.
             */
            function memoizeCapped(func) {
                var result = memoize(func, function (key) {
                    if (cache.size === MAX_MEMOIZE_SIZE) {
                        cache.clear();
                    }
                    return key;
                });

                var cache = result.cache;
                return result;
            }

            module.exports = memoizeCapped;

            /***/
        },
        /* 133 */
        /***/function (module, exports, __webpack_require__) {

            var getNative = __webpack_require__(2);

            /* Built-in method references that are verified to be native. */
            var nativeDefineProperty = getNative(Object, 'defineProperty');

            module.exports = nativeDefineProperty;

            /***/
        },
        /* 134 */
        /***/function (module, exports, __webpack_require__) {

            var overArg = __webpack_require__(43);

            /* Built-in method references for those with the same name as other `lodash` methods. */
            var nativeKeys = overArg(Object.keys, Object);

            module.exports = nativeKeys;

            /***/
        },
        /* 135 */
        /***/function (module, exports, __webpack_require__) {

            /* WEBPACK VAR INJECTION */(function (module) {
                var freeGlobal = __webpack_require__(39);

                /** Detect free variable `exports`. */
                var freeExports = (typeof exports === 'undefined' ? 'undefined' : _typeof2(exports)) == 'object' && exports && !exports.nodeType && exports;

                /** Detect free variable `module`. */
                var freeModule = freeExports && (typeof module === 'undefined' ? 'undefined' : _typeof2(module)) == 'object' && module && !module.nodeType && module;

                /** Detect the popular CommonJS extension `module.exports`. */
                var moduleExports = freeModule && freeModule.exports === freeExports;

                /** Detect free variable `process` from Node.js. */
                var freeProcess = moduleExports && freeGlobal.process;

                /** Used to access faster Node.js helpers. */
                var nodeUtil = function () {
                    try {
                        return freeProcess && freeProcess.binding('util');
                    } catch (e) {}
                }();

                module.exports = nodeUtil;

                /* WEBPACK VAR INJECTION */
            }).call(exports, __webpack_require__(51)(module));

            /***/
        },
        /* 136 */
        /***/function (module, exports, __webpack_require__) {

            var apply = __webpack_require__(74);

            /* Built-in method references for those with the same name as other `lodash` methods. */
            var nativeMax = Math.max;

            /**
             * A specialized version of `baseRest` which transforms the rest array.
             *
             * @private
             * @param {Function} func The function to apply a rest parameter to.
             * @param {number} [start=func.length-1] The start position of the rest parameter.
             * @param {Function} transform The rest array transform.
             * @returns {Function} Returns the new function.
             */
            function overRest(func, start, transform) {
                start = nativeMax(start === undefined ? func.length - 1 : start, 0);
                return function () {
                    var args = arguments,
                        index = -1,
                        length = nativeMax(args.length - start, 0),
                        array = Array(length);

                    while (++index < length) {
                        array[index] = args[start + index];
                    }
                    index = -1;
                    var otherArgs = Array(start + 1);
                    while (++index < start) {
                        otherArgs[index] = args[index];
                    }
                    otherArgs[start] = transform(array);
                    return apply(func, this, otherArgs);
                };
            }

            module.exports = overRest;

            /***/
        },
        /* 137 */
        /***/function (module, exports) {

            /** Used to stand-in for `undefined` hash values. */
            var HASH_UNDEFINED = '__lodash_hash_undefined__';

            /**
             * Adds `value` to the array cache.
             *
             * @private
             * @name add
             * @memberOf SetCache
             * @alias push
             * @param {*} value The value to cache.
             * @returns {Object} Returns the cache instance.
             */
            function setCacheAdd(value) {
                this.__data__.set(value, HASH_UNDEFINED);
                return this;
            }

            module.exports = setCacheAdd;

            /***/
        },
        /* 138 */
        /***/function (module, exports) {

            /**
             * Checks if `value` is in the array cache.
             *
             * @private
             * @name has
             * @memberOf SetCache
             * @param {*} value The value to search for.
             * @returns {number} Returns `true` if `value` is found, else `false`.
             */
            function setCacheHas(value) {
                return this.__data__.has(value);
            }

            module.exports = setCacheHas;

            /***/
        },
        /* 139 */
        /***/function (module, exports, __webpack_require__) {

            var baseSetToString = __webpack_require__(98),
                shortOut = __webpack_require__(140);

            /**
             * Sets the `toString` method of `func` to return `string`.
             *
             * @private
             * @param {Function} func The function to modify.
             * @param {Function} string The `toString` result.
             * @returns {Function} Returns `func`.
             */
            var setToString = shortOut(baseSetToString);

            module.exports = setToString;

            /***/
        },
        /* 140 */
        /***/function (module, exports) {

            /** Used to detect hot functions by number of calls within a span of milliseconds. */
            var HOT_COUNT = 500,
                HOT_SPAN = 16;

            /* Built-in method references for those with the same name as other `lodash` methods. */
            var nativeNow = Date.now;

            /**
             * Creates a function that'll short out and invoke `identity` instead
             * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
             * milliseconds.
             *
             * @private
             * @param {Function} func The function to restrict.
             * @returns {Function} Returns the new shortable function.
             */
            function shortOut(func) {
                var count = 0,
                    lastCalled = 0;

                return function () {
                    var stamp = nativeNow(),
                        remaining = HOT_SPAN - (stamp - lastCalled);

                    lastCalled = stamp;
                    if (remaining > 0) {
                        if (++count >= HOT_COUNT) {
                            return arguments[0];
                        }
                    } else {
                        count = 0;
                    }
                    return func.apply(undefined, arguments);
                };
            }

            module.exports = shortOut;

            /***/
        },
        /* 141 */
        /***/function (module, exports, __webpack_require__) {

            var ListCache = __webpack_require__(5);

            /**
             * Removes all key-value entries from the stack.
             *
             * @private
             * @name clear
             * @memberOf Stack
             */
            function stackClear() {
                this.__data__ = new ListCache();
                this.size = 0;
            }

            module.exports = stackClear;

            /***/
        },
        /* 142 */
        /***/function (module, exports) {

            /**
             * Removes `key` and its value from the stack.
             *
             * @private
             * @name delete
             * @memberOf Stack
             * @param {string} key The key of the value to remove.
             * @returns {boolean} Returns `true` if the entry was removed, else `false`.
             */
            function stackDelete(key) {
                var data = this.__data__,
                    result = data['delete'](key);

                this.size = data.size;
                return result;
            }

            module.exports = stackDelete;

            /***/
        },
        /* 143 */
        /***/function (module, exports) {

            /**
             * Gets the stack value for `key`.
             *
             * @private
             * @name get
             * @memberOf Stack
             * @param {string} key The key of the value to get.
             * @returns {*} Returns the entry value.
             */
            function stackGet(key) {
                return this.__data__.get(key);
            }

            module.exports = stackGet;

            /***/
        },
        /* 144 */
        /***/function (module, exports) {

            /**
             * Checks if a stack value for `key` exists.
             *
             * @private
             * @name has
             * @memberOf Stack
             * @param {string} key The key of the entry to check.
             * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
             */
            function stackHas(key) {
                return this.__data__.has(key);
            }

            module.exports = stackHas;

            /***/
        },
        /* 145 */
        /***/function (module, exports, __webpack_require__) {

            var ListCache = __webpack_require__(5),
                Map = __webpack_require__(13),
                MapCache = __webpack_require__(14);

            /** Used as the size to enable large array optimizations. */
            var LARGE_ARRAY_SIZE = 200;

            /**
             * Sets the stack `key` to `value`.
             *
             * @private
             * @name set
             * @memberOf Stack
             * @param {string} key The key of the value to set.
             * @param {*} value The value to set.
             * @returns {Object} Returns the stack cache instance.
             */
            function stackSet(key, value) {
                var data = this.__data__;
                if (data instanceof ListCache) {
                    var pairs = data.__data__;
                    if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
                        pairs.push([key, value]);
                        this.size = ++data.size;
                        return this;
                    }
                    data = this.__data__ = new MapCache(pairs);
                }
                data.set(key, value);
                this.size = data.size;
                return this;
            }

            module.exports = stackSet;

            /***/
        },
        /* 146 */
        /***/function (module, exports) {

            /**
             * A specialized version of `_.indexOf` which performs strict equality
             * comparisons of values, i.e. `===`.
             *
             * @private
             * @param {Array} array The array to inspect.
             * @param {*} value The value to search for.
             * @param {number} fromIndex The index to search from.
             * @returns {number} Returns the index of the matched value, else `-1`.
             */
            function strictIndexOf(array, value, fromIndex) {
                var index = fromIndex - 1,
                    length = array.length;

                while (++index < length) {
                    if (array[index] === value) {
                        return index;
                    }
                }
                return -1;
            }

            module.exports = strictIndexOf;

            /***/
        },
        /* 147 */
        /***/function (module, exports, __webpack_require__) {

            var memoizeCapped = __webpack_require__(132),
                toString = __webpack_require__(158);

            /** Used to match property names within property paths. */
            var reLeadingDot = /^\./,
                rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

            /** Used to match backslashes in property paths. */
            var reEscapeChar = /\\(\\)?/g;

            /**
             * Converts `string` to a property path array.
             *
             * @private
             * @param {string} string The string to convert.
             * @returns {Array} Returns the property path array.
             */
            var stringToPath = memoizeCapped(function (string) {
                string = toString(string);

                var result = [];
                if (reLeadingDot.test(string)) {
                    result.push('');
                }
                string.replace(rePropName, function (match, number, quote, string) {
                    result.push(quote ? string.replace(reEscapeChar, '$1') : number || match);
                });
                return result;
            });

            module.exports = stringToPath;

            /***/
        },
        /* 148 */
        /***/function (module, exports) {

            /**
             * Creates a function that returns `value`.
             *
             * @static
             * @memberOf _
             * @since 2.4.0
             * @category Util
             * @param {*} value The value to return from the new function.
             * @returns {Function} Returns the new constant function.
             * @example
             *
             * var objects = _.times(2, _.constant({ 'a': 1 }));
             *
             * console.log(objects);
             * // => [{ 'a': 1 }, { 'a': 1 }]
             *
             * console.log(objects[0] === objects[1]);
             * // => true
             */
            function constant(value) {
                return function () {
                    return value;
                };
            }

            module.exports = constant;

            /***/
        },
        /* 149 */
        /***/function (module, exports, __webpack_require__) {

            var baseDifference = __webpack_require__(80),
                baseFlatten = __webpack_require__(32),
                baseRest = __webpack_require__(35),
                isArrayLikeObject = __webpack_require__(21);

            /**
             * Creates an array of `array` values not included in the other given arrays
             * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
             * for equality comparisons. The order and references of result values are
             * determined by the first array.
             *
             * **Note:** Unlike `_.pullAll`, this method returns a new array.
             *
             * @static
             * @memberOf _
             * @since 0.1.0
             * @category Array
             * @param {Array} array The array to inspect.
             * @param {...Array} [values] The values to exclude.
             * @returns {Array} Returns the new array of filtered values.
             * @see _.without, _.xor
             * @example
             *
             * _.difference([2, 1], [2, 3]);
             * // => [1]
             */
            var difference = baseRest(function (array, values) {
                return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true)) : [];
            });

            module.exports = difference;

            /***/
        },
        /* 150 */
        /***/function (module, exports, __webpack_require__) {

            var baseGet = __webpack_require__(33);

            /**
             * Gets the value at `path` of `object`. If the resolved value is
             * `undefined`, the `defaultValue` is returned in its place.
             *
             * @static
             * @memberOf _
             * @since 3.7.0
             * @category Object
             * @param {Object} object The object to query.
             * @param {Array|string} path The path of the property to get.
             * @param {*} [defaultValue] The value returned for `undefined` resolved values.
             * @returns {*} Returns the resolved value.
             * @example
             *
             * var object = { 'a': [{ 'b': { 'c': 3 } }] };
             *
             * _.get(object, 'a[0].b.c');
             * // => 3
             *
             * _.get(object, ['a', '0', 'b', 'c']);
             * // => 3
             *
             * _.get(object, 'a.b.c', 'default');
             * // => 'default'
             */
            function get(object, path, defaultValue) {
                var result = object == null ? undefined : baseGet(object, path);
                return result === undefined ? defaultValue : result;
            }

            module.exports = get;

            /***/
        },
        /* 151 */
        /***/function (module, exports, __webpack_require__) {

            var baseHasIn = __webpack_require__(85),
                hasPath = __webpack_require__(111);

            /**
             * Checks if `path` is a direct or inherited property of `object`.
             *
             * @static
             * @memberOf _
             * @since 4.0.0
             * @category Object
             * @param {Object} object The object to query.
             * @param {Array|string} path The path to check.
             * @returns {boolean} Returns `true` if `path` exists, else `false`.
             * @example
             *
             * var object = _.create({ 'a': _.create({ 'b': 2 }) });
             *
             * _.hasIn(object, 'a');
             * // => true
             *
             * _.hasIn(object, 'a.b');
             * // => true
             *
             * _.hasIn(object, ['a', 'b']);
             * // => true
             *
             * _.hasIn(object, 'b');
             * // => false
             */
            function hasIn(object, path) {
                return object != null && hasPath(object, path, baseHasIn);
            }

            module.exports = hasIn;

            /***/
        },
        /* 152 */
        /***/function (module, exports, __webpack_require__) {

            var getPrototype = __webpack_require__(108),
                isObjectLike = __webpack_require__(4);

            /** `Object#toString` result references. */
            var objectTag = '[object Object]';

            /** Used for built-in method references. */
            var funcProto = Function.prototype,
                objectProto = Object.prototype;

            /** Used to resolve the decompiled source of functions. */
            var funcToString = funcProto.toString;

            /** Used to check objects for own properties. */
            var hasOwnProperty = objectProto.hasOwnProperty;

            /** Used to infer the `Object` constructor. */
            var objectCtorString = funcToString.call(Object);

            /**
             * Used to resolve the
             * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
             * of values.
             */
            var objectToString = objectProto.toString;

            /**
             * Checks if `value` is a plain object, that is, an object created by the
             * `Object` constructor or one with a `[[Prototype]]` of `null`.
             *
             * @static
             * @memberOf _
             * @since 0.8.0
             * @category Lang
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
             * @example
             *
             * function Foo() {
             *   this.a = 1;
             * }
             *
             * _.isPlainObject(new Foo);
             * // => false
             *
             * _.isPlainObject([1, 2, 3]);
             * // => false
             *
             * _.isPlainObject({ 'x': 0, 'y': 0 });
             * // => true
             *
             * _.isPlainObject(Object.create(null));
             * // => true
             */
            function isPlainObject(value) {
                if (!isObjectLike(value) || objectToString.call(value) != objectTag) {
                    return false;
                }
                var proto = getPrototype(value);
                if (proto === null) {
                    return true;
                }
                var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
                return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
            }

            module.exports = isPlainObject;

            /***/
        },
        /* 153 */
        /***/function (module, exports, __webpack_require__) {

            var baseIsTypedArray = __webpack_require__(91),
                baseUnary = __webpack_require__(36),
                nodeUtil = __webpack_require__(135);

            /* Node.js helper references. */
            var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

            /**
             * Checks if `value` is classified as a typed array.
             *
             * @static
             * @memberOf _
             * @since 3.0.0
             * @category Lang
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
             * @example
             *
             * _.isTypedArray(new Uint8Array);
             * // => true
             *
             * _.isTypedArray([]);
             * // => false
             */
            var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

            module.exports = isTypedArray;

            /***/
        },
        /* 154 */
        /***/function (module, exports, __webpack_require__) {

            var baseAssignValue = __webpack_require__(79),
                baseForOwn = __webpack_require__(83),
                baseIteratee = __webpack_require__(92);

            /**
             * Creates an object with the same keys as `object` and values generated
             * by running each own enumerable string keyed property of `object` thru
             * `iteratee`. The iteratee is invoked with three arguments:
             * (value, key, object).
             *
             * @static
             * @memberOf _
             * @since 2.4.0
             * @category Object
             * @param {Object} object The object to iterate over.
             * @param {Function} [iteratee=_.identity] The function invoked per iteration.
             * @returns {Object} Returns the new mapped object.
             * @see _.mapKeys
             * @example
             *
             * var users = {
             *   'fred':    { 'user': 'fred',    'age': 40 },
             *   'pebbles': { 'user': 'pebbles', 'age': 1 }
             * };
             *
             * _.mapValues(users, function(o) { return o.age; });
             * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
             *
             * // The `_.property` iteratee shorthand.
             * _.mapValues(users, 'age');
             * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
             */
            function mapValues(object, iteratee) {
                var result = {};
                iteratee = baseIteratee(iteratee, 3);

                baseForOwn(object, function (value, key, object) {
                    baseAssignValue(result, key, iteratee(value, key, object));
                });
                return result;
            }

            module.exports = mapValues;

            /***/
        },
        /* 155 */
        /***/function (module, exports, __webpack_require__) {

            var MapCache = __webpack_require__(14);

            /** Error message constants. */
            var FUNC_ERROR_TEXT = 'Expected a function';

            /**
             * Creates a function that memoizes the result of `func`. If `resolver` is
             * provided, it determines the cache key for storing the result based on the
             * arguments provided to the memoized function. By default, the first argument
             * provided to the memoized function is used as the map cache key. The `func`
             * is invoked with the `this` binding of the memoized function.
             *
             * **Note:** The cache is exposed as the `cache` property on the memoized
             * function. Its creation may be customized by replacing the `_.memoize.Cache`
             * constructor with one whose instances implement the
             * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
             * method interface of `delete`, `get`, `has`, and `set`.
             *
             * @static
             * @memberOf _
             * @since 0.1.0
             * @category Function
             * @param {Function} func The function to have its output memoized.
             * @param {Function} [resolver] The function to resolve the cache key.
             * @returns {Function} Returns the new memoized function.
             * @example
             *
             * var object = { 'a': 1, 'b': 2 };
             * var other = { 'c': 3, 'd': 4 };
             *
             * var values = _.memoize(_.values);
             * values(object);
             * // => [1, 2]
             *
             * values(other);
             * // => [3, 4]
             *
             * object.a = 2;
             * values(object);
             * // => [1, 2]
             *
             * // Modify the result cache.
             * values.cache.set(object, ['a', 'b']);
             * values(object);
             * // => ['a', 'b']
             *
             * // Replace `_.memoize.Cache`.
             * _.memoize.Cache = WeakMap;
             */
            function memoize(func, resolver) {
                if (typeof func != 'function' || resolver && typeof resolver != 'function') {
                    throw new TypeError(FUNC_ERROR_TEXT);
                }
                var memoized = function memoized() {
                    var args = arguments,
                        key = resolver ? resolver.apply(this, args) : args[0],
                        cache = memoized.cache;

                    if (cache.has(key)) {
                        return cache.get(key);
                    }
                    var result = func.apply(this, args);
                    memoized.cache = cache.set(key, result) || cache;
                    return result;
                };
                memoized.cache = new (memoize.Cache || MapCache)();
                return memoized;
            }

            // Expose `MapCache`.
            memoize.Cache = MapCache;

            module.exports = memoize;

            /***/
        },
        /* 156 */
        /***/function (module, exports) {

            /**
             * This method returns `undefined`.
             *
             * @static
             * @memberOf _
             * @since 2.3.0
             * @category Util
             * @example
             *
             * _.times(2, _.noop);
             * // => [undefined, undefined]
             */
            function noop() {
                // No operation performed.
            }

            module.exports = noop;

            /***/
        },
        /* 157 */
        /***/function (module, exports, __webpack_require__) {

            var baseProperty = __webpack_require__(96),
                basePropertyDeep = __webpack_require__(97),
                isKey = __webpack_require__(8),
                toKey = __webpack_require__(10);

            /**
             * Creates a function that returns the value at `path` of a given object.
             *
             * @static
             * @memberOf _
             * @since 2.4.0
             * @category Util
             * @param {Array|string} path The path of the property to get.
             * @returns {Function} Returns the new accessor function.
             * @example
             *
             * var objects = [
             *   { 'a': { 'b': 2 } },
             *   { 'a': { 'b': 1 } }
             * ];
             *
             * _.map(objects, _.property('a.b'));
             * // => [2, 1]
             *
             * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
             * // => [1, 2]
             */
            function property(path) {
                return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
            }

            module.exports = property;

            /***/
        },
        /* 158 */
        /***/function (module, exports, __webpack_require__) {

            var baseToString = __webpack_require__(100);

            /**
             * Converts `value` to a string. An empty string is returned for `null`
             * and `undefined` values. The sign of `-0` is preserved.
             *
             * @static
             * @memberOf _
             * @since 4.0.0
             * @category Lang
             * @param {*} value The value to process.
             * @returns {string} Returns the string.
             * @example
             *
             * _.toString(null);
             * // => ''
             *
             * _.toString(-0);
             * // => '-0'
             *
             * _.toString([1, 2, 3]);
             * // => '1,2,3'
             */
            function toString(value) {
                return value == null ? '' : baseToString(value);
            }

            module.exports = toString;

            /***/
        },
        /* 159 */
        /***/function (module, exports, __webpack_require__) {

            var baseFlatten = __webpack_require__(32),
                baseRest = __webpack_require__(35),
                baseUniq = __webpack_require__(101),
                isArrayLikeObject = __webpack_require__(21);

            /**
             * Creates an array of unique values, in order, from all given arrays using
             * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
             * for equality comparisons.
             *
             * @static
             * @memberOf _
             * @since 0.1.0
             * @category Array
             * @param {...Array} [arrays] The arrays to inspect.
             * @returns {Array} Returns the new array of combined values.
             * @example
             *
             * _.union([2], [1, 2]);
             * // => [2, 1]
             */
            var union = baseRest(function (arrays) {
                return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
            });

            module.exports = union;

            /***/
        },
        /* 160 */
        /***/function (module, exports) {

            // Copyright Joyent, Inc. and other Node contributors.
            //
            // Permission is hereby granted, free of charge, to any person obtaining a
            // copy of this software and associated documentation files (the
            // "Software"), to deal in the Software without restriction, including
            // without limitation the rights to use, copy, modify, merge, publish,
            // distribute, sublicense, and/or sell copies of the Software, and to permit
            // persons to whom the Software is furnished to do so, subject to the
            // following conditions:
            //
            // The above copyright notice and this permission notice shall be included
            // in all copies or substantial portions of the Software.
            //
            // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
            // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
            // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
            // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
            // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
            // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
            // USE OR OTHER DEALINGS IN THE SOFTWARE.

            'use strict';

            // If obj.hasOwnProperty has been overridden, then calling
            // obj.hasOwnProperty(prop) will break.
            // See: https://github.com/joyent/node/issues/1707

            function hasOwnProperty(obj, prop) {
                return Object.prototype.hasOwnProperty.call(obj, prop);
            }

            module.exports = function (qs, sep, eq, options) {
                sep = sep || '&';
                eq = eq || '=';
                var obj = {};

                if (typeof qs !== 'string' || qs.length === 0) {
                    return obj;
                }

                var regexp = /\+/g;
                qs = qs.split(sep);

                var maxKeys = 1000;
                if (options && typeof options.maxKeys === 'number') {
                    maxKeys = options.maxKeys;
                }

                var len = qs.length;
                // maxKeys <= 0 means that we should not limit keys count
                if (maxKeys > 0 && len > maxKeys) {
                    len = maxKeys;
                }

                for (var i = 0; i < len; ++i) {
                    var x = qs[i].replace(regexp, '%20'),
                        idx = x.indexOf(eq),
                        kstr,
                        vstr,
                        k,
                        v;

                    if (idx >= 0) {
                        kstr = x.substr(0, idx);
                        vstr = x.substr(idx + 1);
                    } else {
                        kstr = x;
                        vstr = '';
                    }

                    k = decodeURIComponent(kstr);
                    v = decodeURIComponent(vstr);

                    if (!hasOwnProperty(obj, k)) {
                        obj[k] = v;
                    } else if (Array.isArray(obj[k])) {
                        obj[k].push(v);
                    } else {
                        obj[k] = [obj[k], v];
                    }
                }

                return obj;
            };

            /***/
        },
        /* 161 */
        /***/function (module, exports) {

            // Copyright Joyent, Inc. and other Node contributors.
            //
            // Permission is hereby granted, free of charge, to any person obtaining a
            // copy of this software and associated documentation files (the
            // "Software"), to deal in the Software without restriction, including
            // without limitation the rights to use, copy, modify, merge, publish,
            // distribute, sublicense, and/or sell copies of the Software, and to permit
            // persons to whom the Software is furnished to do so, subject to the
            // following conditions:
            //
            // The above copyright notice and this permission notice shall be included
            // in all copies or substantial portions of the Software.
            //
            // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
            // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
            // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
            // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
            // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
            // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
            // USE OR OTHER DEALINGS IN THE SOFTWARE.

            'use strict';

            var stringifyPrimitive = function stringifyPrimitive(v) {
                switch (typeof v === 'undefined' ? 'undefined' : _typeof2(v)) {
                    case 'string':
                        return v;

                    case 'boolean':
                        return v ? 'true' : 'false';

                    case 'number':
                        return isFinite(v) ? v : '';

                    default:
                        return '';
                }
            };

            module.exports = function (obj, sep, eq, name) {
                sep = sep || '&';
                eq = eq || '=';
                if (obj === null) {
                    obj = undefined;
                }

                if ((typeof obj === 'undefined' ? 'undefined' : _typeof2(obj)) === 'object') {
                    return Object.keys(obj).map(function (k) {
                        var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
                        if (Array.isArray(obj[k])) {
                            return obj[k].map(function (v) {
                                return ks + encodeURIComponent(stringifyPrimitive(v));
                            }).join(sep);
                        } else {
                            return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
                        }
                    }).join(sep);
                }

                if (!name) return '';
                return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
            };

            /***/
        },
        /* 162 */
        /***/function (module, exports, __webpack_require__) {

            'use strict';

            exports.__esModule = true;
            exports.INIT_ACTION = exports.ActionCreators = exports.ActionTypes = undefined;

            var _extends = Object.assign || function (target) {
                for (var i = 1; i < arguments.length; i++) {
                    var source = arguments[i];for (var key in source) {
                        if (Object.prototype.hasOwnProperty.call(source, key)) {
                            target[key] = source[key];
                        }
                    }
                }return target;
            };

            var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
                return typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
            } : function (obj) {
                return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
            };

            exports.liftAction = liftAction;
            exports.liftReducerWith = liftReducerWith;
            exports.unliftState = unliftState;
            exports.unliftStore = unliftStore;
            exports.default = instrument;

            var _difference = __webpack_require__(149);

            var _difference2 = _interopRequireDefault(_difference);

            var _union = __webpack_require__(159);

            var _union2 = _interopRequireDefault(_union);

            var _isPlainObject = __webpack_require__(152);

            var _isPlainObject2 = _interopRequireDefault(_isPlainObject);

            var _symbolObservable = __webpack_require__(174);

            var _symbolObservable2 = _interopRequireDefault(_symbolObservable);

            function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : { default: obj };
            }

            var ActionTypes = exports.ActionTypes = {
                PERFORM_ACTION: 'PERFORM_ACTION',
                RESET: 'RESET',
                ROLLBACK: 'ROLLBACK',
                COMMIT: 'COMMIT',
                SWEEP: 'SWEEP',
                TOGGLE_ACTION: 'TOGGLE_ACTION',
                SET_ACTIONS_ACTIVE: 'SET_ACTIONS_ACTIVE',
                JUMP_TO_STATE: 'JUMP_TO_STATE',
                IMPORT_STATE: 'IMPORT_STATE',
                LOCK_CHANGES: 'LOCK_CHANGES',
                PAUSE_RECORDING: 'PAUSE_RECORDING'
            };

            /**
             * Action creators to change the History state.
             */
            var ActionCreators = exports.ActionCreators = {
                performAction: function performAction(action) {
                    if (!(0, _isPlainObject2.default)(action)) {
                        throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');
                    }

                    if (typeof action.type === 'undefined') {
                        throw new Error('Actions may not have an undefined "type" property. ' + 'Have you misspelled a constant?');
                    }

                    return { type: ActionTypes.PERFORM_ACTION, action: action, timestamp: Date.now() };
                },
                reset: function reset() {
                    return { type: ActionTypes.RESET, timestamp: Date.now() };
                },
                rollback: function rollback() {
                    return { type: ActionTypes.ROLLBACK, timestamp: Date.now() };
                },
                commit: function commit() {
                    return { type: ActionTypes.COMMIT, timestamp: Date.now() };
                },
                sweep: function sweep() {
                    return { type: ActionTypes.SWEEP };
                },
                toggleAction: function toggleAction(id) {
                    return { type: ActionTypes.TOGGLE_ACTION, id: id };
                },
                setActionsActive: function setActionsActive(start, end) {
                    var active = arguments.length <= 2 || arguments[2] === undefined ? true : arguments[2];

                    return { type: ActionTypes.SET_ACTIONS_ACTIVE, start: start, end: end, active: active };
                },
                jumpToState: function jumpToState(index) {
                    return { type: ActionTypes.JUMP_TO_STATE, index: index };
                },
                importState: function importState(nextLiftedState, noRecompute) {
                    return { type: ActionTypes.IMPORT_STATE, nextLiftedState: nextLiftedState, noRecompute: noRecompute };
                },
                lockChanges: function lockChanges(status) {
                    return { type: ActionTypes.LOCK_CHANGES, status: status };
                },
                pauseRecording: function pauseRecording(status) {
                    return { type: ActionTypes.PAUSE_RECORDING, status: status };
                }
            };

            var INIT_ACTION = exports.INIT_ACTION = { type: '@@INIT' };

            /**
             * Computes the next entry with exceptions catching.
             */
            function computeWithTryCatch(reducer, action, state) {
                var nextState = state;
                var nextError = void 0;
                try {
                    nextState = reducer(state, action);
                } catch (err) {
                    nextError = err.toString();
                    if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && (typeof window.chrome !== 'undefined' || typeof window.process !== 'undefined' && window.process.type === 'renderer')) {
                        // In Chrome, rethrowing provides better source map support
                        setTimeout(function () {
                            throw err;
                        });
                    } else {
                        console.error(err);
                    }
                }

                return {
                    state: nextState,
                    error: nextError
                };
            }

            /**
             * Computes the next entry in the log by applying an action.
             */
            function computeNextEntry(reducer, action, state, shouldCatchErrors) {
                if (!shouldCatchErrors) {
                    return { state: reducer(state, action) };
                }
                return computeWithTryCatch(reducer, action, state);
            }

            /**
             * Runs the reducer on invalidated actions to get a fresh computation log.
             */
            function recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, shouldCatchErrors) {
                // Optimization: exit early and return the same reference
                // if we know nothing could have changed.
                if (!computedStates || minInvalidatedStateIndex === -1 || minInvalidatedStateIndex >= computedStates.length && computedStates.length === stagedActionIds.length) {
                    return computedStates;
                }

                var nextComputedStates = computedStates.slice(0, minInvalidatedStateIndex);
                for (var i = minInvalidatedStateIndex; i < stagedActionIds.length; i++) {
                    var actionId = stagedActionIds[i];
                    var action = actionsById[actionId].action;

                    var previousEntry = nextComputedStates[i - 1];
                    var previousState = previousEntry ? previousEntry.state : committedState;

                    var shouldSkip = skippedActionIds.indexOf(actionId) > -1;
                    var entry = void 0;
                    if (shouldSkip) {
                        entry = previousEntry;
                    } else {
                        if (shouldCatchErrors && previousEntry && previousEntry.error) {
                            entry = {
                                state: previousState,
                                error: 'Interrupted by an error up the chain'
                            };
                        } else {
                            entry = computeNextEntry(reducer, action, previousState, shouldCatchErrors);
                        }
                    }
                    nextComputedStates.push(entry);
                }

                return nextComputedStates;
            }

            /**
             * Lifts an app's action into an action on the lifted store.
             */
            function liftAction(action) {
                return ActionCreators.performAction(action);
            }

            /**
             * Creates a history state reducer from an app's reducer.
             */
            function liftReducerWith(reducer, initialCommittedState, monitorReducer, options) {
                var initialLiftedState = {
                    monitorState: monitorReducer(undefined, {}),
                    nextActionId: 1,
                    actionsById: { 0: liftAction(INIT_ACTION) },
                    stagedActionIds: [0],
                    skippedActionIds: [],
                    committedState: initialCommittedState,
                    currentStateIndex: 0,
                    computedStates: [],
                    isLocked: options.shouldStartLocked === true,
                    isPaused: options.shouldRecordChanges === false
                };

                /**
                 * Manages how the history actions modify the history state.
                 */
                return function (liftedState, liftedAction) {
                    var _ref = liftedState || initialLiftedState;

                    var monitorState = _ref.monitorState;
                    var actionsById = _ref.actionsById;
                    var nextActionId = _ref.nextActionId;
                    var stagedActionIds = _ref.stagedActionIds;
                    var skippedActionIds = _ref.skippedActionIds;
                    var committedState = _ref.committedState;
                    var currentStateIndex = _ref.currentStateIndex;
                    var computedStates = _ref.computedStates;
                    var isLocked = _ref.isLocked;
                    var isPaused = _ref.isPaused;

                    if (!liftedState) {
                        // Prevent mutating initialLiftedState
                        actionsById = _extends({}, actionsById);
                    }

                    function commitExcessActions(n) {
                        // Auto-commits n-number of excess actions.
                        var excess = n;
                        var idsToDelete = stagedActionIds.slice(1, excess + 1);

                        for (var i = 0; i < idsToDelete.length; i++) {
                            if (computedStates[i + 1].error) {
                                // Stop if error is found. Commit actions up to error.
                                excess = i;
                                idsToDelete = stagedActionIds.slice(1, excess + 1);
                                break;
                            } else {
                                delete actionsById[idsToDelete[i]];
                            }
                        }

                        skippedActionIds = skippedActionIds.filter(function (id) {
                            return idsToDelete.indexOf(id) === -1;
                        });
                        stagedActionIds = [0].concat(stagedActionIds.slice(excess + 1));
                        committedState = computedStates[excess].state;
                        computedStates = computedStates.slice(excess);
                        currentStateIndex = currentStateIndex > excess ? currentStateIndex - excess : 0;
                    }

                    function computePausedAction(shouldInit) {
                        var _extends2;

                        var computedState = void 0;
                        if (shouldInit) {
                            computedState = computedStates[currentStateIndex];
                            monitorState = monitorReducer(monitorState, liftedAction);
                        } else {
                            computedState = computeNextEntry(reducer, liftedAction.action, computedStates[currentStateIndex].state, false);
                        }
                        if (!options.pauseActionType || nextActionId === 1) {
                            return {
                                monitorState: monitorState,
                                actionsById: { 0: liftAction(INIT_ACTION) },
                                nextActionId: 1,
                                stagedActionIds: [0],
                                skippedActionIds: [],
                                committedState: computedState.state,
                                currentStateIndex: 0,
                                computedStates: [computedState],
                                isLocked: isLocked,
                                isPaused: true
                            };
                        }
                        if (shouldInit) {
                            stagedActionIds = [].concat(stagedActionIds, [nextActionId]);
                            nextActionId++;
                            currentStateIndex++;
                        }
                        return {
                            monitorState: monitorState,
                            actionsById: _extends({}, actionsById, (_extends2 = {}, _extends2[nextActionId - 1] = liftAction({ type: options.pauseActionType }), _extends2)),
                            nextActionId: nextActionId,
                            stagedActionIds: stagedActionIds,
                            skippedActionIds: skippedActionIds,
                            committedState: committedState,
                            currentStateIndex: currentStateIndex,
                            computedStates: [].concat(computedStates.slice(0, currentStateIndex), [computedState]),
                            isLocked: isLocked,
                            isPaused: true
                        };
                    }

                    // By default, agressively recompute every state whatever happens.
                    // This has O(n) performance, so we'll override this to a sensible
                    // value whenever we feel like we don't have to recompute the states.
                    var minInvalidatedStateIndex = 0;

                    switch (liftedAction.type) {
                        case ActionTypes.PERFORM_ACTION:
                            {
                                if (isLocked) return liftedState || initialLiftedState;
                                if (isPaused) return computePausedAction();

                                // Auto-commit as new actions come in.
                                if (options.maxAge && stagedActionIds.length === options.maxAge) {
                                    commitExcessActions(1);
                                }

                                if (currentStateIndex === stagedActionIds.length - 1) {
                                    currentStateIndex++;
                                }
                                var actionId = nextActionId++;
                                // Mutation! This is the hottest path, and we optimize on purpose.
                                // It is safe because we set a new key in a cache dictionary.
                                actionsById[actionId] = liftedAction;
                                stagedActionIds = [].concat(stagedActionIds, [actionId]);
                                // Optimization: we know that only the new action needs computing.
                                minInvalidatedStateIndex = stagedActionIds.length - 1;
                                break;
                            }
                        case ActionTypes.RESET:
                            {
                                // Get back to the state the store was created with.
                                actionsById = { 0: liftAction(INIT_ACTION) };
                                nextActionId = 1;
                                stagedActionIds = [0];
                                skippedActionIds = [];
                                committedState = initialCommittedState;
                                currentStateIndex = 0;
                                computedStates = [];
                                break;
                            }
                        case ActionTypes.COMMIT:
                            {
                                // Consider the last committed state the new starting point.
                                // Squash any staged actions into a single committed state.
                                actionsById = { 0: liftAction(INIT_ACTION) };
                                nextActionId = 1;
                                stagedActionIds = [0];
                                skippedActionIds = [];
                                committedState = computedStates[currentStateIndex].state;
                                currentStateIndex = 0;
                                computedStates = [];
                                break;
                            }
                        case ActionTypes.ROLLBACK:
                            {
                                // Forget about any staged actions.
                                // Start again from the last committed state.
                                actionsById = { 0: liftAction(INIT_ACTION) };
                                nextActionId = 1;
                                stagedActionIds = [0];
                                skippedActionIds = [];
                                currentStateIndex = 0;
                                computedStates = [];
                                break;
                            }
                        case ActionTypes.TOGGLE_ACTION:
                            {
                                var _ret = function () {
                                    // Toggle whether an action with given ID is skipped.
                                    // Being skipped means it is a no-op during the computation.
                                    var actionId = liftedAction.id;

                                    var index = skippedActionIds.indexOf(actionId);
                                    if (index === -1) {
                                        skippedActionIds = [actionId].concat(skippedActionIds);
                                    } else {
                                        skippedActionIds = skippedActionIds.filter(function (id) {
                                            return id !== actionId;
                                        });
                                    }
                                    // Optimization: we know history before this action hasn't changed
                                    minInvalidatedStateIndex = stagedActionIds.indexOf(actionId);
                                    return 'break';
                                }();

                                if (_ret === 'break') break;
                            }
                        case ActionTypes.SET_ACTIONS_ACTIVE:
                            {
                                // Toggle whether an action with given ID is skipped.
                                // Being skipped means it is a no-op during the computation.
                                var start = liftedAction.start;
                                var end = liftedAction.end;
                                var active = liftedAction.active;

                                var actionIds = [];
                                for (var i = start; i < end; i++) {
                                    actionIds.push(i);
                                }if (active) {
                                    skippedActionIds = (0, _difference2.default)(skippedActionIds, actionIds);
                                } else {
                                    skippedActionIds = (0, _union2.default)(skippedActionIds, actionIds);
                                }

                                // Optimization: we know history before this action hasn't changed
                                minInvalidatedStateIndex = stagedActionIds.indexOf(start);
                                break;
                            }
                        case ActionTypes.JUMP_TO_STATE:
                            {
                                // Without recomputing anything, move the pointer that tell us
                                // which state is considered the current one. Useful for sliders.
                                currentStateIndex = liftedAction.index;
                                // Optimization: we know the history has not changed.
                                minInvalidatedStateIndex = Infinity;
                                break;
                            }
                        case ActionTypes.SWEEP:
                            {
                                // Forget any actions that are currently being skipped.
                                stagedActionIds = (0, _difference2.default)(stagedActionIds, skippedActionIds);
                                skippedActionIds = [];
                                currentStateIndex = Math.min(currentStateIndex, stagedActionIds.length - 1);
                                break;
                            }
                        case ActionTypes.IMPORT_STATE:
                            {
                                if (Array.isArray(liftedAction.nextLiftedState)) {
                                    // recompute array of actions
                                    actionsById = { 0: liftAction(INIT_ACTION) };
                                    nextActionId = 1;
                                    stagedActionIds = [0];
                                    skippedActionIds = [];
                                    currentStateIndex = liftedAction.nextLiftedState.length;
                                    computedStates = [];
                                    committedState = liftedAction.preloadedState;
                                    minInvalidatedStateIndex = 0;
                                    // iterate through actions
                                    liftedAction.nextLiftedState.forEach(function (action) {
                                        actionsById[nextActionId] = liftAction(action);
                                        stagedActionIds.push(nextActionId);
                                        nextActionId++;
                                    });
                                } else {
                                    var _liftedAction$nextLif = liftedAction.nextLiftedState;
                                    // Completely replace everything.

                                    monitorState = _liftedAction$nextLif.monitorState;
                                    actionsById = _liftedAction$nextLif.actionsById;
                                    nextActionId = _liftedAction$nextLif.nextActionId;
                                    stagedActionIds = _liftedAction$nextLif.stagedActionIds;
                                    skippedActionIds = _liftedAction$nextLif.skippedActionIds;
                                    committedState = _liftedAction$nextLif.committedState;
                                    currentStateIndex = _liftedAction$nextLif.currentStateIndex;
                                    computedStates = _liftedAction$nextLif.computedStates;

                                    if (liftedAction.noRecompute) {
                                        minInvalidatedStateIndex = Infinity;
                                    }
                                }

                                break;
                            }
                        case ActionTypes.LOCK_CHANGES:
                            {
                                isLocked = liftedAction.status;
                                minInvalidatedStateIndex = Infinity;
                                break;
                            }
                        case ActionTypes.PAUSE_RECORDING:
                            {
                                isPaused = liftedAction.status;
                                if (isPaused) return computePausedAction(true);
                                minInvalidatedStateIndex = Infinity;
                                break;
                            }
                        case '@@redux/INIT':
                            {
                                if (options.shouldHotReload === false && liftedState) {
                                    return liftedState;
                                }

                                // Recompute states on hot reload and init.
                                minInvalidatedStateIndex = 0;

                                if (options.maxAge && stagedActionIds.length > options.maxAge) {
                                    // States must be recomputed before committing excess.
                                    computedStates = recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, options.shouldCatchErrors);

                                    commitExcessActions(stagedActionIds.length - options.maxAge);

                                    // Avoid double computation.
                                    minInvalidatedStateIndex = Infinity;
                                }

                                break;
                            }
                        default:
                            {
                                // If the action is not recognized, it's a monitor action.
                                // Optimization: a monitor action can't change history.
                                minInvalidatedStateIndex = Infinity;
                                break;
                            }
                    }

                    computedStates = recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, options.shouldCatchErrors);
                    monitorState = monitorReducer(monitorState, liftedAction);
                    return {
                        monitorState: monitorState,
                        actionsById: actionsById,
                        nextActionId: nextActionId,
                        stagedActionIds: stagedActionIds,
                        skippedActionIds: skippedActionIds,
                        committedState: committedState,
                        currentStateIndex: currentStateIndex,
                        computedStates: computedStates,
                        isLocked: isLocked,
                        isPaused: isPaused
                    };
                };
            }

            /**
             * Provides an app's view into the state of the lifted store.
             */
            function unliftState(liftedState) {
                var computedStates = liftedState.computedStates;
                var currentStateIndex = liftedState.currentStateIndex;
                var state = computedStates[currentStateIndex].state;

                return state;
            }

            /**
             * Provides an app's view into the lifted store.
             */
            function unliftStore(liftedStore, liftReducer) {
                var _extends3;

                var lastDefinedState = void 0;

                function getState() {
                    var state = unliftState(liftedStore.getState());
                    if (state !== undefined) {
                        lastDefinedState = state;
                    }
                    return lastDefinedState;
                }

                return _extends({}, liftedStore, (_extends3 = {

                    liftedStore: liftedStore,

                    dispatch: function dispatch(action) {
                        liftedStore.dispatch(liftAction(action));
                        return action;
                    },

                    getState: getState,

                    replaceReducer: function replaceReducer(nextReducer) {
                        liftedStore.replaceReducer(liftReducer(nextReducer));
                    }
                }, _extends3[_symbolObservable2.default] = function () {
                    return _extends({}, liftedStore[_symbolObservable2.default](), {
                        subscribe: function subscribe(observer) {
                            if ((typeof observer === 'undefined' ? 'undefined' : _typeof(observer)) !== 'object') {
                                throw new TypeError('Expected the observer to be an object.');
                            }

                            function observeState() {
                                if (observer.next) {
                                    observer.next(getState());
                                }
                            }

                            observeState();
                            var unsubscribe = liftedStore.subscribe(observeState);
                            return { unsubscribe: unsubscribe };
                        }
                    });
                }, _extends3));
            }

            /**
             * Redux instrumentation store enhancer.
             */
            function instrument() {
                var monitorReducer = arguments.length <= 0 || arguments[0] === undefined ? function () {
                    return null;
                } : arguments[0];
                var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

                /* eslint-disable no-eq-null */
                if (options.maxAge != null && options.maxAge < 2) {
                    /* eslint-enable */
                    throw new Error('DevTools.instrument({ maxAge }) option, if specified, ' + 'may not be less than 2.');
                }

                return function (createStore) {
                    return function (reducer, initialState, enhancer) {

                        function liftReducer(r) {
                            if (typeof r !== 'function') {
                                if (r && typeof r.default === 'function') {
                                    throw new Error('Expected the reducer to be a function. ' + 'Instead got an object with a "default" field. ' + 'Did you pass a module instead of the default export? ' + 'Try passing require(...).default instead.');
                                }
                                throw new Error('Expected the reducer to be a function.');
                            }
                            return liftReducerWith(r, initialState, monitorReducer, options);
                        }

                        var liftedStore = createStore(liftReducer(reducer), enhancer);
                        if (liftedStore.liftedStore) {
                            throw new Error('DevTools instrumentation should not be applied more than once. ' + 'Check your store configuration.');
                        }

                        return unliftStore(liftedStore, liftReducer);
                    };
                };
            }

            /***/
        },
        /* 163 */
        /***/function (module, exports) {

            /* WEBPACK VAR INJECTION */(function (global) {
                'use strict';

                exports.__esModule = true;

                var _extends = Object.assign || function (target) {
                    for (var i = 1; i < arguments.length; i++) {
                        var source = arguments[i];for (var key in source) {
                            if (Object.prototype.hasOwnProperty.call(source, key)) {
                                target[key] = source[key];
                            }
                        }
                    }return target;
                };

                var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
                    return typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
                } : function (obj) {
                    return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
                };

                exports.default = catchErrors;
                var ERROR = '@@remotedev/ERROR';

                function catchErrors(sendError) {
                    if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && _typeof(window.onerror) === 'object') {
                        window.onerror = function (message, url, lineNo, columnNo, error) {
                            var errorAction = { type: ERROR, message: message, url: url, lineNo: lineNo, columnNo: columnNo };
                            if (error && error.stack) errorAction.stack = error.stack;
                            sendError(errorAction);
                            return false;
                        };
                    } else if (typeof ErrorUtils !== 'undefined') {
                        ErrorUtils.setGlobalHandler(function (error, isFatal) {
                            sendError({ type: ERROR, error: error, isFatal: isFatal });
                        });
                    }

                    if ((typeof console === 'undefined' ? 'undefined' : _typeof(console)) === 'object' && typeof console.error === 'function' && !console.beforeRemotedev) {
                        console.beforeRemotedev = console.error.bind(console);
                        console.error = function () {
                            var errorAction = { type: ERROR };
                            var error = arguments[0];
                            errorAction.message = error.message ? error.message : error;
                            if (error.sourceURL) {
                                errorAction = _extends({}, errorAction, {
                                    sourceURL: error.sourceURL, line: error.line, column: error.column
                                });
                            }
                            if (error.stack) errorAction.stack = error.stack;
                            sendError(errorAction);
                            console.beforeRemotedev.apply(null, arguments);
                        };
                    }
                }
                /* WEBPACK VAR INJECTION */
            }).call(exports, function () {
                return this;
            }());

            /***/
        },
        /* 164 */
        /***/function (module, exports, __webpack_require__) {

            'use strict';

            exports.__esModule = true;

            var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
                return typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
            } : function (obj) {
                return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
            };

            var _extends = Object.assign || function (target) {
                for (var i = 1; i < arguments.length; i++) {
                    var source = arguments[i];for (var key in source) {
                        if (Object.prototype.hasOwnProperty.call(source, key)) {
                            target[key] = source[key];
                        }
                    }
                }return target;
            };

            exports.arrToRegex = arrToRegex;
            exports.isFiltered = isFiltered;
            exports.filterStagedActions = filterStagedActions;
            exports.filterState = filterState;

            var _mapValues = __webpack_require__(154);

            var _mapValues2 = _interopRequireDefault(_mapValues);

            function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : { default: obj };
            }

            function arrToRegex(v) {
                return typeof v === 'string' ? v : v.join('|');
            }

            function filterActions(actionsById, actionsFilter) {
                if (!actionsFilter) return actionsById;
                return (0, _mapValues2.default)(actionsById, function (action, id) {
                    return _extends({}, action, { action: actionsFilter(action.action, id) });
                });
            }

            function filterStates(computedStates, statesFilter) {
                if (!statesFilter) return computedStates;
                return computedStates.map(function (state, idx) {
                    return _extends({}, state, { state: statesFilter(state.state, idx) });
                });
            }

            function isFiltered(action, filters) {
                if (!filters || !action) return false;

                var whitelist = filters.whitelist;
                var blacklist = filters.blacklist;

                var _ref = action.action || action;

                var type = _ref.type;

                return whitelist && !type.match(whitelist) || blacklist && type.match(blacklist);
            }

            function filterStagedActions(state, filters) {
                if (!filters) return state;

                var filteredStagedActionIds = [];
                var filteredComputedStates = [];

                state.stagedActionIds.forEach(function (id, idx) {
                    if (!isFiltered(state.actionsById[id], filters)) {
                        filteredStagedActionIds.push(id);
                        filteredComputedStates.push(state.computedStates[idx]);
                    }
                });

                return _extends({}, state, {
                    stagedActionIds: filteredStagedActionIds,
                    computedStates: filteredComputedStates
                });
            }

            function filterState(state, type, localFilter, statesFilter, actionsFilter, nextActionId) {
                if (type === 'ACTION') return !statesFilter ? state : statesFilter(state, nextActionId - 1);else if (type !== 'STATE') return state;

                if (localFilter) {
                    var _ret = function () {
                        var filteredStagedActionIds = [];
                        var filteredComputedStates = [];
                        var filteredActionsById = actionsFilter && {};
                        var actionsById = state.actionsById;
                        var computedStates = state.computedStates;

                        state.stagedActionIds.forEach(function (id, idx) {
                            if (!isFiltered(actionsById[id], localFilter)) {
                                filteredStagedActionIds.push(id);
                                filteredComputedStates.push(statesFilter ? _extends({}, computedStates[idx], { state: statesFilter(computedStates[idx].state, idx) }) : computedStates[idx]);
                                if (actionsFilter) {
                                    filteredActionsById[id] = _extends({}, actionsById[id], {
                                        action: actionsFilter(actionsById[id].action, id)
                                    });
                                }
                            }
                        });

                        return {
                            v: _extends({}, state, {
                                actionsById: filteredActionsById || actionsById,
                                stagedActionIds: filteredStagedActionIds,
                                computedStates: filteredComputedStates
                            })
                        };
                    }();

                    if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
                }

                if (!statesFilter && !actionsFilter) return state;
                return _extends({}, state, {
                    actionsById: filterActions(state.actionsById, actionsFilter),
                    computedStates: filterStates(state.computedStates, statesFilter)
                });
            }

            /***/
        },
        /* 165 */
        /***/function (module, exports, __webpack_require__) {

            'use strict';

            exports.__esModule = true;

            var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
                return typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
            } : function (obj) {
                return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
            };

            exports.generateId = generateId;
            exports.getMethods = getMethods;
            exports.getActionsArray = getActionsArray;
            exports.evalAction = evalAction;
            exports.evalMethod = evalMethod;

            var _getParams = __webpack_require__(60);

            var _getParams2 = _interopRequireDefault(_getParams);

            function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : { default: obj };
            }

            function generateId() {
                return Math.random().toString(36).substr(2);
            }

            function flatTree(obj) {
                var namespace = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];

                var functions = [];
                Object.keys(obj).forEach(function (key) {
                    var prop = obj[key];
                    if (typeof prop === 'function') {
                        functions.push({
                            name: namespace + (key || prop.name || 'anonymous'),
                            func: prop,
                            args: (0, _getParams2.default)(prop)
                        });
                    } else if ((typeof prop === 'undefined' ? 'undefined' : _typeof(prop)) === 'object') {
                        functions = functions.concat(flatTree(prop, namespace + key + '.'));
                    }
                });
                return functions;
            }

            function getMethods(obj) {
                if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object') return undefined;
                var functions = void 0;
                var m = void 0;
                if (obj.__proto__) m = obj.__proto__.__proto__;
                if (!m) m = obj;

                Object.getOwnPropertyNames(m).forEach(function (key) {
                    var prop = m[key];
                    if (typeof prop === 'function' && key !== 'constructor') {
                        if (!functions) functions = [];
                        functions.push({
                            name: key || prop.name || 'anonymous',
                            args: (0, _getParams2.default)(prop)
                        });
                    }
                });
                return functions;
            }

            function getActionsArray(actionCreators) {
                if (Array.isArray(actionCreators)) return actionCreators;
                return flatTree(actionCreators);
            }

            /* eslint-disable no-new-func */
            var interpretArg = function interpretArg(arg) {
                return new Function('return ' + arg)();
            };

            function evalArgs(inArgs, restArgs) {
                var args = inArgs.map(interpretArg);
                if (!restArgs) return args;
                var rest = interpretArg(restArgs);
                if (Array.isArray(rest)) return args.concat.apply(args, rest);
                throw new Error('rest must be an array');
            }

            function evalAction(action, actionCreators) {
                if (typeof action === 'string') {
                    return new Function('return ' + action)();
                }

                var actionCreator = actionCreators[action.selected].func;
                var args = evalArgs(action.args, action.rest);
                return actionCreator.apply(undefined, args);
            }

            function evalMethod(action, obj) {
                if (typeof action === 'string') {
                    return new Function('return ' + action).call(obj);
                }

                var args = evalArgs(action.args, action.rest);
                return new Function('args', 'return this.' + action.name + '(args)').apply(obj, args);
            }
            /* eslint-enable */

            /***/
        },
        /* 166 */
        /***/function (module, exports, __webpack_require__) {

            var SCEmitter = __webpack_require__(12).SCEmitter;

            var SCChannel = function SCChannel(name, client, options) {
                var self = this;

                SCEmitter.call(this);

                this.PENDING = 'pending';
                this.SUBSCRIBED = 'subscribed';
                this.UNSUBSCRIBED = 'unsubscribed';

                this.name = name;
                this.state = this.UNSUBSCRIBED;
                this.client = client;

                this.options = options || {};
                this.setOptions(this.options);
            };

            SCChannel.prototype = Object.create(SCEmitter.prototype);

            SCChannel.prototype.setOptions = function (options) {
                if (!options) {
                    options = {};
                }
                this.waitForAuth = options.waitForAuth || false;
                if (options.data !== undefined) {
                    this.data = options.data;
                }
            };

            SCChannel.prototype.getState = function () {
                return this.state;
            };

            SCChannel.prototype.subscribe = function (options) {
                this.client.subscribe(this.name, options);
            };

            SCChannel.prototype.unsubscribe = function () {
                this.client.unsubscribe(this.name);
            };

            SCChannel.prototype.isSubscribed = function (includePending) {
                return this.client.isSubscribed(this.name, includePending);
            };

            SCChannel.prototype.publish = function (data, callback) {
                this.client.publish(this.name, data, callback);
            };

            SCChannel.prototype.watch = function (handler) {
                this.client.watch(this.name, handler);
            };

            SCChannel.prototype.unwatch = function (handler) {
                this.client.unwatch(this.name, handler);
            };

            SCChannel.prototype.watchers = function () {
                return this.client.watchers(this.name);
            };

            SCChannel.prototype.destroy = function () {
                this.client.destroyChannel(this.name);
            };

            module.exports.SCChannel = SCChannel;

            /***/
        },
        /* 167 */
        /***/function (module, exports) {

            module.exports.create = function () {
                function F() {};

                return function (o) {
                    if (arguments.length != 1) {
                        throw new Error('Object.create implementation only accepts one parameter.');
                    }
                    F.prototype = o;
                    return new F();
                };
            }();

            /***/
        },
        /* 168 */
        /***/function (module, exports) {

            /* WEBPACK VAR INJECTION */(function (global) {
                var base64Chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

                var arrayBufferToBase64 = function arrayBufferToBase64(arraybuffer) {
                    var bytes = new Uint8Array(arraybuffer);
                    var len = bytes.length;
                    var base64 = '';

                    for (var i = 0; i < len; i += 3) {
                        base64 += base64Chars[bytes[i] >> 2];
                        base64 += base64Chars[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];
                        base64 += base64Chars[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];
                        base64 += base64Chars[bytes[i + 2] & 63];
                    }

                    if (len % 3 === 2) {
                        base64 = base64.substring(0, base64.length - 1) + '=';
                    } else if (len % 3 === 1) {
                        base64 = base64.substring(0, base64.length - 2) + '==';
                    }

                    return base64;
                };

                var binaryToBase64Replacer = function binaryToBase64Replacer(key, value) {
                    if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
                        return {
                            base64: true,
                            data: arrayBufferToBase64(value)
                        };
                    } else if (typeof Buffer !== 'undefined') {
                        if (value instanceof Buffer) {
                            return {
                                base64: true,
                                data: value.toString('base64')
                            };
                        }
                        // Some versions of Node.js convert Buffers to Objects before they are passed to
                        // the replacer function - Because of this, we need to rehydrate Buffers
                        // before we can convert them to base64 strings.
                        if (value && value.type == 'Buffer' && value.data instanceof Array) {
                            var rehydratedBuffer;
                            if (Buffer.from) {
                                rehydratedBuffer = Buffer.from(value.data);
                            } else {
                                rehydratedBuffer = new Buffer(value.data);
                            }
                            return {
                                base64: true,
                                data: rehydratedBuffer.toString('base64')
                            };
                        }
                    }
                    return value;
                };

                // Decode the data which was transmitted over the wire to a JavaScript Object in a format which SC understands.
                // See encode function below for more details.
                module.exports.decode = function (input) {
                    if (input == null) {
                        return null;
                    }
                    var message = input.toString();

                    try {
                        return JSON.parse(message);
                    } catch (err) {}
                    return message;
                };

                // Encode a raw JavaScript object (which is in the SC protocol format) into a format for
                // transfering it over the wire. In this case, we just convert it into a simple JSON string.
                // If you want to create your own custom codec, you can encode the object into any format
                // (e.g. binary ArrayBuffer or string with any kind of compression) so long as your decode
                // function is able to rehydrate that object back into its original JavaScript Object format
                // (which adheres to the SC protocol).
                // See https://github.com/SocketCluster/socketcluster/blob/master/socketcluster-protocol.md
                // for details about the SC protocol.
                module.exports.encode = function (object) {
                    return JSON.stringify(object, binaryToBase64Replacer);
                };

                /* WEBPACK VAR INJECTION */
            }).call(exports, function () {
                return this;
            }());

            /***/
        },
        /* 169 */
        /***/function (module, exports, __webpack_require__) {

            var SCSocket = __webpack_require__(50);
            var SCSocketCreator = __webpack_require__(171);

            module.exports.SCSocketCreator = SCSocketCreator;
            module.exports.SCSocket = SCSocket;

            module.exports.SCEmitter = __webpack_require__(12).SCEmitter;

            module.exports.connect = function (options) {
                return SCSocketCreator.connect(options);
            };

            module.exports.destroy = function (options) {
                return SCSocketCreator.destroy(options);
            };

            module.exports.version = '5.0.13';

            /***/
        },
        /* 170 */
        /***/function (module, exports) {

            /* WEBPACK VAR INJECTION */(function (global) {
                var AuthEngine = function AuthEngine() {
                    this._internalStorage = {};
                };

                AuthEngine.prototype._isLocalStorageEnabled = function () {
                    var err;
                    try {
                        // Some browsers will throw an error here if localStorage is disabled.
                        global.localStorage;

                        // Safari, in Private Browsing Mode, looks like it supports localStorage but all calls to setItem
                        // throw QuotaExceededError. We're going to detect this and avoid hard to debug edge cases.
                        global.localStorage.setItem('__scLocalStorageTest', 1);
                        global.localStorage.removeItem('__scLocalStorageTest');
                    } catch (e) {
                        err = e;
                    }
                    return !err;
                };

                AuthEngine.prototype.saveToken = function (name, token, options, callback) {
                    if (this._isLocalStorageEnabled() && global.localStorage) {
                        global.localStorage.setItem(name, token);
                    } else {
                        this._internalStorage[name] = token;
                    }
                    callback && callback(null, token);
                };

                AuthEngine.prototype.removeToken = function (name, callback) {
                    var token;

                    this.loadToken(name, function (err, authToken) {
                        token = authToken;
                    });

                    if (this._isLocalStorageEnabled() && global.localStorage) {
                        global.localStorage.removeItem(name);
                    }
                    delete this._internalStorage[name];

                    callback && callback(null, token);
                };

                AuthEngine.prototype.loadToken = function (name, callback) {
                    var token;

                    if (this._isLocalStorageEnabled() && global.localStorage) {
                        token = global.localStorage.getItem(name);
                    } else {
                        token = this._internalStorage[name] || null;
                    }
                    callback(null, token);
                };

                module.exports.AuthEngine = AuthEngine;

                /* WEBPACK VAR INJECTION */
            }).call(exports, function () {
                return this;
            }());

            /***/
        },
        /* 171 */
        /***/function (module, exports, __webpack_require__) {

            var SCSocket = __webpack_require__(50);

            var _connections = {};

            function getMultiplexId(options) {
                var protocolPrefix = options.secure ? 'https://' : 'http://';
                var queryString = '';
                if (options.query) {
                    if (typeof options.query == 'string') {
                        queryString = options.query;
                    } else {
                        var queryArray = [];
                        var queryMap = options.query;
                        for (var key in queryMap) {
                            if (queryMap.hasOwnProperty(key)) {
                                queryArray.push(key + '=' + queryMap[key]);
                            }
                        }
                        if (queryArray.length) {
                            queryString = '?' + queryArray.join('&');
                        }
                    }
                }
                return protocolPrefix + options.hostname + ':' + options.port + options.path + queryString;
            }

            function connect(options) {
                var self = this;

                options = options || {};

                var opts = {
                    port: 8888,
                    hostname: 'localhost',
                    path: '/socketcluster/',
                    secure: options.secure,
                    autoReconnect: true,
                    autoProcessSubscriptions: true,
                    connectTimeout: 20000,
                    ackTimeout: 10000,
                    timestampRequests: false,
                    timestampParam: 't',
                    authEngine: null,
                    authTokenName: 'socketCluster.authToken',
                    binaryType: 'arraybuffer',
                    multiplex: true
                };
                for (var i in options) {
                    if (options.hasOwnProperty(i)) {
                        opts[i] = options[i];
                    }
                }
                var multiplexId = getMultiplexId(opts);
                if (opts.multiplex === false) {
                    return new SCSocket(opts);
                }
                if (_connections[multiplexId]) {
                    _connections[multiplexId].connect();
                } else {
                    _connections[multiplexId] = new SCSocket(opts);
                }
                return _connections[multiplexId];
            }

            function destroy(options) {
                var self = this;

                options = options || {};

                var opts = {
                    port: 8888,
                    hostname: 'localhost',
                    path: '/socketcluster/',
                    secure: options.secure
                };
                for (var i in options) {
                    if (options.hasOwnProperty(i)) {
                        opts[i] = options[i];
                    }
                }
                var multiplexId = getMultiplexId(opts);
                delete _connections[multiplexId];
            }

            module.exports = {
                connect: connect,
                destroy: destroy
            };

            /***/
        },
        /* 172 */
        /***/function (module, exports, __webpack_require__) {

            var SCEmitter = __webpack_require__(12).SCEmitter;
            var Response = __webpack_require__(49).Response;
            var querystring = __webpack_require__(48);
            var WebSocket = __webpack_require__(173);

            var scErrors = __webpack_require__(25);
            var TimeoutError = scErrors.TimeoutError;

            var SCTransport = function SCTransport(authEngine, codecEngine, options) {
                this.state = this.CLOSED;
                this.auth = authEngine;
                this.codec = codecEngine;
                this.options = options;
                this.connectTimeout = options.connectTimeout;
                this.pingTimeout = options.ackTimeout;
                this.callIdGenerator = options.callIdGenerator;

                this._pingTimeoutTicker = null;
                this._callbackMap = {};

                this.open();
            };

            SCTransport.prototype = Object.create(SCEmitter.prototype);

            SCTransport.CONNECTING = SCTransport.prototype.CONNECTING = 'connecting';
            SCTransport.OPEN = SCTransport.prototype.OPEN = 'open';
            SCTransport.CLOSED = SCTransport.prototype.CLOSED = 'closed';

            SCTransport.prototype.uri = function () {
                var query = this.options.query || {};
                var schema = this.options.secure ? 'wss' : 'ws';
                var port = '';

                if (this.options.port && ('wss' == schema && this.options.port != 443 || 'ws' == schema && this.options.port != 80)) {
                    port = ':' + this.options.port;
                }

                if (this.options.timestampRequests) {
                    query[this.options.timestampParam] = new Date().getTime();
                }

                query = querystring.encode(query);

                if (query.length) {
                    query = '?' + query;
                }

                return schema + '://' + this.options.hostname + port + this.options.path + query;
            };

            SCTransport.prototype.open = function () {
                var self = this;

                this.state = this.CONNECTING;
                var uri = this.uri();

                var wsSocket = new WebSocket(uri, null, this.options);
                wsSocket.binaryType = this.options.binaryType;
                this.socket = wsSocket;

                wsSocket.onopen = function () {
                    self._onOpen();
                };

                wsSocket.onclose = function (event) {
                    self._onClose(event.code, event.reason);
                };

                wsSocket.onmessage = function (message, flags) {
                    self._onMessage(message.data);
                };

                wsSocket.onerror = function (error) {
                    // The onclose event will be called automatically after the onerror event
                    // if the socket is connected - Otherwise, if it's in the middle of
                    // connecting, we want to close it manually with a 1006 - This is necessary
                    // to prevent inconsistent behavior when running the client in Node.js
                    // vs in a browser.

                    if (self.state === self.CONNECTING) {
                        self._onClose(1006);
                    }
                };

                this._connectTimeoutRef = setTimeout(function () {
                    self._onClose(4007);
                    self.socket.close(4007);
                }, this.connectTimeout);
            };

            SCTransport.prototype._onOpen = function () {
                var self = this;

                clearTimeout(this._connectTimeoutRef);
                this._resetPingTimeout();

                this._handshake(function (err, status) {
                    if (err) {
                        self._onError(err);
                        self._onClose(4003);
                        self.socket.close(4003);
                    } else {
                        self.state = self.OPEN;
                        SCEmitter.prototype.emit.call(self, 'open', status);
                        self._resetPingTimeout();
                    }
                });
            };

            SCTransport.prototype._handshake = function (callback) {
                var self = this;
                this.auth.loadToken(this.options.authTokenName, function (err, token) {
                    if (err) {
                        callback(err);
                    } else {
                        // Don't wait for this.state to be 'open'.
                        // The underlying WebSocket (this.socket) is already open.
                        var options = {
                            force: true
                        };
                        self.emit('#handshake', {
                            authToken: token
                        }, options, function (err, status) {
                            if (status) {
                                // Add the token which was used as part of authentication attempt
                                // to the status object.
                                status.authToken = token;
                                if (status.authError) {
                                    status.authError = scErrors.hydrateError(status.authError);
                                }
                            }
                            callback(err, status);
                        });
                    }
                });
            };

            SCTransport.prototype._onClose = function (code, data) {
                delete this.socket.onopen;
                delete this.socket.onclose;
                delete this.socket.onmessage;
                delete this.socket.onerror;

                clearTimeout(this._connectTimeoutRef);

                if (this.state == this.OPEN) {
                    this.state = this.CLOSED;
                    SCEmitter.prototype.emit.call(this, 'close', code, data);
                } else if (this.state == this.CONNECTING) {
                    this.state = this.CLOSED;
                    SCEmitter.prototype.emit.call(this, 'openAbort', code, data);
                }
            };

            SCTransport.prototype._onMessage = function (message) {
                SCEmitter.prototype.emit.call(this, 'event', 'message', message);

                // If ping
                if (message == '#1') {
                    this._resetPingTimeout();
                    if (this.socket.readyState == this.socket.OPEN) {
                        this.socket.send('#2');
                    }
                } else {
                    var obj = this.decode(message);
                    var event = obj.event;

                    if (event) {
                        var response = new Response(this, obj.cid);
                        SCEmitter.prototype.emit.call(this, 'event', event, obj.data, response);
                    } else if (obj.rid != null) {

                        var eventObject = this._callbackMap[obj.rid];
                        if (eventObject) {
                            clearTimeout(eventObject.timeout);
                            delete this._callbackMap[obj.rid];

                            if (eventObject.callback) {
                                var rehydratedError = scErrors.hydrateError(obj.error);
                                eventObject.callback(rehydratedError, obj.data);
                            }
                        }
                    } else {
                        SCEmitter.prototype.emit.call(this, 'event', 'raw', obj);
                    }
                }
            };

            SCTransport.prototype._onError = function (err) {
                SCEmitter.prototype.emit.call(this, 'error', err);
            };

            SCTransport.prototype._resetPingTimeout = function () {
                var self = this;

                var now = new Date().getTime();
                clearTimeout(this._pingTimeoutTicker);

                this._pingTimeoutTicker = setTimeout(function () {
                    self._onClose(4000);
                    self.socket.close(4000);
                }, this.pingTimeout);
            };

            SCTransport.prototype.getBytesReceived = function () {
                return this.socket.bytesReceived;
            };

            SCTransport.prototype.close = function (code, data) {
                code = code || 1000;

                if (this.state == this.OPEN) {
                    var packet = {
                        code: code,
                        data: data
                    };
                    this.emit('#disconnect', packet);

                    this._onClose(code, data);
                    this.socket.close(code);
                } else if (this.state == this.CONNECTING) {
                    this._onClose(code, data);
                    this.socket.close(code);
                }
            };

            SCTransport.prototype.emitRaw = function (eventObject) {
                eventObject.cid = this.callIdGenerator();

                if (eventObject.callback) {
                    this._callbackMap[eventObject.cid] = eventObject;
                }

                var simpleEventObject = {
                    event: eventObject.event,
                    data: eventObject.data,
                    cid: eventObject.cid
                };

                this.sendObject(simpleEventObject);
                return eventObject.cid;
            };

            SCTransport.prototype._handleEventAckTimeout = function (eventObject) {
                var errorMessage = "Event response for '" + eventObject.event + "' timed out";
                var error = new TimeoutError(errorMessage);

                if (eventObject.cid) {
                    delete this._callbackMap[eventObject.cid];
                }
                var callback = eventObject.callback;
                delete eventObject.callback;
                callback.call(eventObject, error, eventObject);
            };

            // The last two optional arguments (a and b) can be options and/or callback
            SCTransport.prototype.emit = function (event, data, a, b) {
                var self = this;

                var callback, options;

                if (b) {
                    options = a;
                    callback = b;
                } else {
                    if (a instanceof Function) {
                        options = {};
                        callback = a;
                    } else {
                        options = a;
                    }
                }

                var eventObject = {
                    event: event,
                    data: data,
                    callback: callback
                };

                if (callback && !options.noTimeout) {
                    eventObject.timeout = setTimeout(function () {
                        self._handleEventAckTimeout(eventObject);
                    }, this.options.ackTimeout);
                }

                var cid = null;
                if (this.state == this.OPEN || options.force) {
                    cid = this.emitRaw(eventObject);
                }
                return cid;
            };

            SCTransport.prototype.cancelPendingResponse = function (cid) {
                delete this._callbackMap[cid];
            };

            SCTransport.prototype.decode = function (message) {
                return this.codec.decode(message);
            };

            SCTransport.prototype.encode = function (object) {
                return this.codec.encode(object);
            };

            SCTransport.prototype.send = function (data) {
                if (this.socket.readyState != this.socket.OPEN) {
                    this._onClose(1005);
                } else {
                    this.socket.send(data);
                }
            };

            SCTransport.prototype.sendObject = function (object) {
                var str, formatError;
                try {
                    str = this.encode(object);
                } catch (err) {
                    formatError = err;
                    this._onError(formatError);
                }
                if (!formatError) {
                    this.send(str);
                }
            };

            module.exports.SCTransport = SCTransport;

            /***/
        },
        /* 173 */
        /***/function (module, exports) {

            /**
             * WebSocket constructor.
             *
             * The third `opts` options object gets ignored in web browsers, since it's
             * non-standard, and throws a TypeError if passed to the constructor.
             * See: https://github.com/einaros/ws/issues/227
             *
             * @param {String} uri
             * @param {Array} protocols (optional)
             * @param {Object} opts (optional)
             * @api public
             */

            function ws(uri, protocols, opts) {
                wx.onSocketOpen(this.handleSocketOpen.bind(this));
                wx.onSocketClose(this.handleSocketClose.bind(this));
                wx.onSocketMessage(this.handleMessage.bind(this));
                wx.onSocketError(this.handleSocketError.bind(this));
                wx.connectSocket({ url: uri });
                return this;
            }

            ws.prototype = {
                handleSocketOpenLater: function handleSocketOpenLater(res) {
                    var that = this;
                    if (this.handleSocketOpenLaterHandler) {
                        clearTimeout(this.handleSocketOpenLaterHandler);
                    }

                    this.handleSocketOpenLaterHandler = setTimeout(function () {
                        that.handleSocketOpen(res);
                    }, 1000);
                },
                handleSocketOpen: function handleSocketOpen(res) {
                    if (this.onopen) {
                        this.onopen(res);
                    } else {
                        this.handleSocketOpenLater(res);
                    }
                },
                handleMessage: function handleMessage(res) {
                    if (this.onmessage) {
                        this.onmessage(res);
                    } else {
                        this.handleMessageLater(res);
                    }
                },
                handleMessageLater: function handleMessageLater(res) {
                    var that = this;
                    if (this.handleMessageLaterHandler) {
                        clearTimeout(this.handleMessageLaterHandler);
                    }

                    this.handleMessageLaterHandler = setTimeout(function () {
                        that.handleMessage(res);
                    }, 1000);
                },
                handleSocketError: function handleSocketError(res) {
                    if (this.onerror) {
                        this.onerror(res);
                    } else {
                        this.handleSocketErrorLater(res);
                    }
                },
                handleSocketErrorLater: function handleSocketErrorLater(res) {
                    var that = this;
                    if (this.handleSocketErrorLaterHandler) {
                        clearTimeout(this.handleSocketErrorLaterHandler);
                    }

                    this.handleSocketErrorLaterHandler = setTimeout(function () {
                        that.handleSocketError(res);
                    }, 1000);
                },
                handleSocketClose: function handleSocketClose(res) {
                    if (this.onclose) {
                        this.onclose(res);
                    } else {
                        this.handleSocketCloseLater(res);
                    }
                },
                handleSocketCloseLater: function handleSocketCloseLater(res) {
                    var that = this;
                    if (this.handleSocketCloseLaterHandler) {
                        clearTimeout(this.handleSocketCloseLaterHandler);
                    }

                    this.handleSocketCloseLaterHandler = setTimeout(function () {
                        that.handleSocketClose(res);
                    });
                },
                send: function send(data) {
                    wx.sendSocketMessage({
                        data: data, fail: function fail(res) {
                            console.log("wx web socket send failed: " + res);
                        }
                    });
                },
                close: wx.closeSocket
            };

            module.exports = ws;
            /***/
        },
        /* 174 */
        /***/function (module, exports, __webpack_require__) {

            /* WEBPACK VAR INJECTION */(function (global) {
                /* global window */
                'use strict';

                module.exports = __webpack_require__(175)(global || window || this);

                /* WEBPACK VAR INJECTION */
            }).call(exports, function () {
                return this;
            }());

            /***/
        },
        /* 175 */
        /***/function (module, exports) {

            'use strict';

            module.exports = function symbolObservablePonyfill(root) {
                var result;
                var _Symbol5 = root.Symbol;

                if (typeof _Symbol5 === 'function') {
                    if (_Symbol5.observable) {
                        result = _Symbol5.observable;
                    } else {
                        result = _Symbol5('observable');
                        _Symbol5.observable = result;
                    }
                } else {
                    result = '@@observable';
                }

                return result;
            };

            /***/
        }
        /******/])
    );
});
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInJlbW90ZS1yZWR1eC1kZXZ0b29scy5qcyJdLCJuYW1lcyI6WyJ3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsInJvb3QiLCJmYWN0b3J5IiwibW9kdWxlIiwiZXhwb3J0cyIsImRlZmluZSIsImFtZCIsIm1vZHVsZXMiLCJpbnN0YWxsZWRNb2R1bGVzIiwiX193ZWJwYWNrX3JlcXVpcmVfXyIsIm1vZHVsZUlkIiwiaWQiLCJsb2FkZWQiLCJjYWxsIiwibSIsImMiLCJwIiwiX19lc01vZHVsZSIsImNvbXBvc2VXaXRoRGV2VG9vbHMiLCJkZWZhdWx0IiwidW5kZWZpbmVkIiwiX2RldlRvb2xzIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiX2RldlRvb2xzMiIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJvYmoiLCJmcmVlR2xvYmFsIiwiZnJlZVNlbGYiLCJzZWxmIiwiRnVuY3Rpb24iLCJiYXNlSXNOYXRpdmUiLCJnZXRWYWx1ZSIsImdldE5hdGl2ZSIsIm9iamVjdCIsImtleSIsInZhbHVlIiwiaXNBcnJheSIsIkFycmF5IiwiaXNPYmplY3RMaWtlIiwibGlzdENhY2hlQ2xlYXIiLCJsaXN0Q2FjaGVEZWxldGUiLCJsaXN0Q2FjaGVHZXQiLCJsaXN0Q2FjaGVIYXMiLCJsaXN0Q2FjaGVTZXQiLCJMaXN0Q2FjaGUiLCJlbnRyaWVzIiwiaW5kZXgiLCJsZW5ndGgiLCJjbGVhciIsImVudHJ5Iiwic2V0IiwicHJvdG90eXBlIiwiaGFzIiwiZXEiLCJhc3NvY0luZGV4T2YiLCJhcnJheSIsImlzS2V5YWJsZSIsImdldE1hcERhdGEiLCJtYXAiLCJkYXRhIiwiX19kYXRhX18iLCJpc1N5bWJvbCIsInJlSXNEZWVwUHJvcCIsInJlSXNQbGFpblByb3AiLCJpc0tleSIsInR5cGUiLCJ0ZXN0IiwibmF0aXZlQ3JlYXRlIiwiSU5GSU5JVFkiLCJ0b0tleSIsInJlc3VsdCIsImlzT2JqZWN0IiwiRW1pdHRlciIsImNyZWF0ZSIsIlNDRW1pdHRlciIsImVtaXQiLCJldmVudCIsImRvbWFpbiIsImVyciIsImFyZ3VtZW50cyIsIkVycm9yIiwiZG9tYWluRW1pdHRlciIsImRvbWFpblRocm93biIsImFwcGx5IiwiTWFwIiwibWFwQ2FjaGVDbGVhciIsIm1hcENhY2hlRGVsZXRlIiwibWFwQ2FjaGVHZXQiLCJtYXBDYWNoZUhhcyIsIm1hcENhY2hlU2V0IiwiTWFwQ2FjaGUiLCJzZXRDYWNoZUFkZCIsInNldENhY2hlSGFzIiwiU2V0Q2FjaGUiLCJ2YWx1ZXMiLCJhZGQiLCJwdXNoIiwiU3ltYm9sIiwiY2FjaGVIYXMiLCJjYWNoZSIsInNldFRvQXJyYXkiLCJzaXplIiwiZm9yRWFjaCIsImlkZW50aXR5IiwiaXNBcnJheUxpa2VPYmplY3QiLCJhcmdzVGFnIiwib2JqZWN0UHJvdG8iLCJoYXNPd25Qcm9wZXJ0eSIsIm9iamVjdFRvU3RyaW5nIiwidG9TdHJpbmciLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsImlzQXJndW1lbnRzIiwiaXNBcnJheUxpa2UiLCJNQVhfU0FGRV9JTlRFR0VSIiwiaXNMZW5ndGgiLCJzeW1ib2xUYWciLCJhcnJheUxpa2VLZXlzIiwiYmFzZUtleXMiLCJrZXlzIiwiY3ljbGUiLCJpc1N0cmljdCIsIkF1dGhUb2tlbkV4cGlyZWRFcnJvciIsIm1lc3NhZ2UiLCJleHBpcnkiLCJjYXB0dXJlU3RhY2tUcmFjZSIsImNhbGxlZSIsInN0YWNrIiwibmFtZSIsIkF1dGhUb2tlbkludmFsaWRFcnJvciIsIlNpbGVudE1pZGRsZXdhcmVCbG9ja2VkRXJyb3IiLCJJbnZhbGlkQWN0aW9uRXJyb3IiLCJJbnZhbGlkQXJndW1lbnRzRXJyb3IiLCJJbnZhbGlkT3B0aW9uc0Vycm9yIiwiSW52YWxpZE1lc3NhZ2VFcnJvciIsIlNvY2tldFByb3RvY29sRXJyb3IiLCJjb2RlIiwiU2VydmVyUHJvdG9jb2xFcnJvciIsIkhUVFBTZXJ2ZXJFcnJvciIsIlJlc291cmNlTGltaXRFcnJvciIsIlRpbWVvdXRFcnJvciIsIkJyb2tlckVycm9yIiwiUHJvY2Vzc0V4aXRFcnJvciIsIlVua25vd25FcnJvciIsInNvY2tldFByb3RvY29sRXJyb3JTdGF0dXNlcyIsInNvY2tldFByb3RvY29sSWdub3JlU3RhdHVzZXMiLCJ1bnNlcmlhbGl6YWJsZUVycm9yUHJvcGVydGllcyIsImRlaHlkcmF0ZUVycm9yIiwiZXJyb3IiLCJpbmNsdWRlU3RhY2tUcmFjZSIsImRlaHlkcmF0ZWRFcnJvciIsImkiLCJkZWN5Y2xlIiwiaHlkcmF0ZUVycm9yIiwiaHlkcmF0ZWRFcnJvciIsIkJ1ZmZlciIsImdsb2JhbCIsImJhc2U2NCIsImllZWU3NTQiLCJTbG93QnVmZmVyIiwiSU5TUEVDVF9NQVhfQllURVMiLCJUWVBFRF9BUlJBWV9TVVBQT1JUIiwidHlwZWRBcnJheVN1cHBvcnQiLCJrTWF4TGVuZ3RoIiwiYXJyIiwiVWludDhBcnJheSIsIl9fcHJvdG9fXyIsImZvbyIsInN1YmFycmF5IiwiYnl0ZUxlbmd0aCIsImUiLCJjcmVhdGVCdWZmZXIiLCJ0aGF0IiwiUmFuZ2VFcnJvciIsImFyZyIsImVuY29kaW5nT3JPZmZzZXQiLCJhbGxvY1Vuc2FmZSIsImZyb20iLCJwb29sU2l6ZSIsIl9hdWdtZW50IiwiVHlwZUVycm9yIiwiQXJyYXlCdWZmZXIiLCJmcm9tQXJyYXlCdWZmZXIiLCJmcm9tU3RyaW5nIiwiZnJvbU9iamVjdCIsInNwZWNpZXMiLCJjb25maWd1cmFibGUiLCJhc3NlcnRTaXplIiwiYWxsb2MiLCJmaWxsIiwiZW5jb2RpbmciLCJjaGVja2VkIiwiYWxsb2NVbnNhZmVTbG93Iiwic3RyaW5nIiwiaXNFbmNvZGluZyIsImFjdHVhbCIsIndyaXRlIiwic2xpY2UiLCJmcm9tQXJyYXlMaWtlIiwiYnl0ZU9mZnNldCIsImlzQnVmZmVyIiwibGVuIiwiY29weSIsImJ1ZmZlciIsImlzbmFuIiwiYiIsIl9pc0J1ZmZlciIsImNvbXBhcmUiLCJhIiwieCIsInkiLCJNYXRoIiwibWluIiwiU3RyaW5nIiwidG9Mb3dlckNhc2UiLCJjb25jYXQiLCJsaXN0IiwicG9zIiwiYnVmIiwiaXNWaWV3IiwibG93ZXJlZENhc2UiLCJ1dGY4VG9CeXRlcyIsImJhc2U2NFRvQnl0ZXMiLCJzbG93VG9TdHJpbmciLCJzdGFydCIsImVuZCIsImhleFNsaWNlIiwidXRmOFNsaWNlIiwiYXNjaWlTbGljZSIsImxhdGluMVNsaWNlIiwiYmFzZTY0U2xpY2UiLCJ1dGYxNmxlU2xpY2UiLCJzd2FwIiwibiIsInN3YXAxNiIsInN3YXAzMiIsInN3YXA2NCIsImVxdWFscyIsImluc3BlY3QiLCJzdHIiLCJtYXgiLCJtYXRjaCIsImpvaW4iLCJ0YXJnZXQiLCJ0aGlzU3RhcnQiLCJ0aGlzRW5kIiwidGhpc0NvcHkiLCJ0YXJnZXRDb3B5IiwiYmlkaXJlY3Rpb25hbEluZGV4T2YiLCJ2YWwiLCJkaXIiLCJpc05hTiIsImFycmF5SW5kZXhPZiIsImluZGV4T2YiLCJsYXN0SW5kZXhPZiIsImluZGV4U2l6ZSIsImFyckxlbmd0aCIsInZhbExlbmd0aCIsInJlYWQiLCJyZWFkVUludDE2QkUiLCJmb3VuZEluZGV4IiwiZm91bmQiLCJqIiwiaW5jbHVkZXMiLCJoZXhXcml0ZSIsIm9mZnNldCIsIk51bWJlciIsInJlbWFpbmluZyIsInN0ckxlbiIsInBhcnNlZCIsInBhcnNlSW50Iiwic3Vic3RyIiwidXRmOFdyaXRlIiwiYmxpdEJ1ZmZlciIsImFzY2lpV3JpdGUiLCJhc2NpaVRvQnl0ZXMiLCJsYXRpbjFXcml0ZSIsImJhc2U2NFdyaXRlIiwidWNzMldyaXRlIiwidXRmMTZsZVRvQnl0ZXMiLCJpc0Zpbml0ZSIsInRvSlNPTiIsIl9hcnIiLCJmcm9tQnl0ZUFycmF5IiwicmVzIiwiZmlyc3RCeXRlIiwiY29kZVBvaW50IiwiYnl0ZXNQZXJTZXF1ZW5jZSIsInNlY29uZEJ5dGUiLCJ0aGlyZEJ5dGUiLCJmb3VydGhCeXRlIiwidGVtcENvZGVQb2ludCIsImRlY29kZUNvZGVQb2ludHNBcnJheSIsIk1BWF9BUkdVTUVOVFNfTEVOR1RIIiwiY29kZVBvaW50cyIsImZyb21DaGFyQ29kZSIsInJldCIsIm91dCIsInRvSGV4IiwiYnl0ZXMiLCJuZXdCdWYiLCJzbGljZUxlbiIsImNoZWNrT2Zmc2V0IiwiZXh0IiwicmVhZFVJbnRMRSIsIm5vQXNzZXJ0IiwibXVsIiwicmVhZFVJbnRCRSIsInJlYWRVSW50OCIsInJlYWRVSW50MTZMRSIsInJlYWRVSW50MzJMRSIsInJlYWRVSW50MzJCRSIsInJlYWRJbnRMRSIsInBvdyIsInJlYWRJbnRCRSIsInJlYWRJbnQ4IiwicmVhZEludDE2TEUiLCJyZWFkSW50MTZCRSIsInJlYWRJbnQzMkxFIiwicmVhZEludDMyQkUiLCJyZWFkRmxvYXRMRSIsInJlYWRGbG9hdEJFIiwicmVhZERvdWJsZUxFIiwicmVhZERvdWJsZUJFIiwiY2hlY2tJbnQiLCJ3cml0ZVVJbnRMRSIsIm1heEJ5dGVzIiwid3JpdGVVSW50QkUiLCJ3cml0ZVVJbnQ4IiwiZmxvb3IiLCJvYmplY3RXcml0ZVVJbnQxNiIsImxpdHRsZUVuZGlhbiIsIndyaXRlVUludDE2TEUiLCJ3cml0ZVVJbnQxNkJFIiwib2JqZWN0V3JpdGVVSW50MzIiLCJ3cml0ZVVJbnQzMkxFIiwid3JpdGVVSW50MzJCRSIsIndyaXRlSW50TEUiLCJsaW1pdCIsInN1YiIsIndyaXRlSW50QkUiLCJ3cml0ZUludDgiLCJ3cml0ZUludDE2TEUiLCJ3cml0ZUludDE2QkUiLCJ3cml0ZUludDMyTEUiLCJ3cml0ZUludDMyQkUiLCJjaGVja0lFRUU3NTQiLCJ3cml0ZUZsb2F0Iiwid3JpdGVGbG9hdExFIiwid3JpdGVGbG9hdEJFIiwid3JpdGVEb3VibGUiLCJ3cml0ZURvdWJsZUxFIiwid3JpdGVEb3VibGVCRSIsInRhcmdldFN0YXJ0IiwiY2hhckNvZGVBdCIsIklOVkFMSURfQkFTRTY0X1JFIiwiYmFzZTY0Y2xlYW4iLCJzdHJpbmd0cmltIiwicmVwbGFjZSIsInRyaW0iLCJ1bml0cyIsIkluZmluaXR5IiwibGVhZFN1cnJvZ2F0ZSIsImJ5dGVBcnJheSIsImhpIiwibG8iLCJ0b0J5dGVBcnJheSIsInNyYyIsImRzdCIsInBhdGhHZXR0ZXIiLCJwYXRoIiwicGF0aHMiLCJnZXRQYXRocyIsInBhdGhTdHJpbmciLCJyZWdleCIsIm1hdGNoZXMiLCJleGVjIiwiU2V0Iiwic3RhY2tDbGVhciIsInN0YWNrRGVsZXRlIiwic3RhY2tHZXQiLCJzdGFja0hhcyIsInN0YWNrU2V0IiwiU3RhY2siLCJiYXNlSW5kZXhPZiIsImFycmF5SW5jbHVkZXMiLCJhcnJheUluY2x1ZGVzV2l0aCIsImNvbXBhcmF0b3IiLCJhcnJheVB1c2giLCJpc0ZsYXR0ZW5hYmxlIiwiYmFzZUZsYXR0ZW4iLCJkZXB0aCIsInByZWRpY2F0ZSIsImNhc3RQYXRoIiwiYmFzZUdldCIsImJhc2VJc0VxdWFsRGVlcCIsImJhc2VJc0VxdWFsIiwib3RoZXIiLCJjdXN0b21pemVyIiwiYml0bWFzayIsIm92ZXJSZXN0Iiwic2V0VG9TdHJpbmciLCJiYXNlUmVzdCIsImZ1bmMiLCJiYXNlVW5hcnkiLCJzdHJpbmdUb1BhdGgiLCJhcnJheVNvbWUiLCJVTk9SREVSRURfQ09NUEFSRV9GTEFHIiwiUEFSVElBTF9DT01QQVJFX0ZMQUciLCJlcXVhbEFycmF5cyIsImVxdWFsRnVuYyIsImlzUGFydGlhbCIsIm90aExlbmd0aCIsInN0YWNrZWQiLCJzZWVuIiwiYXJyVmFsdWUiLCJvdGhWYWx1ZSIsImNvbXBhcmVkIiwib3RoSW5kZXgiLCJyZUlzVWludCIsImlzSW5kZXgiLCJpc1N0cmljdENvbXBhcmFibGUiLCJtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSIsInNyY1ZhbHVlIiwib3ZlckFyZyIsInRyYW5zZm9ybSIsImZ1bmNQcm90byIsImZ1bmNUb1N0cmluZyIsInRvU291cmNlIiwiaXNGdW5jdGlvbiIsImZ1bmNUYWciLCJnZW5UYWciLCJ0YWciLCJkZWNvZGUiLCJwYXJzZSIsImVuY29kZSIsInN0cmluZ2lmeSIsInNjRXJyb3JzIiwiUmVzcG9uc2UiLCJzb2NrZXQiLCJzZW50IiwiX3Jlc3BvbmQiLCJyZXNwb25zZURhdGEiLCJzZW5kIiwicmlkIiwiY2FsbGJhY2siLCJTQ0NoYW5uZWwiLCJBdXRoRW5naW5lIiwiZm9ybWF0dGVyIiwiU0NUcmFuc3BvcnQiLCJxdWVyeXN0cmluZyIsIkxpbmtlZExpc3QiLCJpc0Jyb3dzZXIiLCJ3aW5kb3ciLCJTQ1NvY2tldCIsIm9wdHMiLCJzdGF0ZSIsIkNMT1NFRCIsImF1dGhTdGF0ZSIsIlBFTkRJTkciLCJzaWduZWRBdXRoVG9rZW4iLCJhdXRoVG9rZW4iLCJwZW5kaW5nUmVjb25uZWN0IiwicGVuZGluZ1JlY29ubmVjdFRpbWVvdXQiLCJwZW5kaW5nQ29ubmVjdENhbGxiYWNrIiwiY29ubmVjdFRpbWVvdXQiLCJhY2tUaW1lb3V0IiwiY2hhbm5lbFByZWZpeCIsImRpc2Nvbm5lY3RPblVubG9hZCIsInBpbmdUaW1lb3V0IiwibWF4VGltZW91dCIsInZlcmlmeUR1cmF0aW9uIiwicHJvcGVydHlOYW1lIiwiX2xvY2FsRXZlbnRzIiwiY29ubmVjdEF0dGVtcHRzIiwiX2VtaXRCdWZmZXIiLCJfY2hhbm5lbHMiLCJvcHRpb25zIiwiX2NpZCIsImNhbGxJZEdlbmVyYXRvciIsIl9jYWxsSWRHZW5lcmF0b3IiLCJhdXRvUmVjb25uZWN0IiwiYXV0b1JlY29ubmVjdE9wdGlvbnMiLCJyZWNvbm5lY3RPcHRpb25zIiwiaW5pdGlhbERlbGF5IiwicmFuZG9tbmVzcyIsIm11bHRpcGxpZXIiLCJtYXhEZWxheSIsInN1YnNjcmlwdGlvblJldHJ5T3B0aW9ucyIsImF1dGhFbmdpbmUiLCJhdXRoIiwiY29kZWNFbmdpbmUiLCJjb2RlYyIsInF1ZXJ5IiwiY29ubmVjdCIsIl9jaGFubmVsRW1pdHRlciIsInVubG9hZEhhbmRsZXIiLCJkaXNjb25uZWN0IiwiYXR0YWNoRXZlbnQiLCJhZGRFdmVudExpc3RlbmVyIiwiQ09OTkVDVElORyIsIk9QRU4iLCJBVVRIRU5USUNBVEVEIiwiVU5BVVRIRU5USUNBVEVEIiwiaWdub3JlU3RhdHVzZXMiLCJlcnJvclN0YXR1c2VzIiwiX3ByaXZhdGVFdmVudEhhbmRsZXJNYXAiLCJ1bmRlY29yYXRlZENoYW5uZWxOYW1lIiwiX3VuZGVjb3JhdGVDaGFubmVsTmFtZSIsImNoYW5uZWwiLCJpc1N1YnNjcmliZWQiLCJfdHJpZ2dlckNoYW5uZWxVbnN1YnNjcmliZSIsInJlc3BvbnNlIiwidHJpZ2dlckF1dGhlbnRpY2F0ZSIsIl9vblNDRXJyb3IiLCJfY2hhbmdlVG9BdXRoZW50aWNhdGVkU3RhdGUiLCJ0b2tlbiIsInNhdmVUb2tlbiIsImF1dGhUb2tlbk5hbWUiLCJyZW1vdmVUb2tlbiIsIm9sZFRva2VuIiwiX2NoYW5nZVRvVW5hdXRoZW50aWNhdGVkU3RhdGUiLCJ0cmFuc3BvcnQiLCJjbG9zZSIsImdldFN0YXRlIiwiZ2V0Qnl0ZXNSZWNlaXZlZCIsImRlYXV0aGVudGljYXRlIiwib3BlbiIsImNsZWFyVGltZW91dCIsIl9yZWNvbm5lY3RUaW1lb3V0UmVmIiwiX2NoYW5nZVRvUGVuZGluZ0F1dGhTdGF0ZSIsIm9mZiIsIm9uIiwic3RhdHVzIiwiX29uU0NPcGVuIiwiX29uU0NDbG9zZSIsIl9vblNDRXZlbnQiLCJyZWNvbm5lY3QiLCJwYWNrZXQiLCJvbGRTdGF0ZSIsInN0YXRlQ2hhbmdlRGF0YSIsIm5ld1N0YXRlIiwiX2V4dHJhY3RBdXRoVG9rZW5EYXRhIiwicHJvY2Vzc1BlbmRpbmdTdWJzY3JpcHRpb25zIiwiZGVjb2RlQmFzZTY0IiwiZW5jb2RlZFN0cmluZyIsImRlY29kZWRTdHJpbmciLCJhdG9iIiwiZW5jb2RlQmFzZTY0IiwiYnRvYSIsInRva2VuUGFydHMiLCJzcGxpdCIsImVuY29kZWRUb2tlbkRhdGEiLCJ0b2tlbkRhdGEiLCJKU09OIiwiZ2V0QXV0aFRva2VuIiwiZ2V0U2lnbmVkQXV0aFRva2VuIiwiYXV0aGVudGljYXRlIiwiYXV0aFN0YXR1cyIsImF1dGhFcnJvciIsImlzQXV0aGVudGljYXRlZCIsIl90cnlSZWNvbm5lY3QiLCJleHBvbmVudCIsInRpbWVvdXQiLCJpbml0aWFsVGltZW91dCIsInJvdW5kIiwicmFuZG9tIiwic2V0VGltZW91dCIsImF1dG9Qcm9jZXNzU3Vic2NyaXB0aW9ucyIsIl9mbHVzaEVtaXRCdWZmZXIiLCJsaXN0ZW5lcnMiLCJfc3VzcGVuZFN1YnNjcmlwdGlvbnMiLCJjaGFubmVsTmFtZSIsIlNVQlNDUklCRUQiLCJVTlNVQlNDUklCRUQiLCJvcGVuQWJvcnQiLCJmYWlsdXJlTWVzc2FnZSIsImhhbmRsZXIiLCJjdXJyZW50Tm9kZSIsImhlYWQiLCJuZXh0Tm9kZSIsIm5leHQiLCJldmVudE9iamVjdCIsImRldGFjaCIsImVtaXRSYXciLCJfaGFuZGxlRXZlbnRBY2tUaW1lb3V0IiwiZXZlbnROb2RlIiwiX2VtaXQiLCJJdGVtIiwiYXBwZW5kIiwicHVibGlzaCIsInB1YkRhdGEiLCJfZGVjb3JhdGVDaGFubmVsTmFtZSIsIl90cmlnZ2VyQ2hhbm5lbFN1YnNjcmliZSIsInN1YnNjcmlwdGlvbk9wdGlvbnMiLCJfdHJpZ2dlckNoYW5uZWxTdWJzY3JpYmVGYWlsIiwibWVldHNBdXRoUmVxdWlyZW1lbnRzIiwid2FpdEZvckF1dGgiLCJfY2FuY2VsUGVuZGluZ1N1YnNjcmliZUNhbGxiYWNrIiwiX3BlbmRpbmdTdWJzY3JpcHRpb25DaWQiLCJjYW5jZWxQZW5kaW5nUmVzcG9uc2UiLCJkZWNvcmF0ZWRDaGFubmVsTmFtZSIsIl90cnlTdWJzY3JpYmUiLCJub1RpbWVvdXQiLCJzdWJzY3JpYmUiLCJzZXRPcHRpb25zIiwiX3RyeVVuc3Vic2NyaWJlIiwidW5zdWJzY3JpYmUiLCJjdXJyZW50Q2hhbm5lbCIsImRlc3Ryb3lDaGFubmVsIiwidW53YXRjaCIsInN1YnNjcmlwdGlvbnMiLCJpbmNsdWRlUGVuZGluZyIsInN1YnMiLCJpbmNsdWRlQ2hhbm5lbCIsIndhdGNoIiwicmVtb3ZlTGlzdGVuZXIiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJ3YXRjaGVycyIsIndlYnBhY2tQb2x5ZmlsbCIsImRlcHJlY2F0ZSIsImNoaWxkcmVuIiwiY29uZmlndXJlU3RvcmUiLCJfcmVkdXhEZXZ0b29sc0luc3RydW1lbnQiLCJfcmVkdXhEZXZ0b29sc0luc3RydW1lbnQyIiwic3Vic2NyaWJlciIsImRlZmF1bHRTb2NrZXRPcHRpb25zIiwic2VjdXJlIiwiaG9zdG5hbWUiLCJwb3J0IiwiX3R5cGVvZiIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJfZXh0ZW5kcyIsImFzc2lnbiIsInNvdXJjZSIsImRldlRvb2xzIiwicHJlRGV2VG9vbHMiLCJfanNhbiIsIl9zb2NrZXRjbHVzdGVyQ2xpZW50IiwiX3NvY2tldGNsdXN0ZXJDbGllbnQyIiwiX2NvbmZpZ3VyZVN0b3JlIiwiX2NvbmZpZ3VyZVN0b3JlMiIsIl9jb25zdGFudHMiLCJfcmVhY3ROYXRpdmUiLCJfcmVtb3RlZGV2VXRpbHMiLCJfY2F0Y2hFcnJvcnMiLCJfY2F0Y2hFcnJvcnMyIiwiX2ZpbHRlcnMiLCJpbnN0YW5jZUlkIiwiaW5zdGFuY2VOYW1lIiwic29ja2V0T3B0aW9ucyIsInN0b3JlIiwibGFzdEFjdGlvbiIsImZpbHRlcnMiLCJpc0V4Y2VzcyIsImlzTW9uaXRvcmVkIiwic3RhcnRlZCIsInN0YXJ0T24iLCJzdG9wT24iLCJzZW5kT24iLCJzZW5kT25FcnJvciIsInNlbmRUbyIsImxhc3RFcnJvck1zZyIsImxvY2tlZCIsInBhdXNlZCIsImFjdGlvbkNyZWF0b3JzIiwic3RhdGVTYW5pdGl6ZXIiLCJhY3Rpb25TYW5pdGl6ZXIiLCJnZXRMaWZ0ZWRTdGF0ZSIsImZpbHRlclN0YWdlZEFjdGlvbnMiLCJsaWZ0ZWRTdG9yZSIsImZldGNoIiwibWV0aG9kIiwiaGVhZGVycyIsImJvZHkiLCJwYXlsb2FkIiwiY2F0Y2giLCJjb25zb2xlIiwibG9nIiwicmVsYXkiLCJhY3Rpb24iLCJuZXh0QWN0aW9uSWQiLCJpc0ZpbHRlcmVkIiwiZmlsdGVyU3RhdGUiLCJkaXNwYXRjaFJlbW90ZWx5IiwiZXZhbEFjdGlvbiIsImRpc3BhdGNoIiwiaGFuZGxlTWVzc2FnZXMiLCJuZXh0TGlmdGVkU3RhdGUiLCJhc3luYyIsImZuIiwic2VuZEVycm9yIiwiZXJyb3JBY3Rpb24iLCJzdHIyYXJyYXkiLCJpbml0IiwiZ2V0QWN0aW9uc0FycmF5IiwibG9naW4iLCJzdG9wIiwia2VlcENvbm5lY3RlZCIsImNoZWNrRm9yUmVkdWNlckVycm9ycyIsImxpZnRlZFN0YXRlIiwiY29tcHV0ZWRTdGF0ZXMiLCJjdXJyZW50U3RhdGVJbmRleCIsIm1vbml0b3JSZWR1Y2VyIiwiaGFuZGxlQ2hhbmdlIiwibWF4QWdlIiwibGlmdGVkQWN0aW9uIiwiYWN0aW9uc0J5SWQiLCJzdGFnZWRBY3Rpb25JZHMiLCJpc1BhdXNlZCIsImlzTG9ja2VkIiwiZ2V0SG9zdEZvclJOIiwicmVhbHRpbWUiLCJmIiwicmVkdWNlciIsImluaXRpYWxTdGF0ZSIsInNob3VsZENhdGNoRXJyb3JzIiwic2hvdWxkSG90UmVsb2FkIiwic2hvdWxkUmVjb3JkQ2hhbmdlcyIsInNob3VsZFN0YXJ0TG9ja2VkIiwicGF1c2VBY3Rpb25UeXBlIiwiY3JlYXRlU3RvcmUiLCJwcmVsb2FkZWRTdGF0ZSIsImVuaGFuY2VyIiwidXBkYXRlU3RvcmUiLCJuZXdTdG9yZSIsIl9sZW4iLCJmdW5jcyIsIl9rZXkiLCJyZWR1Y2VSaWdodCIsImNvbXBvc2VkIiwiX19mYkJhdGNoZWRCcmlkZ2UiLCJSZW1vdGVNb2R1bGVzIiwiQW5kcm9pZENvbnN0YW50cyIsIl93aW5kb3ckX19mYkJhdGNoZWRCciIsIlNlcnZlckhvc3QiLCJfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyIsImZyZWVFeHBvcnRzIiwiZnJlZU1vZHVsZSIsIkludmFsaWRDaGFyYWN0ZXJFcnJvciIsIlRBQkxFIiwiUkVHRVhfU1BBQ0VfQ0hBUkFDVEVSUyIsImlucHV0IiwiYml0Q291bnRlciIsImJpdFN0b3JhZ2UiLCJvdXRwdXQiLCJwb3NpdGlvbiIsImNoYXJBdCIsInBhZGRpbmciLCJkIiwibm9kZVR5cGUiLCJsb29rdXAiLCJyZXZMb29rdXAiLCJBcnIiLCJwbGFjZUhvbGRlcnNDb3VudCIsImI2NCIsImwiLCJ0bXAiLCJwbGFjZUhvbGRlcnMiLCJMIiwidHJpcGxldFRvQmFzZTY0IiwibnVtIiwiZW5jb2RlQ2h1bmsiLCJ1aW50OCIsImV4dHJhQnl0ZXMiLCJwYXJ0cyIsIm1heENodW5rTGVuZ3RoIiwibGVuMiIsIm1peGluIiwiX2NhbGxiYWNrcyIsIm9uY2UiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiY2FsbGJhY2tzIiwiY2IiLCJzcGxpY2UiLCJhcmdzIiwiaGFzTGlzdGVuZXJzIiwib2JqZWN0cyIsImRlcmV6IiwibnUiLCJCb29sZWFuIiwiRGF0ZSIsIlJlZ0V4cCIsIiRyZWYiLCJyZXRyb2N5Y2xlIiwiJCIsInB4IiwicmV6IiwiaXRlbSIsImV2YWwiLCJHZXRQYXJhbXMiLCJwYXR0ZXJuQ29tbWVudHMiLCJwYXR0ZXJuQXJndW1lbnRzIiwiZnVuY1N0cmluZyIsImlzTEUiLCJtTGVuIiwibkJ5dGVzIiwiZUxlbiIsImVNYXgiLCJlQmlhcyIsIm5CaXRzIiwicyIsIk5hTiIsInJ0IiwiYWJzIiwiTE4yIiwidXRpbHMiLCJyZXBsYWNlciIsIl92YWx1ZSIsImRhdGUiLCIkanNhbiIsImdldFRpbWUiLCJnZXRSZWdleEZsYWdzIiwic3RyaW5naWZ5RnVuY3Rpb24iLCJuZXh0UGF0aCIsInJlc3RvcmUiLCJzcGFjZSIsIl9vcHRpb25zIiwiZGVjeWNsZWQiLCJ0ZXh0IiwicmV2aXZlciIsIm5lZWRzUmV0cm9jeWNsZSIsImZsYWdzIiwiaWdub3JlQ2FzZSIsIm11bHRpbGluZSIsImN1c3RvbVRvU3RyaW5nIiwicmVzdCIsImNvbW1hIiwid2FybiIsImVycm9yTWVzc2FnZSIsIkxpc3QiLCJMaXN0UHJvdG90eXBlIiwib2YiLCJpdGVtcyIsInRhaWwiLCJ0b0FycmF5IiwicHJlcGVuZCIsIkxpc3RJdGVtIiwiTGlzdEl0ZW1Qcm90b3R5cGUiLCJwcmV2IiwiRGF0YVZpZXciLCJoYXNoQ2xlYXIiLCJoYXNoRGVsZXRlIiwiaGFzaEdldCIsImhhc2hIYXMiLCJoYXNoU2V0IiwiSGFzaCIsIlByb21pc2UiLCJXZWFrTWFwIiwidGhpc0FyZyIsImJhc2VUaW1lcyIsImluaGVyaXRlZCIsInNraXBJbmRleGVzIiwiYXJyYXlNYXAiLCJpdGVyYXRlZSIsImJhc2VBc3NpZ25WYWx1ZSIsIkxBUkdFX0FSUkFZX1NJWkUiLCJiYXNlRGlmZmVyZW5jZSIsImlzQ29tbW9uIiwidmFsdWVzTGVuZ3RoIiwib3V0ZXIiLCJjb21wdXRlZCIsInZhbHVlc0luZGV4IiwiYmFzZUZpbmRJbmRleCIsImZyb21JbmRleCIsImZyb21SaWdodCIsImNyZWF0ZUJhc2VGb3IiLCJiYXNlRm9yIiwiYmFzZUZvck93biIsImJhc2VHZXRUYWciLCJiYXNlSGFzSW4iLCJiYXNlSXNOYU4iLCJzdHJpY3RJbmRleE9mIiwiZXF1YWxCeVRhZyIsImVxdWFsT2JqZWN0cyIsImdldFRhZyIsImlzVHlwZWRBcnJheSIsImFycmF5VGFnIiwib2JqZWN0VGFnIiwib2JqSXNBcnIiLCJvdGhJc0FyciIsIm9ialRhZyIsIm90aFRhZyIsIm9iaklzT2JqIiwib3RoSXNPYmoiLCJpc1NhbWVUYWciLCJvYmpJc1dyYXBwZWQiLCJvdGhJc1dyYXBwZWQiLCJvYmpVbndyYXBwZWQiLCJvdGhVbndyYXBwZWQiLCJiYXNlSXNNYXRjaCIsIm1hdGNoRGF0YSIsIm5vQ3VzdG9taXplciIsIm9ialZhbHVlIiwiaXNNYXNrZWQiLCJyZVJlZ0V4cENoYXIiLCJyZUlzSG9zdEN0b3IiLCJyZUlzTmF0aXZlIiwicGF0dGVybiIsImJvb2xUYWciLCJkYXRlVGFnIiwiZXJyb3JUYWciLCJtYXBUYWciLCJudW1iZXJUYWciLCJyZWdleHBUYWciLCJzZXRUYWciLCJzdHJpbmdUYWciLCJ3ZWFrTWFwVGFnIiwiYXJyYXlCdWZmZXJUYWciLCJkYXRhVmlld1RhZyIsImZsb2F0MzJUYWciLCJmbG9hdDY0VGFnIiwiaW50OFRhZyIsImludDE2VGFnIiwiaW50MzJUYWciLCJ1aW50OFRhZyIsInVpbnQ4Q2xhbXBlZFRhZyIsInVpbnQxNlRhZyIsInVpbnQzMlRhZyIsInR5cGVkQXJyYXlUYWdzIiwiYmFzZUlzVHlwZWRBcnJheSIsImJhc2VNYXRjaGVzIiwiYmFzZU1hdGNoZXNQcm9wZXJ0eSIsInByb3BlcnR5IiwiYmFzZUl0ZXJhdGVlIiwiaXNQcm90b3R5cGUiLCJuYXRpdmVLZXlzIiwiZ2V0TWF0Y2hEYXRhIiwiaGFzSW4iLCJiYXNlUHJvcGVydHkiLCJiYXNlUHJvcGVydHlEZWVwIiwiY29uc3RhbnQiLCJuYXRpdmVEZWZpbmVQcm9wZXJ0eSIsImJhc2VTZXRUb1N0cmluZyIsInN5bWJvbFByb3RvIiwic3ltYm9sVG9TdHJpbmciLCJiYXNlVG9TdHJpbmciLCJjcmVhdGVTZXQiLCJiYXNlVW5pcSIsInNlZW5JbmRleCIsImNvcmVKc0RhdGEiLCJrZXlzRnVuYyIsIml0ZXJhYmxlIiwicHJvcHMiLCJub29wIiwibWFwVG9BcnJheSIsInN5bWJvbFZhbHVlT2YiLCJ2YWx1ZU9mIiwiY29udmVydCIsIm9ialByb3BzIiwib2JqTGVuZ3RoIiwib3RoUHJvcHMiLCJza2lwQ3RvciIsIm9iakN0b3IiLCJvdGhDdG9yIiwiZ2V0UHJvdG90eXBlIiwiZ2V0UHJvdG90eXBlT2YiLCJwcm9taXNlVGFnIiwiZGF0YVZpZXdDdG9yU3RyaW5nIiwibWFwQ3RvclN0cmluZyIsInByb21pc2VDdG9yU3RyaW5nIiwic2V0Q3RvclN0cmluZyIsIndlYWtNYXBDdG9yU3RyaW5nIiwicmVzb2x2ZSIsIkN0b3IiLCJjdG9yU3RyaW5nIiwiaGFzUGF0aCIsImhhc0Z1bmMiLCJIQVNIX1VOREVGSU5FRCIsInNwcmVhZGFibGVTeW1ib2wiLCJpc0NvbmNhdFNwcmVhZGFibGUiLCJtYXNrU3JjS2V5IiwidWlkIiwiSUVfUFJPVE8iLCJwcm90byIsImFycmF5UHJvdG8iLCJsYXN0SW5kZXgiLCJwb3AiLCJtZW1vaXplIiwiTUFYX01FTU9JWkVfU0laRSIsIm1lbW9pemVDYXBwZWQiLCJtb2R1bGVFeHBvcnRzIiwiZnJlZVByb2Nlc3MiLCJwcm9jZXNzIiwibm9kZVV0aWwiLCJiaW5kaW5nIiwibmF0aXZlTWF4Iiwib3RoZXJBcmdzIiwic2hvcnRPdXQiLCJIT1RfQ09VTlQiLCJIT1RfU1BBTiIsIm5hdGl2ZU5vdyIsIm5vdyIsImNvdW50IiwibGFzdENhbGxlZCIsInN0YW1wIiwicGFpcnMiLCJyZUxlYWRpbmdEb3QiLCJyZVByb3BOYW1lIiwicmVFc2NhcGVDaGFyIiwibnVtYmVyIiwicXVvdGUiLCJkaWZmZXJlbmNlIiwiZGVmYXVsdFZhbHVlIiwib2JqZWN0Q3RvclN0cmluZyIsImlzUGxhaW5PYmplY3QiLCJub2RlSXNUeXBlZEFycmF5IiwibWFwVmFsdWVzIiwiRlVOQ19FUlJPUl9URVhUIiwicmVzb2x2ZXIiLCJtZW1vaXplZCIsIkNhY2hlIiwidW5pb24iLCJhcnJheXMiLCJwcm9wIiwicXMiLCJzZXAiLCJyZWdleHAiLCJtYXhLZXlzIiwiaWR4Iiwia3N0ciIsInZzdHIiLCJrIiwidiIsImRlY29kZVVSSUNvbXBvbmVudCIsInN0cmluZ2lmeVByaW1pdGl2ZSIsImtzIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiSU5JVF9BQ1RJT04iLCJBY3Rpb25DcmVhdG9ycyIsIkFjdGlvblR5cGVzIiwibGlmdEFjdGlvbiIsImxpZnRSZWR1Y2VyV2l0aCIsInVubGlmdFN0YXRlIiwidW5saWZ0U3RvcmUiLCJpbnN0cnVtZW50IiwiX2RpZmZlcmVuY2UiLCJfZGlmZmVyZW5jZTIiLCJfdW5pb24iLCJfdW5pb24yIiwiX2lzUGxhaW5PYmplY3QiLCJfaXNQbGFpbk9iamVjdDIiLCJfc3ltYm9sT2JzZXJ2YWJsZSIsIl9zeW1ib2xPYnNlcnZhYmxlMiIsIlBFUkZPUk1fQUNUSU9OIiwiUkVTRVQiLCJST0xMQkFDSyIsIkNPTU1JVCIsIlNXRUVQIiwiVE9HR0xFX0FDVElPTiIsIlNFVF9BQ1RJT05TX0FDVElWRSIsIkpVTVBfVE9fU1RBVEUiLCJJTVBPUlRfU1RBVEUiLCJMT0NLX0NIQU5HRVMiLCJQQVVTRV9SRUNPUkRJTkciLCJwZXJmb3JtQWN0aW9uIiwidGltZXN0YW1wIiwicmVzZXQiLCJyb2xsYmFjayIsImNvbW1pdCIsInN3ZWVwIiwidG9nZ2xlQWN0aW9uIiwic2V0QWN0aW9uc0FjdGl2ZSIsImFjdGl2ZSIsImp1bXBUb1N0YXRlIiwiaW1wb3J0U3RhdGUiLCJub1JlY29tcHV0ZSIsImxvY2tDaGFuZ2VzIiwicGF1c2VSZWNvcmRpbmciLCJjb21wdXRlV2l0aFRyeUNhdGNoIiwibmV4dFN0YXRlIiwibmV4dEVycm9yIiwiY2hyb21lIiwiY29tcHV0ZU5leHRFbnRyeSIsInJlY29tcHV0ZVN0YXRlcyIsIm1pbkludmFsaWRhdGVkU3RhdGVJbmRleCIsImNvbW1pdHRlZFN0YXRlIiwic2tpcHBlZEFjdGlvbklkcyIsIm5leHRDb21wdXRlZFN0YXRlcyIsImFjdGlvbklkIiwicHJldmlvdXNFbnRyeSIsInByZXZpb3VzU3RhdGUiLCJzaG91bGRTa2lwIiwiaW5pdGlhbENvbW1pdHRlZFN0YXRlIiwiaW5pdGlhbExpZnRlZFN0YXRlIiwibW9uaXRvclN0YXRlIiwiX3JlZiIsImNvbW1pdEV4Y2Vzc0FjdGlvbnMiLCJleGNlc3MiLCJpZHNUb0RlbGV0ZSIsImZpbHRlciIsImNvbXB1dGVQYXVzZWRBY3Rpb24iLCJzaG91bGRJbml0IiwiX2V4dGVuZHMyIiwiY29tcHV0ZWRTdGF0ZSIsIl9yZXQiLCJhY3Rpb25JZHMiLCJfbGlmdGVkQWN0aW9uJG5leHRMaWYiLCJsaWZ0UmVkdWNlciIsIl9leHRlbmRzMyIsImxhc3REZWZpbmVkU3RhdGUiLCJyZXBsYWNlUmVkdWNlciIsIm5leHRSZWR1Y2VyIiwib2JzZXJ2ZXIiLCJvYnNlcnZlU3RhdGUiLCJyIiwiY2F0Y2hFcnJvcnMiLCJFUlJPUiIsIm9uZXJyb3IiLCJ1cmwiLCJsaW5lTm8iLCJjb2x1bW5ObyIsIkVycm9yVXRpbHMiLCJzZXRHbG9iYWxIYW5kbGVyIiwiaXNGYXRhbCIsImJlZm9yZVJlbW90ZWRldiIsImJpbmQiLCJzb3VyY2VVUkwiLCJsaW5lIiwiY29sdW1uIiwiYXJyVG9SZWdleCIsIl9tYXBWYWx1ZXMiLCJfbWFwVmFsdWVzMiIsImZpbHRlckFjdGlvbnMiLCJhY3Rpb25zRmlsdGVyIiwiZmlsdGVyU3RhdGVzIiwic3RhdGVzRmlsdGVyIiwid2hpdGVsaXN0IiwiYmxhY2tsaXN0IiwiZmlsdGVyZWRTdGFnZWRBY3Rpb25JZHMiLCJmaWx0ZXJlZENvbXB1dGVkU3RhdGVzIiwibG9jYWxGaWx0ZXIiLCJmaWx0ZXJlZEFjdGlvbnNCeUlkIiwiZ2VuZXJhdGVJZCIsImdldE1ldGhvZHMiLCJldmFsTWV0aG9kIiwiX2dldFBhcmFtcyIsIl9nZXRQYXJhbXMyIiwiZmxhdFRyZWUiLCJuYW1lc3BhY2UiLCJmdW5jdGlvbnMiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwiaW50ZXJwcmV0QXJnIiwiZXZhbEFyZ3MiLCJpbkFyZ3MiLCJyZXN0QXJncyIsImFjdGlvbkNyZWF0b3IiLCJzZWxlY3RlZCIsImNsaWVudCIsImRlc3Ryb3kiLCJGIiwibyIsImJhc2U2NENoYXJzIiwiYXJyYXlCdWZmZXJUb0Jhc2U2NCIsImFycmF5YnVmZmVyIiwic3Vic3RyaW5nIiwiYmluYXJ5VG9CYXNlNjRSZXBsYWNlciIsInJlaHlkcmF0ZWRCdWZmZXIiLCJTQ1NvY2tldENyZWF0b3IiLCJ2ZXJzaW9uIiwiX2ludGVybmFsU3RvcmFnZSIsIl9pc0xvY2FsU3RvcmFnZUVuYWJsZWQiLCJsb2NhbFN0b3JhZ2UiLCJzZXRJdGVtIiwicmVtb3ZlSXRlbSIsImxvYWRUb2tlbiIsImdldEl0ZW0iLCJfY29ubmVjdGlvbnMiLCJnZXRNdWx0aXBsZXhJZCIsInByb3RvY29sUHJlZml4IiwicXVlcnlTdHJpbmciLCJxdWVyeUFycmF5IiwicXVlcnlNYXAiLCJ0aW1lc3RhbXBSZXF1ZXN0cyIsInRpbWVzdGFtcFBhcmFtIiwiYmluYXJ5VHlwZSIsIm11bHRpcGxleCIsIm11bHRpcGxleElkIiwiV2ViU29ja2V0IiwiX3BpbmdUaW1lb3V0VGlja2VyIiwiX2NhbGxiYWNrTWFwIiwidXJpIiwic2NoZW1hIiwid3NTb2NrZXQiLCJvbm9wZW4iLCJfb25PcGVuIiwib25jbG9zZSIsIl9vbkNsb3NlIiwicmVhc29uIiwib25tZXNzYWdlIiwiX29uTWVzc2FnZSIsIl9jb25uZWN0VGltZW91dFJlZiIsIl9yZXNldFBpbmdUaW1lb3V0IiwiX2hhbmRzaGFrZSIsIl9vbkVycm9yIiwiZm9yY2UiLCJyZWFkeVN0YXRlIiwiY2lkIiwicmVoeWRyYXRlZEVycm9yIiwiYnl0ZXNSZWNlaXZlZCIsInNpbXBsZUV2ZW50T2JqZWN0Iiwic2VuZE9iamVjdCIsImZvcm1hdEVycm9yIiwid3MiLCJwcm90b2NvbHMiLCJ3eCIsIm9uU29ja2V0T3BlbiIsImhhbmRsZVNvY2tldE9wZW4iLCJvblNvY2tldENsb3NlIiwiaGFuZGxlU29ja2V0Q2xvc2UiLCJvblNvY2tldE1lc3NhZ2UiLCJoYW5kbGVNZXNzYWdlIiwib25Tb2NrZXRFcnJvciIsImhhbmRsZVNvY2tldEVycm9yIiwiY29ubmVjdFNvY2tldCIsImhhbmRsZVNvY2tldE9wZW5MYXRlciIsImhhbmRsZVNvY2tldE9wZW5MYXRlckhhbmRsZXIiLCJoYW5kbGVNZXNzYWdlTGF0ZXIiLCJoYW5kbGVNZXNzYWdlTGF0ZXJIYW5kbGVyIiwiaGFuZGxlU29ja2V0RXJyb3JMYXRlciIsImhhbmRsZVNvY2tldEVycm9yTGF0ZXJIYW5kbGVyIiwiaGFuZGxlU29ja2V0Q2xvc2VMYXRlciIsImhhbmRsZVNvY2tldENsb3NlTGF0ZXJIYW5kbGVyIiwic2VuZFNvY2tldE1lc3NhZ2UiLCJmYWlsIiwiY2xvc2VTb2NrZXQiLCJzeW1ib2xPYnNlcnZhYmxlUG9ueWZpbGwiLCJvYnNlcnZhYmxlIl0sIm1hcHBpbmdzIjoiOzs7O0FBQUEsQ0FBRSxTQUFTQSxnQ0FBVCxDQUEyQ0MsSUFBM0MsRUFBaURDLE9BQWpELEVBQTJEO0FBQ3pELFFBQUssUUFBT0MsTUFBUCwwQ0FBT0EsTUFBUCxPQUFrQixRQUF2QixFQUNJQSxPQUFPQyxPQUFQLEdBQWlCRixTQUFqQixDQURKLEtBRUssSUFBSyxPQUFPRyxNQUFQLEtBQWtCLFVBQWxCLElBQWdDQSxPQUFPQyxHQUE1QyxFQUNERCxPQUFRLEVBQVIsRUFBWUgsT0FBWixFQURDLEtBRUEsSUFBSyxR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bHMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIoIGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKCByb290LCBmYWN0b3J5ICkge1xuICAgIGlmICggdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgKVxuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcbiAgICBlbHNlIGlmICggdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kIClcbiAgICAgICAgZGVmaW5lKCBbXSwgZmFjdG9yeSApO1xuICAgIGVsc2UgaWYgKCB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgKVxuICAgICAgICBleHBvcnRzW1wicmVtb3RlLXJlZHV4LWRldnRvb2xzXCJdID0gZmFjdG9yeSgpO1xuICAgIGVsc2VcbiAgICAgICAgcm9vdFtcInJlbW90ZS1yZWR1eC1kZXZ0b29sc1wiXSA9IGZhY3RvcnkoKTtcbn0gKSggdGhpcywgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAvKioqKioqLyAoIGZ1bmN0aW9uICggbW9kdWxlcyApIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyggbW9kdWxlSWQgKSB7XG5cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZiAoIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdIClcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fSxcbi8qKioqKiovIFx0XHRcdGlkOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGxvYWRlZDogZmFsc2VcbiAgICAgICAgICAgICAgICAvKioqKioqL1xufTtcblxuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwoIG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fICk7XG5cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiAgICAgICAgICAgIC8qKioqKiovXG59XG5cblxuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oIDAgKTtcbiAgICAgICAgLyoqKioqKi9cbn0gKVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovKCBbXG4vKiAwICovXG4vKioqLyBmdW5jdGlvbiAoIG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyApIHtcblxuICAgICAgICAgICAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgICAgICAgICAgIGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgZXhwb3J0cy5jb21wb3NlV2l0aERldlRvb2xzID0gZXhwb3J0cy5kZWZhdWx0ID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICAgICAgdmFyIF9kZXZUb29scyA9IF9fd2VicGFja19yZXF1aXJlX18oIDU0ICk7XG5cbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIGV4cG9ydHMsICdjb21wb3NlV2l0aERldlRvb2xzJywge1xuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfZGV2VG9vbHMuY29tcG9zZVdpdGhEZXZUb29scztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gKTtcblxuICAgICAgICAgICAgICAgIHZhciBfZGV2VG9vbHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdCggX2RldlRvb2xzICk7XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KCBvYmogKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbiAgICAgICAgICAgICAgICBleHBvcnRzLmRlZmF1bHQgPSBfZGV2VG9vbHMyLmRlZmF1bHQ7XG5cbiAgICAgICAgICAgICAgICAvKioqL1xufSxcbi8qIDEgKi9cbi8qKiovIGZ1bmN0aW9uICggbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGZyZWVHbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCAzOSApO1xuXG4gICAgICAgICAgICAgICAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbiAgICAgICAgICAgICAgICB2YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuICAgICAgICAgICAgICAgIC8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xuICAgICAgICAgICAgICAgIHZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbiggJ3JldHVybiB0aGlzJyApKCk7XG5cbiAgICAgICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IHJvb3Q7XG5cblxuICAgICAgICAgICAgICAgIC8qKiovXG59LFxuLyogMiAqL1xuLyoqKi8gZnVuY3Rpb24gKCBtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18gKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgYmFzZUlzTmF0aXZlID0gX193ZWJwYWNrX3JlcXVpcmVfXyggOTAgKSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0VmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCAxMTAgKTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZ2V0TmF0aXZlKCBvYmplY3QsIGtleSApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gZ2V0VmFsdWUoIG9iamVjdCwga2V5ICk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBiYXNlSXNOYXRpdmUoIHZhbHVlICkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGdldE5hdGl2ZTtcblxuXG4gICAgICAgICAgICAgICAgLyoqKi9cbn0sXG4vKiAzICovXG4vKioqLyBmdW5jdGlvbiAoIG1vZHVsZSwgZXhwb3J0cyApIHtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgICAgICogQG1lbWJlck9mIF9cbiAgICAgICAgICAgICAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgICAgICAgICAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gICAgICAgICAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICAgICAgICAgICAgICAgICAqIC8vID0+IHRydWVcbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogXy5pc0FycmF5KCdhYmMnKTtcbiAgICAgICAgICAgICAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogXy5pc0FycmF5KF8ubm9vcCk7XG4gICAgICAgICAgICAgICAgICogLy8gPT4gZmFsc2VcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbiAgICAgICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXk7XG5cblxuICAgICAgICAgICAgICAgIC8qKiovXG59LFxuLyogNCAqL1xuLyoqKi8gZnVuY3Rpb24gKCBtb2R1bGUsIGV4cG9ydHMgKSB7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAgICAgICAgICAgICAgICAgKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgICAgICogQG1lbWJlck9mIF9cbiAgICAgICAgICAgICAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgICAgICAgICAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gICAgICAgICAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAgICAgICAgICAgICAgICAgKiAvLyA9PiB0cnVlXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICAgICAgICAgICAgICAgICAqIC8vID0+IHRydWVcbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gICAgICAgICAgICAgICAgICogLy8gPT4gZmFsc2VcbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICAgICAgICAgICAgICAgICAqIC8vID0+IGZhbHNlXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gaXNPYmplY3RMaWtlKCB2YWx1ZSApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gaXNPYmplY3RMaWtlO1xuXG5cbiAgICAgICAgICAgICAgICAvKioqL1xufSxcbi8qIDUgKi9cbi8qKiovIGZ1bmN0aW9uICggbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGxpc3RDYWNoZUNsZWFyID0gX193ZWJwYWNrX3JlcXVpcmVfXyggMTIxICksXG4gICAgICAgICAgICAgICAgICAgIGxpc3RDYWNoZURlbGV0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oIDEyMiApLFxuICAgICAgICAgICAgICAgICAgICBsaXN0Q2FjaGVHZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCAxMjMgKSxcbiAgICAgICAgICAgICAgICAgICAgbGlzdENhY2hlSGFzID0gX193ZWJwYWNrX3JlcXVpcmVfXyggMTI0ICksXG4gICAgICAgICAgICAgICAgICAgIGxpc3RDYWNoZVNldCA9IF9fd2VicGFja19yZXF1aXJlX18oIDEyNSApO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQ3JlYXRlcyBhbiBsaXN0IGNhY2hlIG9iamVjdC5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gTGlzdENhY2hlKCBlbnRyaWVzICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IGVudHJpZXMgPyBlbnRyaWVzLmxlbmd0aCA6IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoICsraW5kZXggPCBsZW5ndGggKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0KCBlbnRyeVswXSwgZW50cnlbMV0gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEFkZCBtZXRob2RzIHRvIGBMaXN0Q2FjaGVgLlxuICAgICAgICAgICAgICAgIExpc3RDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBsaXN0Q2FjaGVDbGVhcjtcbiAgICAgICAgICAgICAgICBMaXN0Q2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IGxpc3RDYWNoZURlbGV0ZTtcbiAgICAgICAgICAgICAgICBMaXN0Q2FjaGUucHJvdG90eXBlLmdldCA9IGxpc3RDYWNoZUdldDtcbiAgICAgICAgICAgICAgICBMaXN0Q2FjaGUucHJvdG90eXBlLmhhcyA9IGxpc3RDYWNoZUhhcztcbiAgICAgICAgICAgICAgICBMaXN0Q2FjaGUucHJvdG90eXBlLnNldCA9IGxpc3RDYWNoZVNldDtcblxuICAgICAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gTGlzdENhY2hlO1xuXG5cbiAgICAgICAgICAgICAgICAvKioqL1xufSxcbi8qIDYgKi9cbi8qKiovIGZ1bmN0aW9uICggbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGVxID0gX193ZWJwYWNrX3JlcXVpcmVfXyggNDUgKTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBga2V5YCBpcyBmb3VuZCBpbiBgYXJyYXlgIG9mIGtleS12YWx1ZSBwYWlycy5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHsqfSBrZXkgVGhlIGtleSB0byBzZWFyY2ggZm9yLlxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gYXNzb2NJbmRleE9mKCBhcnJheSwga2V5ICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIGxlbmd0aC0tICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBlcSggYXJyYXlbbGVuZ3RoXVswXSwga2V5ICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBhc3NvY0luZGV4T2Y7XG5cblxuICAgICAgICAgICAgICAgIC8qKiovXG59LFxuLyogNyAqL1xuLyoqKi8gZnVuY3Rpb24gKCBtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18gKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgaXNLZXlhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyggMTE4ICk7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBHZXRzIHRoZSBkYXRhIGZvciBgbWFwYC5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIHF1ZXJ5LlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHJlZmVyZW5jZSBrZXkuXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hcCBkYXRhLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGdldE1hcERhdGEoIG1hcCwga2V5ICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IG1hcC5fX2RhdGFfXztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzS2V5YWJsZSgga2V5IClcbiAgICAgICAgICAgICAgICAgICAgICAgID8gZGF0YVt0eXBlb2Yga2V5ID09ICdzdHJpbmcnID8gJ3N0cmluZycgOiAnaGFzaCddXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGRhdGEubWFwO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gZ2V0TWFwRGF0YTtcblxuXG4gICAgICAgICAgICAgICAgLyoqKi9cbn0sXG4vKiA4ICovXG4vKioqLyBmdW5jdGlvbiAoIG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyApIHtcblxuICAgICAgICAgICAgICAgIHZhciBpc0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyggMyApLFxuICAgICAgICAgICAgICAgICAgICBpc1N5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oIDIzICk7XG5cbiAgICAgICAgICAgICAgICAvKiogVXNlZCB0byBtYXRjaCBwcm9wZXJ0eSBuYW1lcyB3aXRoaW4gcHJvcGVydHkgcGF0aHMuICovXG4gICAgICAgICAgICAgICAgdmFyIHJlSXNEZWVwUHJvcCA9IC9cXC58XFxbKD86W15bXFxdXSp8KFtcIiddKSg/Oig/IVxcMSlbXlxcXFxdfFxcXFwuKSo/XFwxKVxcXS8sXG4gICAgICAgICAgICAgICAgICAgIHJlSXNQbGFpblByb3AgPSAvXlxcdyokLztcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSBhbmQgbm90IGEgcHJvcGVydHkgcGF0aC5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBpc0tleSggdmFsdWUsIG9iamVjdCApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBpc0FycmF5KCB2YWx1ZSApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPT0gbnVsbCB8fCBpc1N5bWJvbCggdmFsdWUgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZUlzUGxhaW5Qcm9wLnRlc3QoIHZhbHVlICkgfHwgIXJlSXNEZWVwUHJvcC50ZXN0KCB2YWx1ZSApIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAoIG9iamVjdCAhPSBudWxsICYmIHZhbHVlIGluIE9iamVjdCggb2JqZWN0ICkgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGlzS2V5O1xuXG5cbiAgICAgICAgICAgICAgICAvKioqL1xufSxcbi8qIDkgKi9cbi8qKiovIGZ1bmN0aW9uICggbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGdldE5hdGl2ZSA9IF9fd2VicGFja19yZXF1aXJlX18oIDIgKTtcblxuICAgICAgICAgICAgICAgIC8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbiAgICAgICAgICAgICAgICB2YXIgbmF0aXZlQ3JlYXRlID0gZ2V0TmF0aXZlKCBPYmplY3QsICdjcmVhdGUnICk7XG5cbiAgICAgICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IG5hdGl2ZUNyZWF0ZTtcblxuXG4gICAgICAgICAgICAgICAgLyoqKi9cbn0sXG4vKiAxMCAqL1xuLyoqKi8gZnVuY3Rpb24gKCBtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18gKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgaXNTeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCAyMyApO1xuXG4gICAgICAgICAgICAgICAgLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG4gICAgICAgICAgICAgICAgdmFyIElORklOSVRZID0gMSAvIDA7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIGtleSBpZiBpdCdzIG5vdCBhIHN0cmluZyBvciBzeW1ib2wuXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge3N0cmluZ3xzeW1ib2x9IFJldHVybnMgdGhlIGtleS5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiB0b0tleSggdmFsdWUgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggdHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IGlzU3ltYm9sKCB2YWx1ZSApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSAoIHZhbHVlICsgJycgKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICggcmVzdWx0ID09ICcwJyAmJiAoIDEgLyB2YWx1ZSApID09IC1JTkZJTklUWSApID8gJy0wJyA6IHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IHRvS2V5O1xuXG5cbiAgICAgICAgICAgICAgICAvKioqL1xufSxcbi8qIDExICovXG4vKioqLyBmdW5jdGlvbiAoIG1vZHVsZSwgZXhwb3J0cyApIHtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICAgICAgICAgICAgICAgICAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAgICAgICAgICAgICAgICAgKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgICAgICogQG1lbWJlck9mIF9cbiAgICAgICAgICAgICAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgICAgICAgICAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAgICAgICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBfLmlzT2JqZWN0KHt9KTtcbiAgICAgICAgICAgICAgICAgKiAvLyA9PiB0cnVlXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gICAgICAgICAgICAgICAgICogLy8gPT4gdHJ1ZVxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogXy5pc09iamVjdChfLm5vb3ApO1xuICAgICAgICAgICAgICAgICAqIC8vID0+IHRydWVcbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIF8uaXNPYmplY3QobnVsbCk7XG4gICAgICAgICAgICAgICAgICogLy8gPT4gZmFsc2VcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBpc09iamVjdCggdmFsdWUgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAoIHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdDtcblxuXG4gICAgICAgICAgICAgICAgLyoqKi9cbn0sXG4vKiAxMiAqL1xuLyoqKi8gZnVuY3Rpb24gKCBtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18gKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgRW1pdHRlciA9IF9fd2VicGFja19yZXF1aXJlX18oIDU4ICk7XG5cbiAgICAgICAgICAgICAgICBpZiAoICFPYmplY3QuY3JlYXRlICkge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuY3JlYXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXyggMTY3ICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIFNDRW1pdHRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgRW1pdHRlci5jYWxsKCB0aGlzICk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIFNDRW1pdHRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBFbWl0dGVyLnByb3RvdHlwZSApO1xuXG4gICAgICAgICAgICAgICAgU0NFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gKCBldmVudCApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBldmVudCA9PSAnZXJyb3InICYmIHRoaXMuZG9tYWluICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRW1pdCB0aGUgZXJyb3Igb24gdGhlIGRvbWFpbiBpZiBpdCBoYXMgb25lLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qb3llbnQvbm9kZS9ibG9iL2VmNDM0NDMxMWUxOWE0ZjczYzAzMTUwODI1MmIyMTcxMmIyMmZlOGEvbGliL2V2ZW50cy5qcyNMNzgtODVcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVyciA9IGFyZ3VtZW50c1sxXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhZXJyICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVyciA9IG5ldyBFcnJvciggJ1VuY2F1Z2h0LCB1bnNwZWNpZmllZCBcImVycm9yXCIgZXZlbnQuJyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyLmRvbWFpbkVtaXR0ZXIgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyLmRvbWFpbiA9IHRoaXMuZG9tYWluO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyLmRvbWFpblRocm93biA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kb21haW4uZW1pdCggJ2Vycm9yJywgZXJyICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgRW1pdHRlci5wcm90b3R5cGUuZW1pdC5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzLlNDRW1pdHRlciA9IFNDRW1pdHRlcjtcblxuXG4gICAgICAgICAgICAgICAgLyoqKi9cbn0sXG4vKiAxMyAqL1xuLyoqKi8gZnVuY3Rpb24gKCBtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18gKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgZ2V0TmF0aXZlID0gX193ZWJwYWNrX3JlcXVpcmVfXyggMiApLFxuICAgICAgICAgICAgICAgICAgICByb290ID0gX193ZWJwYWNrX3JlcXVpcmVfXyggMSApO1xuXG4gICAgICAgICAgICAgICAgLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xuICAgICAgICAgICAgICAgIHZhciBNYXAgPSBnZXROYXRpdmUoIHJvb3QsICdNYXAnICk7XG5cbiAgICAgICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IE1hcDtcblxuXG4gICAgICAgICAgICAgICAgLyoqKi9cbn0sXG4vKiAxNCAqL1xuLyoqKi8gZnVuY3Rpb24gKCBtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18gKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgbWFwQ2FjaGVDbGVhciA9IF9fd2VicGFja19yZXF1aXJlX18oIDEyNiApLFxuICAgICAgICAgICAgICAgICAgICBtYXBDYWNoZURlbGV0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oIDEyNyApLFxuICAgICAgICAgICAgICAgICAgICBtYXBDYWNoZUdldCA9IF9fd2VicGFja19yZXF1aXJlX18oIDEyOCApLFxuICAgICAgICAgICAgICAgICAgICBtYXBDYWNoZUhhcyA9IF9fd2VicGFja19yZXF1aXJlX18oIDEyOSApLFxuICAgICAgICAgICAgICAgICAgICBtYXBDYWNoZVNldCA9IF9fd2VicGFja19yZXF1aXJlX18oIDEzMCApO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQ3JlYXRlcyBhIG1hcCBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBNYXBDYWNoZSggZW50cmllcyApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSBlbnRyaWVzID8gZW50cmllcy5sZW5ndGggOiAwO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCArK2luZGV4IDwgbGVuZ3RoICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldCggZW50cnlbMF0sIGVudHJ5WzFdICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgbWV0aG9kcyB0byBgTWFwQ2FjaGVgLlxuICAgICAgICAgICAgICAgIE1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG4gICAgICAgICAgICAgICAgTWFwQ2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IG1hcENhY2hlRGVsZXRlO1xuICAgICAgICAgICAgICAgIE1hcENhY2hlLnByb3RvdHlwZS5nZXQgPSBtYXBDYWNoZUdldDtcbiAgICAgICAgICAgICAgICBNYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XG4gICAgICAgICAgICAgICAgTWFwQ2FjaGUucHJvdG90eXBlLnNldCA9IG1hcENhY2hlU2V0O1xuXG4gICAgICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBNYXBDYWNoZTtcblxuXG4gICAgICAgICAgICAgICAgLyoqKi9cbn0sXG4vKiAxNSAqL1xuLyoqKi8gZnVuY3Rpb24gKCBtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18gKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgTWFwQ2FjaGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCAxNCApLFxuICAgICAgICAgICAgICAgICAgICBzZXRDYWNoZUFkZCA9IF9fd2VicGFja19yZXF1aXJlX18oIDEzNyApLFxuICAgICAgICAgICAgICAgICAgICBzZXRDYWNoZUhhcyA9IF9fd2VicGFja19yZXF1aXJlX18oIDEzOCApO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBDcmVhdGVzIGFuIGFycmF5IGNhY2hlIG9iamVjdCB0byBzdG9yZSB1bmlxdWUgdmFsdWVzLlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGNhY2hlLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIFNldENhY2hlKCB2YWx1ZXMgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gdmFsdWVzID8gdmFsdWVzLmxlbmd0aCA6IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCArK2luZGV4IDwgbGVuZ3RoICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGQoIHZhbHVlc1tpbmRleF0gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEFkZCBtZXRob2RzIHRvIGBTZXRDYWNoZWAuXG4gICAgICAgICAgICAgICAgU2V0Q2FjaGUucHJvdG90eXBlLmFkZCA9IFNldENhY2hlLnByb3RvdHlwZS5wdXNoID0gc2V0Q2FjaGVBZGQ7XG4gICAgICAgICAgICAgICAgU2V0Q2FjaGUucHJvdG90eXBlLmhhcyA9IHNldENhY2hlSGFzO1xuXG4gICAgICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBTZXRDYWNoZTtcblxuXG4gICAgICAgICAgICAgICAgLyoqKi9cbn0sXG4vKiAxNiAqL1xuLyoqKi8gZnVuY3Rpb24gKCBtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18gKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgcm9vdCA9IF9fd2VicGFja19yZXF1aXJlX18oIDEgKTtcblxuICAgICAgICAgICAgICAgIC8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xuICAgICAgICAgICAgICAgIHZhciBTeW1ib2wgPSByb290LlN5bWJvbDtcblxuICAgICAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gU3ltYm9sO1xuXG5cbiAgICAgICAgICAgICAgICAvKioqL1xufSxcbi8qIDE3ICovXG4vKioqLyBmdW5jdGlvbiAoIG1vZHVsZSwgZXhwb3J0cyApIHtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIENoZWNrcyBpZiBhIGBjYWNoZWAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNhY2hlIFRoZSBjYWNoZSB0byBxdWVyeS5cbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gY2FjaGVIYXMoIGNhY2hlLCBrZXkgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZS5oYXMoIGtleSApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gY2FjaGVIYXM7XG5cblxuICAgICAgICAgICAgICAgIC8qKiovXG59LFxuLyogMTggKi9cbi8qKiovIGZ1bmN0aW9uICggbW9kdWxlLCBleHBvcnRzICkge1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQ29udmVydHMgYHNldGAgdG8gYW4gYXJyYXkgb2YgaXRzIHZhbHVlcy5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHNldCBUaGUgc2V0IHRvIGNvbnZlcnQuXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB2YWx1ZXMuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gc2V0VG9BcnJheSggc2V0ICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IEFycmF5KCBzZXQuc2l6ZSApO1xuXG4gICAgICAgICAgICAgICAgICAgIHNldC5mb3JFYWNoKCBmdW5jdGlvbiAoIHZhbHVlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0WysraW5kZXhdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH0gKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IHNldFRvQXJyYXk7XG5cblxuICAgICAgICAgICAgICAgIC8qKiovXG59LFxuLyogMTkgKi9cbi8qKiovIGZ1bmN0aW9uICggbW9kdWxlLCBleHBvcnRzICkge1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgaXQgcmVjZWl2ZXMuXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgICAgICogQHNpbmNlIDAuMS4wXG4gICAgICAgICAgICAgICAgICogQG1lbWJlck9mIF9cbiAgICAgICAgICAgICAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55IHZhbHVlLlxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG4gICAgICAgICAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogY29uc29sZS5sb2coXy5pZGVudGl0eShvYmplY3QpID09PSBvYmplY3QpO1xuICAgICAgICAgICAgICAgICAqIC8vID0+IHRydWVcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBpZGVudGl0eSggdmFsdWUgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGlkZW50aXR5O1xuXG5cbiAgICAgICAgICAgICAgICAvKioqL1xufSxcbi8qIDIwICovXG4vKioqLyBmdW5jdGlvbiAoIG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyApIHtcblxuICAgICAgICAgICAgICAgIHZhciBpc0FycmF5TGlrZU9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oIDIxICk7XG5cbiAgICAgICAgICAgICAgICAvKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG4gICAgICAgICAgICAgICAgdmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJztcblxuICAgICAgICAgICAgICAgIC8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbiAgICAgICAgICAgICAgICB2YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4gICAgICAgICAgICAgICAgLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG4gICAgICAgICAgICAgICAgdmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gICAgICAgICAgICAgICAgICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gICAgICAgICAgICAgICAgICogb2YgdmFsdWVzLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHZhciBvYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4gICAgICAgICAgICAgICAgLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG4gICAgICAgICAgICAgICAgdmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICAgICAgICAgICAgICogQHNpbmNlIDAuMS4wXG4gICAgICAgICAgICAgICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gICAgICAgICAgICAgICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgICAgICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAgICAgICAgICAgICAgICAgKiAvLyA9PiB0cnVlXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gICAgICAgICAgICAgICAgICogLy8gPT4gZmFsc2VcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBpc0FyZ3VtZW50cyggdmFsdWUgKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNhZmFyaSA4LjEgbWFrZXMgYGFyZ3VtZW50cy5jYWxsZWVgIGVudW1lcmFibGUgaW4gc3RyaWN0IG1vZGUuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpc0FycmF5TGlrZU9iamVjdCggdmFsdWUgKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKCB2YWx1ZSwgJ2NhbGxlZScgKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKCAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCggdmFsdWUsICdjYWxsZWUnICkgfHwgb2JqZWN0VG9TdHJpbmcuY2FsbCggdmFsdWUgKSA9PSBhcmdzVGFnICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBpc0FyZ3VtZW50cztcblxuXG4gICAgICAgICAgICAgICAgLyoqKi9cbn0sXG4vKiAyMSAqL1xuLyoqKi8gZnVuY3Rpb24gKCBtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18gKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgaXNBcnJheUxpa2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCA0NiApLFxuICAgICAgICAgICAgICAgICAgICBpc09iamVjdExpa2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCA0ICk7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmlzQXJyYXlMaWtlYCBleGNlcHQgdGhhdCBpdCBhbHNvIGNoZWNrcyBpZiBgdmFsdWVgXG4gICAgICAgICAgICAgICAgICogaXMgYW4gb2JqZWN0LlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICAgICAgICAgICAgICogQHNpbmNlIDQuMC4wXG4gICAgICAgICAgICAgICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheS1saWtlIG9iamVjdCxcbiAgICAgICAgICAgICAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAgICAgICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBfLmlzQXJyYXlMaWtlT2JqZWN0KFsxLCAyLCAzXSk7XG4gICAgICAgICAgICAgICAgICogLy8gPT4gdHJ1ZVxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogXy5pc0FycmF5TGlrZU9iamVjdChkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICAgKiAvLyA9PiB0cnVlXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBfLmlzQXJyYXlMaWtlT2JqZWN0KCdhYmMnKTtcbiAgICAgICAgICAgICAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogXy5pc0FycmF5TGlrZU9iamVjdChfLm5vb3ApO1xuICAgICAgICAgICAgICAgICAqIC8vID0+IGZhbHNlXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gaXNBcnJheUxpa2VPYmplY3QoIHZhbHVlICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNPYmplY3RMaWtlKCB2YWx1ZSApICYmIGlzQXJyYXlMaWtlKCB2YWx1ZSApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gaXNBcnJheUxpa2VPYmplY3Q7XG5cblxuICAgICAgICAgICAgICAgIC8qKiovXG59LFxuLyogMjIgKi9cbi8qKiovIGZ1bmN0aW9uICggbW9kdWxlLCBleHBvcnRzICkge1xuXG4gICAgICAgICAgICAgICAgLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG4gICAgICAgICAgICAgICAgdmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gICAgICAgICAgICAgICAgICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAgICAgICAgICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAgICAgICAgICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAgICAgICAgICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogXy5pc0xlbmd0aCgzKTtcbiAgICAgICAgICAgICAgICAgKiAvLyA9PiB0cnVlXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAgICAgICAgICAgICAqIC8vID0+IGZhbHNlXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcbiAgICAgICAgICAgICAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogXy5pc0xlbmd0aCgnMycpO1xuICAgICAgICAgICAgICAgICAqIC8vID0+IGZhbHNlXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gaXNMZW5ndGgoIHZhbHVlICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBpc0xlbmd0aDtcblxuXG4gICAgICAgICAgICAgICAgLyoqKi9cbn0sXG4vKiAyMyAqL1xuLyoqKi8gZnVuY3Rpb24gKCBtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18gKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgaXNPYmplY3RMaWtlID0gX193ZWJwYWNrX3JlcXVpcmVfXyggNCApO1xuXG4gICAgICAgICAgICAgICAgLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xuICAgICAgICAgICAgICAgIHZhciBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxuICAgICAgICAgICAgICAgIC8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbiAgICAgICAgICAgICAgICB2YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogVXNlZCB0byByZXNvbHZlIHRoZVxuICAgICAgICAgICAgICAgICAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICAgICAgICAgICAgICAgICAqIG9mIHZhbHVlcy5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB2YXIgb2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICAgICAgICAgICAgICogQHNpbmNlIDQuMC4wXG4gICAgICAgICAgICAgICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuICAgICAgICAgICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gICAgICAgICAgICAgICAgICogLy8gPT4gdHJ1ZVxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gICAgICAgICAgICAgICAgICogLy8gPT4gZmFsc2VcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBpc1N5bWJvbCggdmFsdWUgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICggaXNPYmplY3RMaWtlKCB2YWx1ZSApICYmIG9iamVjdFRvU3RyaW5nLmNhbGwoIHZhbHVlICkgPT0gc3ltYm9sVGFnICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBpc1N5bWJvbDtcblxuXG4gICAgICAgICAgICAgICAgLyoqKi9cbn0sXG4vKiAyNCAqL1xuLyoqKi8gZnVuY3Rpb24gKCBtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18gKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgYXJyYXlMaWtlS2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oIDc1ICksXG4gICAgICAgICAgICAgICAgICAgIGJhc2VLZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyggOTMgKSxcbiAgICAgICAgICAgICAgICAgICAgaXNBcnJheUxpa2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCA0NiApO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy4gU2VlIHRoZVxuICAgICAgICAgICAgICAgICAqIFtFUyBzcGVjXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAgICAgICAgICAgICAgICAgKiBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAgICAgICAgICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICAgICAgICAgICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAgICAgICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICAgICAgICAgICAgICogICB0aGlzLmEgPSAxO1xuICAgICAgICAgICAgICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgICAgICAgICAgICAgKiB9XG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogXy5rZXlzKG5ldyBGb28pO1xuICAgICAgICAgICAgICAgICAqIC8vID0+IFsnYScsICdiJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIF8ua2V5cygnaGknKTtcbiAgICAgICAgICAgICAgICAgKiAvLyA9PiBbJzAnLCAnMSddXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24ga2V5cyggb2JqZWN0ICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNBcnJheUxpa2UoIG9iamVjdCApID8gYXJyYXlMaWtlS2V5cyggb2JqZWN0ICkgOiBiYXNlS2V5cyggb2JqZWN0ICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBrZXlzO1xuXG5cbiAgICAgICAgICAgICAgICAvKioqL1xufSxcbi8qIDI1ICovXG4vKioqLyBmdW5jdGlvbiAoIG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyApIHtcblxuICAgICAgICAgICAgICAgIHZhciBjeWNsZSA9IF9fd2VicGFja19yZXF1aXJlX18oIDU5ICk7XG5cbiAgICAgICAgICAgICAgICB2YXIgaXNTdHJpY3QgPSAoIGZ1bmN0aW9uICgpIHsgcmV0dXJuICF0aGlzOyB9ICkoKTtcblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIEF1dGhUb2tlbkV4cGlyZWRFcnJvciggbWVzc2FnZSwgZXhwaXJ5ICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlICYmICFpc1N0cmljdCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKCB0aGlzLCBhcmd1bWVudHMuY2FsbGVlICk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YWNrID0gKCBuZXcgRXJyb3IoKSApLnN0YWNrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmFtZSA9ICdBdXRoVG9rZW5FeHBpcmVkRXJyb3InO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmV4cGlyeSA9IGV4cGlyeTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIEF1dGhUb2tlbkV4cGlyZWRFcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBFcnJvci5wcm90b3R5cGUgKTtcblxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gQXV0aFRva2VuSW52YWxpZEVycm9yKCBtZXNzYWdlICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlICYmICFpc1N0cmljdCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKCB0aGlzLCBhcmd1bWVudHMuY2FsbGVlICk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YWNrID0gKCBuZXcgRXJyb3IoKSApLnN0YWNrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmFtZSA9ICdBdXRoVG9rZW5JbnZhbGlkRXJyb3InO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgQXV0aFRva2VuSW52YWxpZEVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEVycm9yLnByb3RvdHlwZSApO1xuXG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBTaWxlbnRNaWRkbGV3YXJlQmxvY2tlZEVycm9yKCBtZXNzYWdlLCB0eXBlICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlICYmICFpc1N0cmljdCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKCB0aGlzLCBhcmd1bWVudHMuY2FsbGVlICk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YWNrID0gKCBuZXcgRXJyb3IoKSApLnN0YWNrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmFtZSA9ICdTaWxlbnRNaWRkbGV3YXJlQmxvY2tlZEVycm9yJztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFNpbGVudE1pZGRsZXdhcmVCbG9ja2VkRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggRXJyb3IucHJvdG90eXBlICk7XG5cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIEludmFsaWRBY3Rpb25FcnJvciggbWVzc2FnZSApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSAmJiAhaXNTdHJpY3QgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSggdGhpcywgYXJndW1lbnRzLmNhbGxlZSApO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFjayA9ICggbmV3IEVycm9yKCkgKS5zdGFjaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm5hbWUgPSAnSW52YWxpZEFjdGlvbkVycm9yJztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIEludmFsaWRBY3Rpb25FcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBFcnJvci5wcm90b3R5cGUgKTtcblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIEludmFsaWRBcmd1bWVudHNFcnJvciggbWVzc2FnZSApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSAmJiAhaXNTdHJpY3QgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSggdGhpcywgYXJndW1lbnRzLmNhbGxlZSApO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFjayA9ICggbmV3IEVycm9yKCkgKS5zdGFjaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm5hbWUgPSAnSW52YWxpZEFyZ3VtZW50c0Vycm9yJztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIEludmFsaWRBcmd1bWVudHNFcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBFcnJvci5wcm90b3R5cGUgKTtcblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIEludmFsaWRPcHRpb25zRXJyb3IoIG1lc3NhZ2UgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UgJiYgIWlzU3RyaWN0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoIHRoaXMsIGFyZ3VtZW50cy5jYWxsZWUgKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sgPSAoIG5ldyBFcnJvcigpICkuc3RhY2s7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uYW1lID0gJ0ludmFsaWRPcHRpb25zRXJyb3InO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgSW52YWxpZE9wdGlvbnNFcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBFcnJvci5wcm90b3R5cGUgKTtcblxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gSW52YWxpZE1lc3NhZ2VFcnJvciggbWVzc2FnZSApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSAmJiAhaXNTdHJpY3QgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSggdGhpcywgYXJndW1lbnRzLmNhbGxlZSApO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFjayA9ICggbmV3IEVycm9yKCkgKS5zdGFjaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm5hbWUgPSAnSW52YWxpZE1lc3NhZ2VFcnJvcic7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBJbnZhbGlkTWVzc2FnZUVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEVycm9yLnByb3RvdHlwZSApO1xuXG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBTb2NrZXRQcm90b2NvbEVycm9yKCBtZXNzYWdlLCBjb2RlICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlICYmICFpc1N0cmljdCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKCB0aGlzLCBhcmd1bWVudHMuY2FsbGVlICk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YWNrID0gKCBuZXcgRXJyb3IoKSApLnN0YWNrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmFtZSA9ICdTb2NrZXRQcm90b2NvbEVycm9yJztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFNvY2tldFByb3RvY29sRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggRXJyb3IucHJvdG90eXBlICk7XG5cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIFNlcnZlclByb3RvY29sRXJyb3IoIG1lc3NhZ2UgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UgJiYgIWlzU3RyaWN0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoIHRoaXMsIGFyZ3VtZW50cy5jYWxsZWUgKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sgPSAoIG5ldyBFcnJvcigpICkuc3RhY2s7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uYW1lID0gJ1NlcnZlclByb3RvY29sRXJyb3InO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgU2VydmVyUHJvdG9jb2xFcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBFcnJvci5wcm90b3R5cGUgKTtcblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIEhUVFBTZXJ2ZXJFcnJvciggbWVzc2FnZSApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSAmJiAhaXNTdHJpY3QgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSggdGhpcywgYXJndW1lbnRzLmNhbGxlZSApO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFjayA9ICggbmV3IEVycm9yKCkgKS5zdGFjaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm5hbWUgPSAnSFRUUFNlcnZlckVycm9yJztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIEhUVFBTZXJ2ZXJFcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBFcnJvci5wcm90b3R5cGUgKTtcblxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gUmVzb3VyY2VMaW1pdEVycm9yKCBtZXNzYWdlICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlICYmICFpc1N0cmljdCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKCB0aGlzLCBhcmd1bWVudHMuY2FsbGVlICk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YWNrID0gKCBuZXcgRXJyb3IoKSApLnN0YWNrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmFtZSA9ICdSZXNvdXJjZUxpbWl0RXJyb3InO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgUmVzb3VyY2VMaW1pdEVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEVycm9yLnByb3RvdHlwZSApO1xuXG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBUaW1lb3V0RXJyb3IoIG1lc3NhZ2UgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UgJiYgIWlzU3RyaWN0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoIHRoaXMsIGFyZ3VtZW50cy5jYWxsZWUgKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sgPSAoIG5ldyBFcnJvcigpICkuc3RhY2s7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uYW1lID0gJ1RpbWVvdXRFcnJvcic7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBUaW1lb3V0RXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggRXJyb3IucHJvdG90eXBlICk7XG5cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIEJyb2tlckVycm9yKCBtZXNzYWdlICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlICYmICFpc1N0cmljdCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKCB0aGlzLCBhcmd1bWVudHMuY2FsbGVlICk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YWNrID0gKCBuZXcgRXJyb3IoKSApLnN0YWNrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmFtZSA9ICdCcm9rZXJFcnJvcic7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBCcm9rZXJFcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBFcnJvci5wcm90b3R5cGUgKTtcblxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gUHJvY2Vzc0V4aXRFcnJvciggbWVzc2FnZSwgY29kZSApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSAmJiAhaXNTdHJpY3QgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSggdGhpcywgYXJndW1lbnRzLmNhbGxlZSApO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFjayA9ICggbmV3IEVycm9yKCkgKS5zdGFjaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm5hbWUgPSAnUHJvY2Vzc0V4aXRFcnJvcic7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBQcm9jZXNzRXhpdEVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEVycm9yLnByb3RvdHlwZSApO1xuXG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBVbmtub3duRXJyb3IoIG1lc3NhZ2UgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UgJiYgIWlzU3RyaWN0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoIHRoaXMsIGFyZ3VtZW50cy5jYWxsZWUgKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sgPSAoIG5ldyBFcnJvcigpICkuc3RhY2s7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uYW1lID0gJ1Vua25vd25FcnJvcic7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBVbmtub3duRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggRXJyb3IucHJvdG90eXBlICk7XG5cblxuICAgICAgICAgICAgICAgIC8vIEV4cG9zZSBhbGwgZXJyb3IgdHlwZXNcblxuICAgICAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICAgICAgICAgICAgICBBdXRoVG9rZW5FeHBpcmVkRXJyb3I6IEF1dGhUb2tlbkV4cGlyZWRFcnJvcixcbiAgICAgICAgICAgICAgICAgICAgQXV0aFRva2VuSW52YWxpZEVycm9yOiBBdXRoVG9rZW5JbnZhbGlkRXJyb3IsXG4gICAgICAgICAgICAgICAgICAgIFNpbGVudE1pZGRsZXdhcmVCbG9ja2VkRXJyb3I6IFNpbGVudE1pZGRsZXdhcmVCbG9ja2VkRXJyb3IsXG4gICAgICAgICAgICAgICAgICAgIEludmFsaWRBY3Rpb25FcnJvcjogSW52YWxpZEFjdGlvbkVycm9yLFxuICAgICAgICAgICAgICAgICAgICBJbnZhbGlkQXJndW1lbnRzRXJyb3I6IEludmFsaWRBcmd1bWVudHNFcnJvcixcbiAgICAgICAgICAgICAgICAgICAgSW52YWxpZE9wdGlvbnNFcnJvcjogSW52YWxpZE9wdGlvbnNFcnJvcixcbiAgICAgICAgICAgICAgICAgICAgSW52YWxpZE1lc3NhZ2VFcnJvcjogSW52YWxpZE1lc3NhZ2VFcnJvcixcbiAgICAgICAgICAgICAgICAgICAgU29ja2V0UHJvdG9jb2xFcnJvcjogU29ja2V0UHJvdG9jb2xFcnJvcixcbiAgICAgICAgICAgICAgICAgICAgU2VydmVyUHJvdG9jb2xFcnJvcjogU2VydmVyUHJvdG9jb2xFcnJvcixcbiAgICAgICAgICAgICAgICAgICAgSFRUUFNlcnZlckVycm9yOiBIVFRQU2VydmVyRXJyb3IsXG4gICAgICAgICAgICAgICAgICAgIFJlc291cmNlTGltaXRFcnJvcjogUmVzb3VyY2VMaW1pdEVycm9yLFxuICAgICAgICAgICAgICAgICAgICBUaW1lb3V0RXJyb3I6IFRpbWVvdXRFcnJvcixcbiAgICAgICAgICAgICAgICAgICAgQnJva2VyRXJyb3I6IEJyb2tlckVycm9yLFxuICAgICAgICAgICAgICAgICAgICBQcm9jZXNzRXhpdEVycm9yOiBQcm9jZXNzRXhpdEVycm9yLFxuICAgICAgICAgICAgICAgICAgICBVbmtub3duRXJyb3I6IFVua25vd25FcnJvclxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBtb2R1bGUuZXhwb3J0cy5zb2NrZXRQcm90b2NvbEVycm9yU3RhdHVzZXMgPSB7XG4gICAgICAgICAgICAgICAgICAgIDEwMDE6ICdTb2NrZXQgd2FzIGRpc2Nvbm5lY3RlZCcsXG4gICAgICAgICAgICAgICAgICAgIDEwMDI6ICdBIFdlYlNvY2tldCBwcm90b2NvbCBlcnJvciB3YXMgZW5jb3VudGVyZWQnLFxuICAgICAgICAgICAgICAgICAgICAxMDAzOiAnU2VydmVyIHRlcm1pbmF0ZWQgc29ja2V0IGJlY2F1c2UgaXQgcmVjZWl2ZWQgaW52YWxpZCBkYXRhJyxcbiAgICAgICAgICAgICAgICAgICAgMTAwNTogJ1NvY2tldCBjbG9zZWQgd2l0aG91dCBzdGF0dXMgY29kZScsXG4gICAgICAgICAgICAgICAgICAgIDEwMDY6ICdTb2NrZXQgaHVuZyB1cCcsXG4gICAgICAgICAgICAgICAgICAgIDEwMDc6ICdNZXNzYWdlIGZvcm1hdCB3YXMgaW5jb3JyZWN0JyxcbiAgICAgICAgICAgICAgICAgICAgMTAwODogJ0VuY291bnRlcmVkIGEgcG9saWN5IHZpb2xhdGlvbicsXG4gICAgICAgICAgICAgICAgICAgIDEwMDk6ICdNZXNzYWdlIHdhcyB0b28gYmlnIHRvIHByb2Nlc3MnLFxuICAgICAgICAgICAgICAgICAgICAxMDEwOiAnQ2xpZW50IGVuZGVkIHRoZSBjb25uZWN0aW9uIGJlY2F1c2UgdGhlIHNlcnZlciBkaWQgbm90IGNvbXBseSB3aXRoIGV4dGVuc2lvbiByZXF1aXJlbWVudHMnLFxuICAgICAgICAgICAgICAgICAgICAxMDExOiAnU2VydmVyIGVuY291bnRlcmVkIGFuIHVuZXhwZWN0ZWQgZmF0YWwgY29uZGl0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgNDAwMDogJ1NlcnZlciBwaW5nIHRpbWVkIG91dCcsXG4gICAgICAgICAgICAgICAgICAgIDQwMDE6ICdDbGllbnQgcG9uZyB0aW1lZCBvdXQnLFxuICAgICAgICAgICAgICAgICAgICA0MDAyOiAnU2VydmVyIGZhaWxlZCB0byBzaWduIGF1dGggdG9rZW4nLFxuICAgICAgICAgICAgICAgICAgICA0MDAzOiAnRmFpbGVkIHRvIGNvbXBsZXRlIGhhbmRzaGFrZScsXG4gICAgICAgICAgICAgICAgICAgIDQwMDQ6ICdDbGllbnQgZmFpbGVkIHRvIHNhdmUgYXV0aCB0b2tlbicsXG4gICAgICAgICAgICAgICAgICAgIDQwMDU6ICdEaWQgbm90IHJlY2VpdmUgI2hhbmRzaGFrZSBmcm9tIGNsaWVudCBiZWZvcmUgdGltZW91dCcsXG4gICAgICAgICAgICAgICAgICAgIDQwMDY6ICdGYWlsZWQgdG8gYmluZCBzb2NrZXQgdG8gbWVzc2FnZSBicm9rZXInLFxuICAgICAgICAgICAgICAgICAgICA0MDA3OiAnQ2xpZW50IGNvbm5lY3Rpb24gZXN0YWJsaXNobWVudCB0aW1lZCBvdXQnXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzLnNvY2tldFByb3RvY29sSWdub3JlU3RhdHVzZXMgPSB7XG4gICAgICAgICAgICAgICAgICAgIDEwMDA6ICdTb2NrZXQgY2xvc2VkIG5vcm1hbGx5JyxcbiAgICAgICAgICAgICAgICAgICAgMTAwMTogJ1NvY2tldCBodW5nIHVwJ1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAvLyBQcm9wZXJ0aWVzIHJlbGF0ZWQgdG8gZXJyb3IgZG9tYWlucyBjYW5ub3QgYmUgc2VyaWFsaXplZC5cbiAgICAgICAgICAgICAgICB2YXIgdW5zZXJpYWxpemFibGVFcnJvclByb3BlcnRpZXMgPSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbWFpbjogMSxcbiAgICAgICAgICAgICAgICAgICAgZG9tYWluRW1pdHRlcjogMSxcbiAgICAgICAgICAgICAgICAgICAgZG9tYWluVGhyb3duOiAxXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzLmRlaHlkcmF0ZUVycm9yID0gZnVuY3Rpb24gKCBlcnJvciwgaW5jbHVkZVN0YWNrVHJhY2UgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWh5ZHJhdGVkRXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIGlmICggdHlwZW9mIGVycm9yID09ICdzdHJpbmcnICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVoeWRyYXRlZEVycm9yID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWh5ZHJhdGVkRXJyb3IgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggaW5jbHVkZVN0YWNrVHJhY2UgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVoeWRyYXRlZEVycm9yLnN0YWNrID0gZXJyb3Iuc3RhY2s7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSBpbiBlcnJvciApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoICF1bnNlcmlhbGl6YWJsZUVycm9yUHJvcGVydGllc1tpXSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVoeWRyYXRlZEVycm9yW2ldID0gZXJyb3JbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjeWNsZS5kZWN5Y2xlKCBkZWh5ZHJhdGVkRXJyb3IgKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMuaHlkcmF0ZUVycm9yID0gZnVuY3Rpb24gKCBlcnJvciApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGh5ZHJhdGVkRXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIGVycm9yICE9IG51bGwgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHR5cGVvZiBlcnJvciA9PSAnc3RyaW5nJyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoeWRyYXRlZEVycm9yID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh5ZHJhdGVkRXJyb3IgPSBuZXcgRXJyb3IoIGVycm9yLm1lc3NhZ2UgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSBpbiBlcnJvciApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBlcnJvci5oYXNPd25Qcm9wZXJ0eSggaSApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHlkcmF0ZWRFcnJvcltpXSA9IGVycm9yW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoeWRyYXRlZEVycm9yO1xuICAgICAgICAgICAgICAgIH07XG5cblxuICAgICAgICAgICAgICAgIC8qKiovXG59LFxuLyogMjYgKi9cbi8qKiovIGZ1bmN0aW9uICggbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fICkge1xuXG5cdC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyggZnVuY3Rpb24gKCBCdWZmZXIsIGdsb2JhbCApIHsvKiFcblx0ICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG5cdCAqXG5cdCAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuXHQgKiBAbGljZW5zZSAgTUlUXG5cdCAqL1xuICAgICAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4gICAgICAgICAgICAgICAgICAgICd1c2Ugc3RyaWN0J1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBiYXNlNjQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCA1NyApXG4gICAgICAgICAgICAgICAgICAgIHZhciBpZWVlNzU0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyggNjEgKVxuICAgICAgICAgICAgICAgICAgICB2YXIgaXNBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oIDYyIClcblxuICAgICAgICAgICAgICAgICAgICBleHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuICAgICAgICAgICAgICAgICAgICBleHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuXG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICAgICAgICAgICAgICAgICAgICAgKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICAgICAgICAgICAgICAgICAgICAgKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAgICAgICAgICAgICAgICAgICAgICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgKiBEdWUgdG8gdmFyaW91cyBicm93c2VyIGJ1Z3MsIHNvbWV0aW1lcyB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uIHdpbGwgYmUgdXNlZCBldmVuXG4gICAgICAgICAgICAgICAgICAgICAqIHdoZW4gdGhlIGJyb3dzZXIgc3VwcG9ydHMgdHlwZWQgYXJyYXlzLlxuICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgKiBOb3RlOlxuICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgKiAgIC0gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWAgaW5zdGFuY2VzLFxuICAgICAgICAgICAgICAgICAgICAgKiAgICAgU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzguXG4gICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAqICAgLSBDaHJvbWUgOS0xMCBpcyBtaXNzaW5nIHRoZSBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgKiAgIC0gSUUxMCBoYXMgYSBicm9rZW4gYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFycmF5cyBvZlxuICAgICAgICAgICAgICAgICAgICAgKiAgICAgaW5jb3JyZWN0IGxlbmd0aCBpbiBzb21lIHNpdHVhdGlvbnMuXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAqIFdlIGRldGVjdCB0aGVzZSBidWdneSBicm93c2VycyBhbmQgc2V0IGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGAgdG8gYGZhbHNlYCBzbyB0aGV5XG4gICAgICAgICAgICAgICAgICAgICAqIGdldCB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uLCB3aGljaCBpcyBzbG93ZXIgYnV0IGJlaGF2ZXMgY29ycmVjdGx5LlxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSAoIHR5cGVvZiBUWVBFRF9BUlJBWV9TVVBQT1JUICE9PSAndW5kZWZpbmVkJyApXG4gICAgICAgICAgICAgICAgICAgICAgICA/IFRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdHlwZWRBcnJheVN1cHBvcnQoKVxuXG4gICAgICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgICAqIEV4cG9ydCBrTWF4TGVuZ3RoIGFmdGVyIHR5cGVkIGFycmF5IHN1cHBvcnQgaXMgZGV0ZXJtaW5lZC5cbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydHMua01heExlbmd0aCA9IGtNYXhMZW5ndGgoKVxuXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoIDEgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyci5fX3Byb3RvX18gPSB7IF9fcHJvdG9fXzogVWludDhBcnJheS5wcm90b3R5cGUsIGZvbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfSB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDIgJiYgLy8gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGFyci5zdWJhcnJheSA9PT0gJ2Z1bmN0aW9uJyAmJiAvLyBjaHJvbWUgOS0xMCBsYWNrIGBzdWJhcnJheWBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyLnN1YmFycmF5KCAxLCAxICkuYnl0ZUxlbmd0aCA9PT0gMCAvLyBpZTEwIGhhcyBicm9rZW4gYHN1YmFycmF5YFxuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoIGUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBrTWF4TGVuZ3RoKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAweDdmZmZmZmZmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAweDNmZmZmZmZmXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBjcmVhdGVCdWZmZXIoIHRoYXQsIGxlbmd0aCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgga01heExlbmd0aCgpIDwgbGVuZ3RoICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCAnSW52YWxpZCB0eXBlZCBhcnJheSBsZW5ndGgnIClcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdCA9IG5ldyBVaW50OEFycmF5KCBsZW5ndGggKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB0aGF0ID09PSBudWxsICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0ID0gbmV3IEJ1ZmZlciggbGVuZ3RoIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5sZW5ndGggPSBsZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoYXRcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAgICAgICAgICAgICAgICAgICAgICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICAgICAgICAgICAgICAgICAgICAgKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gICAgICAgICAgICAgICAgICAgICAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gICAgICAgICAgICAgICAgICAgICAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAgICAgICAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gQnVmZmVyKCBhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmICEoIHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlciggYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGggKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb21tb24gY2FzZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdJZiBlbmNvZGluZyBpcyBzcGVjaWZpZWQgdGhlbiB0aGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWxsb2NVbnNhZmUoIHRoaXMsIGFyZyApXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnJvbSggdGhpcywgYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGggKVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogTGVnYWN5LCBub3QgbmVlZGVkIGFueW1vcmUuIFJlbW92ZSBpbiBuZXh0IG1ham9yIHZlcnNpb24uXG4gICAgICAgICAgICAgICAgICAgIEJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uICggYXJyICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJyLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhcnJcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGZyb20oIHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGggKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvciggJ1widmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicgKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKCB0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoIClcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmcm9tU3RyaW5nKCB0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCApXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmcm9tT2JqZWN0KCB0aGF0LCB2YWx1ZSApXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gICAgICAgICAgICAgICAgICAgICAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAgICAgICAgICAgICAgICAgICAgICogQnVmZmVyLmZyb20oYXJyYXkpXG4gICAgICAgICAgICAgICAgICAgICAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAgICAgICAgICAgICAgICAgICAgICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gICAgICAgICAgICAgICAgICAgICAqKi9cbiAgICAgICAgICAgICAgICAgICAgQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAoIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGggKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnJvbSggbnVsbCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCApXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoIEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgQnVmZmVyLnByb3RvdHlwZS5fX3Byb3RvX18gPSBVaW50OEFycmF5LnByb3RvdHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgQnVmZmVyLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnNwZWNpZXMgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdID09PSBCdWZmZXIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRml4IHN1YmFycmF5KCkgaW4gRVMyMDE2LiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvOTdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIEJ1ZmZlciwgU3ltYm9sLnNwZWNpZXMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gYXNzZXJ0U2l6ZSggc2l6ZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdHlwZW9mIHNpemUgIT09ICdudW1iZXInICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoICdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJyApXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBzaXplIDwgMCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvciggJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG5lZ2F0aXZlJyApXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBhbGxvYyggdGhhdCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnRTaXplKCBzaXplIClcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggc2l6ZSA8PSAwICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIoIHRoYXQsIHNpemUgKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBmaWxsICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYmUgaW50ZXJwcmV0dGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gY3JlYXRlQnVmZmVyKCB0aGF0LCBzaXplICkuZmlsbCggZmlsbCwgZW5jb2RpbmcgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGNyZWF0ZUJ1ZmZlciggdGhhdCwgc2l6ZSApLmZpbGwoIGZpbGwgKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlciggdGhhdCwgc2l6ZSApXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICAgICAgICAgICAgICAgICAgICAgKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gICAgICAgICAgICAgICAgICAgICAqKi9cbiAgICAgICAgICAgICAgICAgICAgQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKCBzaXplLCBmaWxsLCBlbmNvZGluZyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhbGxvYyggbnVsbCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcgKVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gYWxsb2NVbnNhZmUoIHRoYXQsIHNpemUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnRTaXplKCBzaXplIClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQgPSBjcmVhdGVCdWZmZXIoIHRoYXQsIHNpemUgPCAwID8gMCA6IGNoZWNrZWQoIHNpemUgKSB8IDAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgc2l6ZTsgKytpICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0W2ldID0gMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGF0XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAgICAgICAgICAgICAgICAgICAgICogKi9cbiAgICAgICAgICAgICAgICAgICAgQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKCBzaXplICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFsbG9jVW5zYWZlKCBudWxsLCBzaXplIClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBCdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKCBzaXplICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFsbG9jVW5zYWZlKCBudWxsLCBzaXplIClcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGZyb21TdHJpbmcoIHRoYXQsIHN0cmluZywgZW5jb2RpbmcgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggIUJ1ZmZlci5pc0VuY29kaW5nKCBlbmNvZGluZyApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoICdcImVuY29kaW5nXCIgbXVzdCBiZSBhIHZhbGlkIHN0cmluZyBlbmNvZGluZycgKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aCggc3RyaW5nLCBlbmNvZGluZyApIHwgMFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdCA9IGNyZWF0ZUJ1ZmZlciggdGhhdCwgbGVuZ3RoIClcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFjdHVhbCA9IHRoYXQud3JpdGUoIHN0cmluZywgZW5jb2RpbmcgKVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGFjdHVhbCAhPT0gbGVuZ3RoICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdCA9IHRoYXQuc2xpY2UoIDAsIGFjdHVhbCApXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGF0XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBmcm9tQXJyYXlMaWtlKCB0aGF0LCBhcnJheSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoIGFycmF5Lmxlbmd0aCApIHwgMFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdCA9IGNyZWF0ZUJ1ZmZlciggdGhhdCwgbGVuZ3RoIClcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoYXRcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciggdGhhdCwgYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5LmJ5dGVMZW5ndGggLy8gdGhpcyB0aHJvd3MgaWYgYGFycmF5YCBpcyBub3QgYSB2YWxpZCBBcnJheUJ1ZmZlclxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCAnXFwnb2Zmc2V0XFwnIGlzIG91dCBvZiBib3VuZHMnIClcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArICggbGVuZ3RoIHx8IDAgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvciggJ1xcJ2xlbmd0aFxcJyBpcyBvdXQgb2YgYm91bmRzJyApXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoIGFycmF5IClcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIGxlbmd0aCA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoIGFycmF5LCBieXRlT2Zmc2V0IClcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXkgPSBuZXcgVWludDhBcnJheSggYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCApXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdCA9IGFycmF5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0ID0gZnJvbUFycmF5TGlrZSggdGhhdCwgYXJyYXkgKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoYXRcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGZyb21PYmplY3QoIHRoYXQsIG9iaiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggQnVmZmVyLmlzQnVmZmVyKCBvYmogKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGVuID0gY2hlY2tlZCggb2JqLmxlbmd0aCApIHwgMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQgPSBjcmVhdGVCdWZmZXIoIHRoYXQsIGxlbiApXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHRoYXQubGVuZ3RoID09PSAwICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhhdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iai5jb3B5KCB0aGF0LCAwLCAwLCBsZW4gKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGF0XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggb2JqICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggKCB0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iai5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciApIHx8ICdsZW5ndGgnIGluIG9iaiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgaXNuYW4oIG9iai5sZW5ndGggKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIoIHRoYXQsIDAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKCB0aGF0LCBvYmogKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggb2JqLnR5cGUgPT09ICdCdWZmZXInICYmIGlzQXJyYXkoIG9iai5kYXRhICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKCB0aGF0LCBvYmouZGF0YSApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCAnRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIG9yIGFycmF5LWxpa2Ugb2JqZWN0LicgKVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gY2hlY2tlZCggbGVuZ3RoICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwga01heExlbmd0aCgpYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggbGVuZ3RoID49IGtNYXhMZW5ndGgoKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvciggJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBrTWF4TGVuZ3RoKCkudG9TdHJpbmcoIDE2ICkgKyAnIGJ5dGVzJyApXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGVuZ3RoIHwgMFxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gU2xvd0J1ZmZlciggbGVuZ3RoICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCArbGVuZ3RoICE9IGxlbmd0aCApIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSAwXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gQnVmZmVyLmFsbG9jKCArbGVuZ3RoIClcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIEJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyKCBiICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEhKCBiICE9IG51bGwgJiYgYi5faXNCdWZmZXIgKVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlKCBhLCBiICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhQnVmZmVyLmlzQnVmZmVyKCBhICkgfHwgIUJ1ZmZlci5pc0J1ZmZlciggYiApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoICdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJyApXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggYSA9PT0gYiApIHJldHVybiAwXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4ID0gYS5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB5ID0gYi5sZW5ndGhcblxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbiggeCwgeSApOyBpIDwgbGVuOyArK2kgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBhW2ldICE9PSBiW2ldICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4ID0gYVtpXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5ID0gYltpXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB4IDwgeSApIHJldHVybiAtMVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB5IDwgeCApIHJldHVybiAxXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMFxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nKCBlbmNvZGluZyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoIFN0cmluZyggZW5jb2RpbmcgKS50b0xvd2VyQ2FzZSgpICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAndXRmOCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd1Y3MyJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd1Y3MtMic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCggbGlzdCwgbGVuZ3RoICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhaXNBcnJheSggbGlzdCApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoICdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnIClcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBsaXN0Lmxlbmd0aCA9PT0gMCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gQnVmZmVyLmFsbG9jKCAwIClcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggbGVuZ3RoID09PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKCBsZW5ndGggKVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBvcyA9IDBcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYnVmID0gbGlzdFtpXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggIUJ1ZmZlci5pc0J1ZmZlciggYnVmICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoICdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmLmNvcHkoIGJ1ZmZlciwgcG9zIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3MgKz0gYnVmLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlclxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gYnl0ZUxlbmd0aCggc3RyaW5nLCBlbmNvZGluZyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggQnVmZmVyLmlzQnVmZmVyKCBzdHJpbmcgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBBcnJheUJ1ZmZlci5pc1ZpZXcgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIEFycmF5QnVmZmVyLmlzVmlldyggc3RyaW5nICkgfHwgc3RyaW5nIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5nID0gJycgKyBzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggbGVuID09PSAwICkgcmV0dXJuIDBcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggOyA7ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoIGVuY29kaW5nICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGVuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKCBzdHJpbmcgKS5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAndWNzMic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyggc3RyaW5nICkubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGxvd2VyZWRDYXNlICkgcmV0dXJuIHV0ZjhUb0J5dGVzKCBzdHJpbmcgKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kaW5nID0gKCAnJyArIGVuY29kaW5nICkudG9Mb3dlckNhc2UoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIEJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHNsb3dUb1N0cmluZyggZW5jb2RpbmcsIHN0YXJ0LCBlbmQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IDBcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBzdGFydCA+IHRoaXMubGVuZ3RoICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZW5kIDw9IDAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcnXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZvcmNlIGNvZXJzaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQgPj4+PSAwXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA+Pj49IDBcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBlbmQgPD0gc3RhcnQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcnXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggIWVuY29kaW5nICkgZW5jb2RpbmcgPSAndXRmOCdcblxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCB0cnVlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoIGVuY29kaW5nICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdoZXgnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhleFNsaWNlKCB0aGlzLCBzdGFydCwgZW5kIClcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd1dGY4JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSggdGhpcywgc3RhcnQsIGVuZCApXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UoIHRoaXMsIHN0YXJ0LCBlbmQgKVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UoIHRoaXMsIHN0YXJ0LCBlbmQgKVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UoIHRoaXMsIHN0YXJ0LCBlbmQgKVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd1Y3MtMic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKCB0aGlzLCBzdGFydCwgZW5kIClcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBsb3dlcmVkQ2FzZSApIHRocm93IG5ldyBUeXBlRXJyb3IoICdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RpbmcgPSAoIGVuY29kaW5nICsgJycgKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCBhbmQgYGlzLWJ1ZmZlcmAgKGluIFNhZmFyaSA1LTcpIHRvIGRldGVjdFxuICAgICAgICAgICAgICAgICAgICAvLyBCdWZmZXIgaW5zdGFuY2VzLlxuICAgICAgICAgICAgICAgICAgICBCdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcblxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBzd2FwKCBiLCBuLCBtICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBiW25dXG4gICAgICAgICAgICAgICAgICAgICAgICBiW25dID0gYlttXVxuICAgICAgICAgICAgICAgICAgICAgICAgYlttXSA9IGlcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIEJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGxlbiAlIDIgIT09IDAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoICdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycgKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dhcCggdGhpcywgaSwgaSArIDEgKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIEJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGxlbiAlIDQgIT09IDAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoICdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycgKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dhcCggdGhpcywgaSwgaSArIDMgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3YXAoIHRoaXMsIGkgKyAxLCBpICsgMiApXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggbGVuICUgOCAhPT0gMCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvciggJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJyApXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2FwKCB0aGlzLCBpLCBpICsgNyApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dhcCggdGhpcywgaSArIDEsIGkgKyA2IClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2FwKCB0aGlzLCBpICsgMiwgaSArIDUgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3YXAoIHRoaXMsIGkgKyAzLCBpICsgNCApXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoIHwgMFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBsZW5ndGggPT09IDAgKSByZXR1cm4gJydcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggYXJndW1lbnRzLmxlbmd0aCA9PT0gMCApIHJldHVybiB1dGY4U2xpY2UoIHRoaXMsIDAsIGxlbmd0aCApXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMoIGIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoICFCdWZmZXIuaXNCdWZmZXIoIGIgKSApIHRocm93IG5ldyBUeXBlRXJyb3IoICdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJyApXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHRoaXMgPT09IGIgKSByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKCB0aGlzLCBiICkgPT09IDBcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIEJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RyID0gJydcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHRoaXMubGVuZ3RoID4gMCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgPSB0aGlzLnRvU3RyaW5nKCAnaGV4JywgMCwgbWF4ICkubWF0Y2goIC8uezJ9L2cgKS5qb2luKCAnICcgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdGhpcy5sZW5ndGggPiBtYXggKSBzdHIgKz0gJyAuLi4gJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIEJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUoIHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhQnVmZmVyLmlzQnVmZmVyKCB0YXJnZXQgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCAnQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicgKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHN0YXJ0ID09PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSAwXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGVuZCA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNTdGFydCA9IDBcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdGhpc0VuZCA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCAnb3V0IG9mIHJhbmdlIGluZGV4JyApXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHRoaXNTdGFydCA+PSB0aGlzRW5kICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAtMVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBzdGFydCA+PSBlbmQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDFcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPj4+PSAwXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQgPj4+PSAwXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzU3RhcnQgPj4+PSAwXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzRW5kID4+Pj0gMFxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHRoaXMgPT09IHRhcmdldCApIHJldHVybiAwXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHkgPSBlbmQgLSBzdGFydFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlbiA9IE1hdGgubWluKCB4LCB5IClcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRoaXNDb3B5ID0gdGhpcy5zbGljZSggdGhpc1N0YXJ0LCB0aGlzRW5kIClcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKCBzdGFydCwgZW5kIClcblxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgbGVuOyArK2kgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeCA9IHRoaXNDb3B5W2ldXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHggPCB5ICkgcmV0dXJuIC0xXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHkgPCB4ICkgcmV0dXJuIDFcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4gICAgICAgICAgICAgICAgICAgIC8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuXG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vIEFyZ3VtZW50czpcbiAgICAgICAgICAgICAgICAgICAgLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2hcbiAgICAgICAgICAgICAgICAgICAgLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbiAgICAgICAgICAgICAgICAgICAgLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4gICAgICAgICAgICAgICAgICAgIC8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nXG4gICAgICAgICAgICAgICAgICAgIC8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mKCBidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpciApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVtcHR5IGJ1ZmZlciBtZWFucyBubyBtYXRjaFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBidWZmZXIubGVuZ3RoID09PSAwICkgcmV0dXJuIC0xXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBieXRlT2Zmc2V0ID0gMFxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICggYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldCAgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggaXNOYU4oIGJ5dGVPZmZzZXQgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBieXRlT2Zmc2V0OiBpdCBpdCdzIHVuZGVmaW5lZCwgbnVsbCwgTmFOLCBcImZvb1wiLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6ICggYnVmZmVyLmxlbmd0aCAtIDEgKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBieXRlT2Zmc2V0IDwgMCApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGggKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBkaXIgKSByZXR1cm4gLTFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICggYnl0ZU9mZnNldCA8IDAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBkaXIgKSBieXRlT2Zmc2V0ID0gMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgcmV0dXJuIC0xXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vcm1hbGl6ZSB2YWxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gQnVmZmVyLmZyb20oIHZhbCwgZW5jb2RpbmcgKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBCdWZmZXIuaXNCdWZmZXIoIHZhbCApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHZhbC5sZW5ndGggPT09IDAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAtMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXlJbmRleE9mKCBidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpciApXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCB0eXBlb2YgdmFsID09PSAnbnVtYmVyJyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSB2YWwgJiAweEZGIC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGRpciApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoIGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0IClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKCBidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5SW5kZXhPZiggYnVmZmVyLCBbdmFsXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpciApXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoICd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInIClcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGFycmF5SW5kZXhPZiggYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXhTaXplID0gMVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZW5jb2RpbmcgIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGluZyA9IFN0cmluZyggZW5jb2RpbmcgKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleFNpemUgPSAyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbExlbmd0aCAvPSAyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVPZmZzZXQgLz0gMlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gcmVhZCggYnVmLCBpICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggaW5kZXhTaXplID09PSAxICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYnVmW2ldXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoIGkgKiBpbmRleFNpemUgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZGlyICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmb3VuZEluZGV4ID0gLTFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCBpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHJlYWQoIGFyciwgaSApID09PSByZWFkKCB2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4ICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGZvdW5kSW5kZXggPT09IC0xICkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGggKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBmb3VuZEluZGV4ICE9PSAtMSApIGkgLT0gaSAtIGZvdW5kSW5kZXhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGggKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZm91bmQgPSB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCByZWFkKCBhcnIsIGkgKyBqICkgIT09IHJlYWQoIHZhbCwgaiApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kID0gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZm91bmQgKSByZXR1cm4gaVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBCdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMoIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbmRleE9mKCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nICkgIT09IC0xXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBCdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mKCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKCB0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlIClcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIEJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiggdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZiggdGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UgKVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gaGV4V3JpdGUoIGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IE51bWJlciggb2Zmc2V0ICkgfHwgMFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggIWxlbmd0aCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gTnVtYmVyKCBsZW5ndGggKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggbGVuZ3RoID4gcmVtYWluaW5nICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBzdHJMZW4gJSAyICE9PSAwICkgdGhyb3cgbmV3IFR5cGVFcnJvciggJ0ludmFsaWQgaGV4IHN0cmluZycgKVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGxlbmd0aCA+IHN0ckxlbiAvIDIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KCBzdHJpbmcuc3Vic3RyKCBpICogMiwgMiApLCAxNiApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBpc05hTiggcGFyc2VkICkgKSByZXR1cm4gaVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHV0ZjhXcml0ZSggYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJsaXRCdWZmZXIoIHV0ZjhUb0J5dGVzKCBzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQgKSwgYnVmLCBvZmZzZXQsIGxlbmd0aCApXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBhc2NpaVdyaXRlKCBidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGggKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmxpdEJ1ZmZlciggYXNjaWlUb0J5dGVzKCBzdHJpbmcgKSwgYnVmLCBvZmZzZXQsIGxlbmd0aCApXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBsYXRpbjFXcml0ZSggYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUoIGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCApXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBiYXNlNjRXcml0ZSggYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJsaXRCdWZmZXIoIGJhc2U2NFRvQnl0ZXMoIHN0cmluZyApLCBidWYsIG9mZnNldCwgbGVuZ3RoIClcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHVjczJXcml0ZSggYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJsaXRCdWZmZXIoIHV0ZjE2bGVUb0J5dGVzKCBzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQgKSwgYnVmLCBvZmZzZXQsIGxlbmd0aCApXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBCdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUoIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIGlzRmluaXRlKCBvZmZzZXQgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBpc0Zpbml0ZSggbGVuZ3RoICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IGxlbmd0aCB8IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBlbmNvZGluZyA9PT0gdW5kZWZpbmVkICkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbGVnYWN5IHdyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKSAtIHJlbW92ZSBpbiB2MC4xM1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcgKSBsZW5ndGggPSByZW1haW5pbmdcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAoIHN0cmluZy5sZW5ndGggPiAwICYmICggbGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwICkgKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvciggJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJyApXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggIWVuY29kaW5nICkgZW5jb2RpbmcgPSAndXRmOCdcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIDsgOyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKCBlbmNvZGluZyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBoZXhXcml0ZSggdGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCApXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAndXRmOCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1dGY4V3JpdGUoIHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGggKVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhc2NpaVdyaXRlKCB0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoIClcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxhdGluMVdyaXRlKCB0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoIClcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSggdGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCApXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAndWNzMic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1Y3MyV3JpdGUoIHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGggKVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGxvd2VyZWRDYXNlICkgdGhyb3cgbmV3IFR5cGVFcnJvciggJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZyApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGluZyA9ICggJycgKyBlbmNvZGluZyApLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIEJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCggdGhpcy5fYXJyIHx8IHRoaXMsIDAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gYmFzZTY0U2xpY2UoIGJ1Ziwgc3RhcnQsIGVuZCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheSggYnVmIClcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KCBidWYuc2xpY2UoIHN0YXJ0LCBlbmQgKSApXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiB1dGY4U2xpY2UoIGJ1Ziwgc3RhcnQsIGVuZCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZCA9IE1hdGgubWluKCBidWYubGVuZ3RoLCBlbmQgKVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlcyA9IFtdXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0gc3RhcnRcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICggaSA8IGVuZCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvZGVQb2ludCA9IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9ICggZmlyc3RCeXRlID4gMHhFRiApID8gNFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICggZmlyc3RCeXRlID4gMHhERiApID8gM1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAoIGZpcnN0Qnl0ZSA+IDB4QkYgKSA/IDJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IDFcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoICggYnl0ZXNQZXJTZXF1ZW5jZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGZpcnN0Qnl0ZSA8IDB4ODAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAoIHNlY29uZEJ5dGUgJiAweEMwICkgPT09IDB4ODAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoIGZpcnN0Qnl0ZSAmIDB4MUYgKSA8PCAweDYgfCAoIHNlY29uZEJ5dGUgJiAweDNGIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB0ZW1wQ29kZVBvaW50ID4gMHg3RiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggKCBzZWNvbmRCeXRlICYgMHhDMCApID09PSAweDgwICYmICggdGhpcmRCeXRlICYgMHhDMCApID09PSAweDgwICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKCBmaXJzdEJ5dGUgJiAweEYgKSA8PCAweEMgfCAoIHNlY29uZEJ5dGUgJiAweDNGICkgPDwgMHg2IHwgKCB0aGlyZEJ5dGUgJiAweDNGIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKCB0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAoIHNlY29uZEJ5dGUgJiAweEMwICkgPT09IDB4ODAgJiYgKCB0aGlyZEJ5dGUgJiAweEMwICkgPT09IDB4ODAgJiYgKCBmb3VydGhCeXRlICYgMHhDMCApID09PSAweDgwICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKCBmaXJzdEJ5dGUgJiAweEYgKSA8PCAweDEyIHwgKCBzZWNvbmRCeXRlICYgMHgzRiApIDw8IDB4QyB8ICggdGhpcmRCeXRlICYgMHgzRiApIDw8IDB4NiB8ICggZm91cnRoQnl0ZSAmIDB4M0YgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBjb2RlUG9pbnQgPT09IG51bGwgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBjb2RlUG9pbnQgPiAweEZGRkYgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKCBjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKCBjb2RlUG9pbnQgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KCByZXMgKVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxuICAgICAgICAgICAgICAgICAgICB2YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkoIGNvZGVQb2ludHMgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggbGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KCBTdHJpbmcsIGNvZGVQb2ludHMgKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXMgPSAnJ1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSAwXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIGkgPCBsZW4gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFN0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZVBvaW50cy5zbGljZSggaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSCApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gYXNjaWlTbGljZSggYnVmLCBzdGFydCwgZW5kICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJldCA9ICcnXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSBNYXRoLm1pbiggYnVmLmxlbmd0aCwgZW5kIClcblxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCBidWZbaV0gJiAweDdGIClcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXRcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGxhdGluMVNsaWNlKCBidWYsIHN0YXJ0LCBlbmQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmV0ID0gJydcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZCA9IE1hdGgubWluKCBidWYubGVuZ3RoLCBlbmQgKVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoIGJ1ZltpXSApXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBoZXhTbGljZSggYnVmLCBzdGFydCwgZW5kICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhc3RhcnQgfHwgc3RhcnQgPCAwICkgc3RhcnQgPSAwXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoICFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4gKSBlbmQgPSBsZW5cblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG91dCA9ICcnXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0ICs9IHRvSGV4KCBidWZbaV0gKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG91dFxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gdXRmMTZsZVNsaWNlKCBidWYsIHN0YXJ0LCBlbmQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYnl0ZXMgPSBidWYuc2xpY2UoIHN0YXJ0LCBlbmQgKVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlcyA9ICcnXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSggYnl0ZXNbaV0gKyBieXRlc1tpICsgMV0gKiAyNTYgKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlKCBzdGFydCwgZW5kICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IH5+c3RhcnRcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBzdGFydCA8IDAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgKz0gbGVuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBzdGFydCA8IDAgKSBzdGFydCA9IDBcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIHN0YXJ0ID4gbGVuICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gbGVuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZW5kIDwgMCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQgKz0gbGVuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBlbmQgPCAwICkgZW5kID0gMFxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICggZW5kID4gbGVuICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZCA9IGxlblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGVuZCA8IHN0YXJ0ICkgZW5kID0gc3RhcnRcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld0J1ZlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KCBzdGFydCwgZW5kIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdCdWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2xpY2VMZW4gPSBlbmQgLSBzdGFydFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0J1ZiA9IG5ldyBCdWZmZXIoIHNsaWNlTGVuLCB1bmRlZmluZWQgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IHNsaWNlTGVuOyArK2kgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0J1ZltpXSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ld0J1ZlxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBjaGVja09mZnNldCggb2Zmc2V0LCBleHQsIGxlbmd0aCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggKCBvZmZzZXQgJSAxICkgIT09IDAgfHwgb2Zmc2V0IDwgMCApIHRocm93IG5ldyBSYW5nZUVycm9yKCAnb2Zmc2V0IGlzIG5vdCB1aW50JyApXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG9mZnNldCArIGV4dCA+IGxlbmd0aCApIHRocm93IG5ldyBSYW5nZUVycm9yKCAnVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcgKVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSggb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhbm9Bc3NlcnQgKSBjaGVja09mZnNldCggb2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aCApXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtdWwgPSAxXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IDBcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICggKytpIDwgYnl0ZUxlbmd0aCAmJiAoIG11bCAqPSAweDEwMCApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWxcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIEJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUoIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gICAgICAgICAgICAgICAgICAgICAgICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggIW5vQXNzZXJ0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrT2Zmc2V0KCBvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoIClcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG11bCA9IDFcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICggYnl0ZUxlbmd0aCA+IDAgJiYgKCBtdWwgKj0gMHgxMDAgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWxcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIEJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4KCBvZmZzZXQsIG5vQXNzZXJ0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhbm9Bc3NlcnQgKSBjaGVja09mZnNldCggb2Zmc2V0LCAxLCB0aGlzLmxlbmd0aCApXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tvZmZzZXRdXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSggb2Zmc2V0LCBub0Fzc2VydCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggIW5vQXNzZXJ0ICkgY2hlY2tPZmZzZXQoIG9mZnNldCwgMiwgdGhpcy5sZW5ndGggKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICggdGhpc1tvZmZzZXQgKyAxXSA8PCA4IClcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIEJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFKCBvZmZzZXQsIG5vQXNzZXJ0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhbm9Bc3NlcnQgKSBjaGVja09mZnNldCggb2Zmc2V0LCAyLCB0aGlzLmxlbmd0aCApXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCB0aGlzW29mZnNldF0gPDwgOCApIHwgdGhpc1tvZmZzZXQgKyAxXVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUoIG9mZnNldCwgbm9Bc3NlcnQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoICFub0Fzc2VydCApIGNoZWNrT2Zmc2V0KCBvZmZzZXQsIDQsIHRoaXMubGVuZ3RoIClcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICggKCB0aGlzW29mZnNldF0gKSB8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCB0aGlzW29mZnNldCArIDFdIDw8IDggKSB8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCB0aGlzW29mZnNldCArIDJdIDw8IDE2ICkgKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCB0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwIClcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIEJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFKCBvZmZzZXQsIG5vQXNzZXJ0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhbm9Bc3NlcnQgKSBjaGVja09mZnNldCggb2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCApXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoIHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCApICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoICggdGhpc1tvZmZzZXQgKyAxXSA8PCAxNiApIHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCB0aGlzW29mZnNldCArIDJdIDw8IDggKSB8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbb2Zmc2V0ICsgM10gKVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUoIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gICAgICAgICAgICAgICAgICAgICAgICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggIW5vQXNzZXJ0ICkgY2hlY2tPZmZzZXQoIG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGggKVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbXVsID0gMVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSAwXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoICsraSA8IGJ5dGVMZW5ndGggJiYgKCBtdWwgKj0gMHgxMDAgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbXVsICo9IDB4ODBcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB2YWwgPj0gbXVsICkgdmFsIC09IE1hdGgucG93KCAyLCA4ICogYnl0ZUxlbmd0aCApXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWxcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIEJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFKCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoICFub0Fzc2VydCApIGNoZWNrT2Zmc2V0KCBvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoIClcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBieXRlTGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbXVsID0gMVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCBpID4gMCAmJiAoIG11bCAqPSAweDEwMCApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG11bCAqPSAweDgwXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdmFsID49IG11bCApIHZhbCAtPSBNYXRoLnBvdyggMiwgOCAqIGJ5dGVMZW5ndGggKVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDgoIG9mZnNldCwgbm9Bc3NlcnQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoICFub0Fzc2VydCApIGNoZWNrT2Zmc2V0KCBvZmZzZXQsIDEsIHRoaXMubGVuZ3RoIClcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggISggdGhpc1tvZmZzZXRdICYgMHg4MCApICkgcmV0dXJuICggdGhpc1tvZmZzZXRdIClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoICggMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEgKSAqIC0xIClcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIEJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSggb2Zmc2V0LCBub0Fzc2VydCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggIW5vQXNzZXJ0ICkgY2hlY2tPZmZzZXQoIG9mZnNldCwgMiwgdGhpcy5sZW5ndGggKVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICggdGhpc1tvZmZzZXQgKyAxXSA8PCA4IClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoIHZhbCAmIDB4ODAwMCApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFKCBvZmZzZXQsIG5vQXNzZXJ0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhbm9Bc3NlcnQgKSBjaGVja09mZnNldCggb2Zmc2V0LCAyLCB0aGlzLmxlbmd0aCApXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICggdGhpc1tvZmZzZXRdIDw8IDggKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICggdmFsICYgMHg4MDAwICkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUoIG9mZnNldCwgbm9Bc3NlcnQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoICFub0Fzc2VydCApIGNoZWNrT2Zmc2V0KCBvZmZzZXQsIDQsIHRoaXMubGVuZ3RoIClcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICggdGhpc1tvZmZzZXRdICkgfFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICggdGhpc1tvZmZzZXQgKyAxXSA8PCA4ICkgfFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICggdGhpc1tvZmZzZXQgKyAyXSA8PCAxNiApIHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQgKVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFKCBvZmZzZXQsIG5vQXNzZXJ0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhbm9Bc3NlcnQgKSBjaGVja09mZnNldCggb2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCApXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoIHRoaXNbb2Zmc2V0XSA8PCAyNCApIHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYgKSB8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCB0aGlzW29mZnNldCArIDJdIDw8IDggKSB8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCB0aGlzW29mZnNldCArIDNdIClcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIEJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSggb2Zmc2V0LCBub0Fzc2VydCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggIW5vQXNzZXJ0ICkgY2hlY2tPZmZzZXQoIG9mZnNldCwgNCwgdGhpcy5sZW5ndGggKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGllZWU3NTQucmVhZCggdGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNCApXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBCdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUoIG9mZnNldCwgbm9Bc3NlcnQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoICFub0Fzc2VydCApIGNoZWNrT2Zmc2V0KCBvZmZzZXQsIDQsIHRoaXMubGVuZ3RoIClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpZWVlNzU0LnJlYWQoIHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0IClcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIEJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFKCBvZmZzZXQsIG5vQXNzZXJ0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhbm9Bc3NlcnQgKSBjaGVja09mZnNldCggb2Zmc2V0LCA4LCB0aGlzLmxlbmd0aCApXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWVlZTc1NC5yZWFkKCB0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4IClcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIEJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFKCBvZmZzZXQsIG5vQXNzZXJ0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhbm9Bc3NlcnQgKSBjaGVja09mZnNldCggb2Zmc2V0LCA4LCB0aGlzLmxlbmd0aCApXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWVlZTc1NC5yZWFkKCB0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOCApXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBjaGVja0ludCggYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhQnVmZmVyLmlzQnVmZmVyKCBidWYgKSApIHRocm93IG5ldyBUeXBlRXJyb3IoICdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnIClcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4gKSB0aHJvdyBuZXcgUmFuZ2VFcnJvciggJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJyApXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGggKSB0aHJvdyBuZXcgUmFuZ2VFcnJvciggJ0luZGV4IG91dCBvZiByYW5nZScgKVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFKCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gK3ZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gICAgICAgICAgICAgICAgICAgICAgICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggIW5vQXNzZXJ0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KCAyLCA4ICogYnl0ZUxlbmd0aCApIC0gMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrSW50KCB0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMCApXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtdWwgPSAxXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IDBcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCArK2kgPCBieXRlTGVuZ3RoICYmICggbXVsICo9IDB4MTAwICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1tvZmZzZXQgKyBpXSA9ICggdmFsdWUgLyBtdWwgKSAmIDB4RkZcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIEJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSggdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9ICt2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoICFub0Fzc2VydCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdyggMiwgOCAqIGJ5dGVMZW5ndGggKSAtIDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGVja0ludCggdGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbXVsID0gMVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCAtLWkgPj0gMCAmJiAoIG11bCAqPSAweDEwMCApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoIHZhbHVlIC8gbXVsICkgJiAweEZGXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4KCB2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gK3ZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoICFub0Fzc2VydCApIGNoZWNrSW50KCB0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwIClcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICkgdmFsdWUgPSBNYXRoLmZsb29yKCB2YWx1ZSApXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW29mZnNldF0gPSAoIHZhbHVlICYgMHhmZiApXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2Zmc2V0ICsgMVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MTYoIGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB2YWx1ZSA8IDAgKSB2YWx1ZSA9IDB4ZmZmZiArIHZhbHVlICsgMVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBqID0gTWF0aC5taW4oIGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDIgKTsgaSA8IGo7ICsraSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZbb2Zmc2V0ICsgaV0gPSAoIHZhbHVlICYgKCAweGZmIDw8ICggOCAqICggbGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpICkgKSApICkgPj4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggbGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpICkgKiA4XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFKCB2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gK3ZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoICFub0Fzc2VydCApIGNoZWNrSW50KCB0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW29mZnNldF0gPSAoIHZhbHVlICYgMHhmZiApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1tvZmZzZXQgKyAxXSA9ICggdmFsdWUgPj4+IDggKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3RXcml0ZVVJbnQxNiggdGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSApXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2Zmc2V0ICsgMlxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSggdmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9ICt2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhbm9Bc3NlcnQgKSBjaGVja0ludCggdGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwIClcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1tvZmZzZXRdID0gKCB2YWx1ZSA+Pj4gOCApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1tvZmZzZXQgKyAxXSA9ICggdmFsdWUgJiAweGZmIClcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0V3JpdGVVSW50MTYoIHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlIClcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvZmZzZXQgKyAyXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQzMiggYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHZhbHVlIDwgMCApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBqID0gTWF0aC5taW4oIGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDQgKTsgaSA8IGo7ICsraSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZbb2Zmc2V0ICsgaV0gPSAoIHZhbHVlID4+PiAoIGxpdHRsZUVuZGlhbiA/IGkgOiAzIC0gaSApICogOCApICYgMHhmZlxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSggdmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9ICt2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhbm9Bc3NlcnQgKSBjaGVja0ludCggdGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMCApXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAoIHZhbHVlID4+PiAyNCApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1tvZmZzZXQgKyAyXSA9ICggdmFsdWUgPj4+IDE2IClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW29mZnNldCArIDFdID0gKCB2YWx1ZSA+Pj4gOCApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1tvZmZzZXRdID0gKCB2YWx1ZSAmIDB4ZmYgKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3RXcml0ZVVJbnQzMiggdGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSApXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2Zmc2V0ICsgNFxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSggdmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9ICt2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhbm9Bc3NlcnQgKSBjaGVja0ludCggdGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMCApXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbb2Zmc2V0XSA9ICggdmFsdWUgPj4+IDI0IClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW29mZnNldCArIDFdID0gKCB2YWx1ZSA+Pj4gMTYgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAoIHZhbHVlID4+PiA4IClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW29mZnNldCArIDNdID0gKCB2YWx1ZSAmIDB4ZmYgKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3RXcml0ZVVJbnQzMiggdGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UgKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9mZnNldCArIDRcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIEJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUoIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSArdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggIW5vQXNzZXJ0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsaW1pdCA9IE1hdGgucG93KCAyLCA4ICogYnl0ZUxlbmd0aCAtIDEgKVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tJbnQoIHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0IClcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSAwXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbXVsID0gMVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN1YiA9IDBcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCArK2kgPCBieXRlTGVuZ3RoICYmICggbXVsICo9IDB4MTAwICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWIgPSAxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoICggdmFsdWUgLyBtdWwgKSA+PiAwICkgLSBzdWIgJiAweEZGXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBCdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFKCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gK3ZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoICFub0Fzc2VydCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGltaXQgPSBNYXRoLnBvdyggMiwgOCAqIGJ5dGVMZW5ndGggLSAxIClcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrSW50KCB0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdCApXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtdWwgPSAxXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3ViID0gMFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCAtLWkgPj0gMCAmJiAoIG11bCAqPSAweDEwMCApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViID0gMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW29mZnNldCArIGldID0gKCAoIHZhbHVlIC8gbXVsICkgPj4gMCApIC0gc3ViICYgMHhGRlxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDgoIHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSArdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggIW5vQXNzZXJ0ICkgY2hlY2tJbnQoIHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwIClcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICkgdmFsdWUgPSBNYXRoLmZsb29yKCB2YWx1ZSApXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHZhbHVlIDwgMCApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1tvZmZzZXRdID0gKCB2YWx1ZSAmIDB4ZmYgKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9mZnNldCArIDFcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIEJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFKCB2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gK3ZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoICFub0Fzc2VydCApIGNoZWNrSW50KCB0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW29mZnNldF0gPSAoIHZhbHVlICYgMHhmZiApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1tvZmZzZXQgKyAxXSA9ICggdmFsdWUgPj4+IDggKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3RXcml0ZVVJbnQxNiggdGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSApXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2Zmc2V0ICsgMlxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUoIHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSArdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggIW5vQXNzZXJ0ICkgY2hlY2tJbnQoIHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMCApXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbb2Zmc2V0XSA9ICggdmFsdWUgPj4+IDggKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAoIHZhbHVlICYgMHhmZiApXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdFdyaXRlVUludDE2KCB0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSApXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2Zmc2V0ICsgMlxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUoIHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSArdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggIW5vQXNzZXJ0ICkgY2hlY2tJbnQoIHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwIClcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1tvZmZzZXRdID0gKCB2YWx1ZSAmIDB4ZmYgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAoIHZhbHVlID4+PiA4IClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW29mZnNldCArIDJdID0gKCB2YWx1ZSA+Pj4gMTYgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAoIHZhbHVlID4+PiAyNCApXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdFdyaXRlVUludDMyKCB0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlIClcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvZmZzZXQgKyA0XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSggdmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9ICt2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhbm9Bc3NlcnQgKSBjaGVja0ludCggdGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB2YWx1ZSA8IDAgKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1tvZmZzZXRdID0gKCB2YWx1ZSA+Pj4gMjQgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAoIHZhbHVlID4+PiAxNiApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1tvZmZzZXQgKyAyXSA9ICggdmFsdWUgPj4+IDggKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAoIHZhbHVlICYgMHhmZiApXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdFdyaXRlVUludDMyKCB0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSApXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2Zmc2V0ICsgNFxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gY2hlY2tJRUVFNzU0KCBidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGggKSB0aHJvdyBuZXcgUmFuZ2VFcnJvciggJ0luZGV4IG91dCBvZiByYW5nZScgKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBvZmZzZXQgPCAwICkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoICdJbmRleCBvdXQgb2YgcmFuZ2UnIClcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHdyaXRlRmxvYXQoIGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggIW5vQXNzZXJ0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrSUVFRTc1NCggYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOCApXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZWVlNzU0LndyaXRlKCBidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQgKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9mZnNldCArIDRcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIEJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFKCB2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB3cml0ZUZsb2F0KCB0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydCApXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBCdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSggdmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gd3JpdGVGbG9hdCggdGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0IClcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHdyaXRlRG91YmxlKCBidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoICFub0Fzc2VydCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGVja0lFRUU3NTQoIGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCApXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZWVlNzU0LndyaXRlKCBidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDggKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9mZnNldCArIDhcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIEJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUoIHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdyaXRlRG91YmxlKCB0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydCApXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBCdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFKCB2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB3cml0ZURvdWJsZSggdGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0IClcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSggdGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggIXN0YXJ0ICkgc3RhcnQgPSAwXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoICFlbmQgJiYgZW5kICE9PSAwICkgZW5kID0gdGhpcy5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCApIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhdGFyZ2V0U3RhcnQgKSB0YXJnZXRTdGFydCA9IDBcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZW5kID4gMCAmJiBlbmQgPCBzdGFydCApIGVuZCA9IHN0YXJ0XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBlbmQgPT09IHN0YXJ0ICkgcmV0dXJuIDBcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCApIHJldHVybiAwXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdGFyZ2V0U3RhcnQgPCAwICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCAndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycgKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGggKSB0aHJvdyBuZXcgUmFuZ2VFcnJvciggJ3NvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMnIClcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZW5kIDwgMCApIHRocm93IG5ldyBSYW5nZUVycm9yKCAnc291cmNlRW5kIG91dCBvZiBib3VuZHMnIClcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXJlIHdlIG9vYj9cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZW5kID4gdGhpcy5sZW5ndGggKSBlbmQgPSB0aGlzLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdGhpcyA9PT0gdGFyZ2V0ICYmIHN0YXJ0IDwgdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0U3RhcnQgPCBlbmQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIGxlbiA8IDEwMDAgfHwgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFzY2VuZGluZyBjb3B5IGZyb20gc3RhcnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCBpID0gMDsgaSA8IGxlbjsgKytpICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdWJhcnJheSggc3RhcnQsIHN0YXJ0ICsgbGVuICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFN0YXJ0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGVuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBVc2FnZTpcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4gICAgICAgICAgICAgICAgICAgIC8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuICAgICAgICAgICAgICAgICAgICAvLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbiAgICAgICAgICAgICAgICAgICAgQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCggdmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCB0eXBlb2YgZW5kID09PSAnc3RyaW5nJyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB2YWwubGVuZ3RoID09PSAxICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KCAwIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBjb2RlIDwgMjU2ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gY29kZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCAnZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKCBlbmNvZGluZyApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCAnVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCB0eXBlb2YgdmFsID09PSAnbnVtYmVyJyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSB2YWwgJiAyNTVcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCAnT3V0IG9mIHJhbmdlIGluZGV4JyApXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZW5kIDw9IHN0YXJ0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhdmFsICkgdmFsID0gMFxuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB0eXBlb2YgdmFsID09PSAnbnVtYmVyJyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1tpXSA9IHZhbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKCB2YWwgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHZhbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHV0ZjhUb0J5dGVzKCBuZXcgQnVmZmVyKCB2YWwsIGVuY29kaW5nICkudG9TdHJpbmcoKSApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBIRUxQRVIgRlVOQ1RJT05TXG4gICAgICAgICAgICAgICAgICAgIC8vID09PT09PT09PT09PT09PT1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rXFwvMC05QS1aYS16LV9dL2dcblxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBiYXNlNjRjbGVhbiggc3RyICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHIgPSBzdHJpbmd0cmltKCBzdHIgKS5yZXBsYWNlKCBJTlZBTElEX0JBU0U2NF9SRSwgJycgKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBzdHIubGVuZ3RoIDwgMiApIHJldHVybiAnJ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIHN0ci5sZW5ndGggJSA0ICE9PSAwICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciA9IHN0ciArICc9J1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0clxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gc3RyaW5ndHJpbSggc3RyICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBzdHIudHJpbSApIHJldHVybiBzdHIudHJpbSgpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoIC9eXFxzK3xcXHMrJC9nLCAnJyApXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiB0b0hleCggbiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggbiA8IDE2ICkgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoIDE2IClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuLnRvU3RyaW5nKCAxNiApXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiB1dGY4VG9CeXRlcyggc3RyaW5nLCB1bml0cyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2RlUG9pbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBieXRlcyA9IFtdXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KCBpIClcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggIWxlYWRTdXJyb2dhdGUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBjb2RlUG9pbnQgPiAweERCRkYgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggKCB1bml0cyAtPSAzICkgPiAtMSApIGJ5dGVzLnB1c2goIDB4RUYsIDB4QkYsIDB4QkQgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBpICsgMSA9PT0gbGVuZ3RoICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoICggdW5pdHMgLT0gMyApID4gLTEgKSBieXRlcy5wdXNoKCAweEVGLCAweEJGLCAweEJEIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggY29kZVBvaW50IDwgMHhEQzAwICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAoIHVuaXRzIC09IDMgKSA+IC0xICkgYnl0ZXMucHVzaCggMHhFRiwgMHhCRiwgMHhCRCApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZVBvaW50ID0gKCBsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwICkgKyAweDEwMDAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICggbGVhZFN1cnJvZ2F0ZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoICggdW5pdHMgLT0gMyApID4gLTEgKSBieXRlcy5wdXNoKCAweEVGLCAweEJGLCAweEJEIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZW5jb2RlIHV0ZjhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGNvZGVQb2ludCA8IDB4ODAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggKCB1bml0cyAtPSAxICkgPCAwICkgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZXMucHVzaCggY29kZVBvaW50IClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBjb2RlUG9pbnQgPCAweDgwMCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAoIHVuaXRzIC09IDIgKSA8IDAgKSBicmVha1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBieXRlcy5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICggY29kZVBvaW50IDwgMHgxMDAwMCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAoIHVuaXRzIC09IDMgKSA8IDAgKSBicmVha1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBieXRlcy5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICggY29kZVBvaW50IDwgMHgxMTAwMDAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggKCB1bml0cyAtPSA0ICkgPCAwICkgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoICdJbnZhbGlkIGNvZGUgcG9pbnQnIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBieXRlc1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gYXNjaWlUb0J5dGVzKCBzdHIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBieXRlQXJyYXkucHVzaCggc3RyLmNoYXJDb2RlQXQoIGkgKSAmIDB4RkYgKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJ5dGVBcnJheVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMoIHN0ciwgdW5pdHMgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYywgaGksIGxvXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoICggdW5pdHMgLT0gMiApIDwgMCApIGJyZWFrXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjID0gc3RyLmNoYXJDb2RlQXQoIGkgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpID0gYyA+PiA4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG8gPSBjICUgMjU2XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZUFycmF5LnB1c2goIGxvIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBieXRlQXJyYXkucHVzaCggaGkgKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYnl0ZUFycmF5XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBiYXNlNjRUb0J5dGVzKCBzdHIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KCBiYXNlNjRjbGVhbiggc3RyICkgKVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gYmxpdEJ1ZmZlciggc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAoIGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCApIHx8ICggaSA+PSBzcmMubGVuZ3RoICkgKSBicmVha1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGlzbmFuKCB2YWwgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsICE9PSB2YWwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL1xufS5jYWxsKCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKCAyNiApLkJ1ZmZlciwgKCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KCkgKSApIClcblxuICAgICAgICAgICAgICAgIC8qKiovXG59LFxuLyogMjcgKi9cbi8qKiovIGZ1bmN0aW9uICggbW9kdWxlLCBleHBvcnRzICkge1xuXG4gICAgICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBwYXRoR2V0dGVyO1xuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gcGF0aEdldHRlciggb2JqLCBwYXRoICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIHBhdGggIT09ICckJyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXRocyA9IGdldFBhdGhzKCBwYXRoICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBwYXRocy5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoID0gcGF0aHNbaV0udG9TdHJpbmcoKS5yZXBsYWNlKCAvXFxcXFwiL2csICdcIicgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmogPSBvYmpbcGF0aF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBnZXRQYXRocyggcGF0aFN0cmluZyApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlZ2V4ID0gLyg/OlxcLihcXHcrKSl8KD86XFxbKFxcZCspXFxdKXwoPzpcXFtcIigoPzpbXlxcXFxcIl18XFxcXC4pKilcIlxcXSkvZztcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGNoZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGNoO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIG1hdGNoID0gcmVnZXguZXhlYyggcGF0aFN0cmluZyApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlcy5wdXNoKCBtYXRjaFsxXSB8fCBtYXRjaFsyXSB8fCBtYXRjaFszXSApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaGVzO1xuICAgICAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICAgICAgLyoqKi9cbn0sXG4vKiAyOCAqL1xuLyoqKi8gZnVuY3Rpb24gKCBtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18gKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgZ2V0TmF0aXZlID0gX193ZWJwYWNrX3JlcXVpcmVfXyggMiApLFxuICAgICAgICAgICAgICAgICAgICByb290ID0gX193ZWJwYWNrX3JlcXVpcmVfXyggMSApO1xuXG4gICAgICAgICAgICAgICAgLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xuICAgICAgICAgICAgICAgIHZhciBTZXQgPSBnZXROYXRpdmUoIHJvb3QsICdTZXQnICk7XG5cbiAgICAgICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IFNldDtcblxuXG4gICAgICAgICAgICAgICAgLyoqKi9cbn0sXG4vKiAyOSAqL1xuLyoqKi8gZnVuY3Rpb24gKCBtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18gKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgTGlzdENhY2hlID0gX193ZWJwYWNrX3JlcXVpcmVfXyggNSApLFxuICAgICAgICAgICAgICAgICAgICBzdGFja0NsZWFyID0gX193ZWJwYWNrX3JlcXVpcmVfXyggMTQxICksXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrRGVsZXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXyggMTQyICksXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrR2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyggMTQzICksXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrSGFzID0gX193ZWJwYWNrX3JlcXVpcmVfXyggMTQ0ICksXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrU2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyggMTQ1ICk7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBDcmVhdGVzIGEgc3RhY2sgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gU3RhY2soIGVudHJpZXMgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGUoIGVudHJpZXMgKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEFkZCBtZXRob2RzIHRvIGBTdGFja2AuXG4gICAgICAgICAgICAgICAgU3RhY2sucHJvdG90eXBlLmNsZWFyID0gc3RhY2tDbGVhcjtcbiAgICAgICAgICAgICAgICBTdGFjay5wcm90b3R5cGVbJ2RlbGV0ZSddID0gc3RhY2tEZWxldGU7XG4gICAgICAgICAgICAgICAgU3RhY2sucHJvdG90eXBlLmdldCA9IHN0YWNrR2V0O1xuICAgICAgICAgICAgICAgIFN0YWNrLnByb3RvdHlwZS5oYXMgPSBzdGFja0hhcztcbiAgICAgICAgICAgICAgICBTdGFjay5wcm90b3R5cGUuc2V0ID0gc3RhY2tTZXQ7XG5cbiAgICAgICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IFN0YWNrO1xuXG5cbiAgICAgICAgICAgICAgICAvKioqL1xufSxcbi8qIDMwICovXG4vKioqLyBmdW5jdGlvbiAoIG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyApIHtcblxuICAgICAgICAgICAgICAgIHZhciBiYXNlSW5kZXhPZiA9IF9fd2VicGFja19yZXF1aXJlX18oIDg2ICk7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uaW5jbHVkZXNgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgICAgICAgICAgICAgICAqIHNwZWNpZnlpbmcgYW4gaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHsqfSB0YXJnZXQgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB0YXJnZXRgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gYXJyYXlJbmNsdWRlcyggYXJyYXksIHZhbHVlICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gISFsZW5ndGggJiYgYmFzZUluZGV4T2YoIGFycmF5LCB2YWx1ZSwgMCApID4gLTE7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBhcnJheUluY2x1ZGVzO1xuXG5cbiAgICAgICAgICAgICAgICAvKioqL1xufSxcbi8qIDMxICovXG4vKioqLyBmdW5jdGlvbiAoIG1vZHVsZSwgZXhwb3J0cyApIHtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYXJyYXlJbmNsdWRlc2AgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBhIGNvbXBhcmF0b3IuXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHsqfSB0YXJnZXQgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyYXRvciBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdGFyZ2V0YCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGFycmF5SW5jbHVkZXNXaXRoKCBhcnJheSwgdmFsdWUsIGNvbXBhcmF0b3IgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICggKytpbmRleCA8IGxlbmd0aCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggY29tcGFyYXRvciggdmFsdWUsIGFycmF5W2luZGV4XSApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGFycmF5SW5jbHVkZXNXaXRoO1xuXG5cbiAgICAgICAgICAgICAgICAvKioqL1xufSxcbi8qIDMyICovXG4vKioqLyBmdW5jdGlvbiAoIG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyApIHtcblxuICAgICAgICAgICAgICAgIHZhciBhcnJheVB1c2ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCA3NyApLFxuICAgICAgICAgICAgICAgICAgICBpc0ZsYXR0ZW5hYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyggMTE3ICk7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mbGF0dGVuYCB3aXRoIHN1cHBvcnQgZm9yIHJlc3RyaWN0aW5nIGZsYXR0ZW5pbmcuXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZXB0aCBUaGUgbWF4aW11bSByZWN1cnNpb24gZGVwdGguXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbcHJlZGljYXRlPWlzRmxhdHRlbmFibGVdIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbaXNTdHJpY3RdIFJlc3RyaWN0IHRvIHZhbHVlcyB0aGF0IHBhc3MgYHByZWRpY2F0ZWAgY2hlY2tzLlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IFtyZXN1bHQ9W11dIFRoZSBpbml0aWFsIHJlc3VsdCB2YWx1ZS5cbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gYmFzZUZsYXR0ZW4oIGFycmF5LCBkZXB0aCwgcHJlZGljYXRlLCBpc1N0cmljdCwgcmVzdWx0ICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgICAgICAgICAgICAgICAgICBwcmVkaWNhdGUgfHwgKCBwcmVkaWNhdGUgPSBpc0ZsYXR0ZW5hYmxlICk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCB8fCAoIHJlc3VsdCA9IFtdICk7XG5cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCArK2luZGV4IDwgbGVuZ3RoICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBkZXB0aCA+IDAgJiYgcHJlZGljYXRlKCB2YWx1ZSApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZGVwdGggPiAxICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBmbGF0dGVuIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXNlRmxhdHRlbiggdmFsdWUsIGRlcHRoIC0gMSwgcHJlZGljYXRlLCBpc1N0cmljdCwgcmVzdWx0ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlQdXNoKCByZXN1bHQsIHZhbHVlICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICggIWlzU3RyaWN0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBiYXNlRmxhdHRlbjtcblxuXG4gICAgICAgICAgICAgICAgLyoqKi9cbn0sXG4vKiAzMyAqL1xuLyoqKi8gZnVuY3Rpb24gKCBtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18gKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgY2FzdFBhdGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCAzNyApLFxuICAgICAgICAgICAgICAgICAgICBpc0tleSA9IF9fd2VicGFja19yZXF1aXJlX18oIDggKSxcbiAgICAgICAgICAgICAgICAgICAgdG9LZXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCAxMCApO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZ2V0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZmF1bHQgdmFsdWVzLlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gYmFzZUdldCggb2JqZWN0LCBwYXRoICkge1xuICAgICAgICAgICAgICAgICAgICBwYXRoID0gaXNLZXkoIHBhdGgsIG9iamVjdCApID8gW3BhdGhdIDogY2FzdFBhdGgoIHBhdGggKTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCBvYmplY3QgIT0gbnVsbCAmJiBpbmRleCA8IGxlbmd0aCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdCA9IG9iamVjdFt0b0tleSggcGF0aFtpbmRleCsrXSApXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCBpbmRleCAmJiBpbmRleCA9PSBsZW5ndGggKSA/IG9iamVjdCA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGJhc2VHZXQ7XG5cblxuICAgICAgICAgICAgICAgIC8qKiovXG59LFxuLyogMzQgKi9cbi8qKiovIGZ1bmN0aW9uICggbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGJhc2VJc0VxdWFsRGVlcCA9IF9fd2VicGFja19yZXF1aXJlX18oIDg3ICksXG4gICAgICAgICAgICAgICAgICAgIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyggMTEgKSxcbiAgICAgICAgICAgICAgICAgICAgaXNPYmplY3RMaWtlID0gX193ZWJwYWNrX3JlcXVpcmVfXyggNCApO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNFcXVhbGAgd2hpY2ggc3VwcG9ydHMgcGFydGlhbCBjb21wYXJpc29uc1xuICAgICAgICAgICAgICAgICAqIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtiaXRtYXNrXSBUaGUgYml0bWFzayBvZiBjb21wYXJpc29uIGZsYWdzLlxuICAgICAgICAgICAgICAgICAqICBUaGUgYml0bWFzayBtYXkgYmUgY29tcG9zZWQgb2YgdGhlIGZvbGxvd2luZyBmbGFnczpcbiAgICAgICAgICAgICAgICAgKiAgICAgMSAtIFVub3JkZXJlZCBjb21wYXJpc29uXG4gICAgICAgICAgICAgICAgICogICAgIDIgLSBQYXJ0aWFsIGNvbXBhcmlzb25cbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGB2YWx1ZWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGJhc2VJc0VxdWFsKCB2YWx1ZSwgb3RoZXIsIGN1c3RvbWl6ZXIsIGJpdG1hc2ssIHN0YWNrICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIHZhbHVlID09PSBvdGhlciApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICggdmFsdWUgPT0gbnVsbCB8fCBvdGhlciA9PSBudWxsIHx8ICggIWlzT2JqZWN0KCB2YWx1ZSApICYmICFpc09iamVjdExpa2UoIG90aGVyICkgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBiYXNlSXNFcXVhbERlZXAoIHZhbHVlLCBvdGhlciwgYmFzZUlzRXF1YWwsIGN1c3RvbWl6ZXIsIGJpdG1hc2ssIHN0YWNrICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNFcXVhbDtcblxuXG4gICAgICAgICAgICAgICAgLyoqKi9cbn0sXG4vKiAzNSAqL1xuLyoqKi8gZnVuY3Rpb24gKCBtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18gKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgaWRlbnRpdHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCAxOSApLFxuICAgICAgICAgICAgICAgICAgICBvdmVyUmVzdCA9IF9fd2VicGFja19yZXF1aXJlX18oIDEzNiApLFxuICAgICAgICAgICAgICAgICAgICBzZXRUb1N0cmluZyA9IF9fd2VicGFja19yZXF1aXJlX18oIDEzOSApO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmVzdGAgd2hpY2ggZG9lc24ndCB2YWxpZGF0ZSBvciBjb2VyY2UgYXJndW1lbnRzLlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBiYXNlUmVzdCggZnVuYywgc3RhcnQgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXRUb1N0cmluZyggb3ZlclJlc3QoIGZ1bmMsIHN0YXJ0LCBpZGVudGl0eSApLCBmdW5jICsgJycgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGJhc2VSZXN0O1xuXG5cbiAgICAgICAgICAgICAgICAvKioqL1xufSxcbi8qIDM2ICovXG4vKioqLyBmdW5jdGlvbiAoIG1vZHVsZSwgZXhwb3J0cyApIHtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuYXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIHN0b3JpbmcgbWV0YWRhdGEuXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBiYXNlVW5hcnkoIGZ1bmMgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoIHZhbHVlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmMoIHZhbHVlICk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBiYXNlVW5hcnk7XG5cblxuICAgICAgICAgICAgICAgIC8qKiovXG59LFxuLyogMzcgKi9cbi8qKiovIGZ1bmN0aW9uICggbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGlzQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCAzICksXG4gICAgICAgICAgICAgICAgICAgIHN0cmluZ1RvUGF0aCA9IF9fd2VicGFja19yZXF1aXJlX18oIDE0NyApO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQ2FzdHMgYHZhbHVlYCB0byBhIHBhdGggYXJyYXkgaWYgaXQncyBub3Qgb25lLlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY2FzdCBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGNhc3RQYXRoKCB2YWx1ZSApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzQXJyYXkoIHZhbHVlICkgPyB2YWx1ZSA6IHN0cmluZ1RvUGF0aCggdmFsdWUgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGNhc3RQYXRoO1xuXG5cbiAgICAgICAgICAgICAgICAvKioqL1xufSxcbi8qIDM4ICovXG4vKioqLyBmdW5jdGlvbiAoIG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyApIHtcblxuICAgICAgICAgICAgICAgIHZhciBTZXRDYWNoZSA9IF9fd2VicGFja19yZXF1aXJlX18oIDE1ICksXG4gICAgICAgICAgICAgICAgICAgIGFycmF5U29tZSA9IF9fd2VicGFja19yZXF1aXJlX18oIDc4ICksXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlSGFzID0gX193ZWJwYWNrX3JlcXVpcmVfXyggMTcgKTtcblxuICAgICAgICAgICAgICAgIC8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIGNvbXBhcmlzb24gc3R5bGVzLiAqL1xuICAgICAgICAgICAgICAgIHZhciBVTk9SREVSRURfQ09NUEFSRV9GTEFHID0gMSxcbiAgICAgICAgICAgICAgICAgICAgUEFSVElBTF9DT01QQVJFX0ZMQUcgPSAyO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBhcnJheXMgd2l0aCBzdXBwb3J0IGZvclxuICAgICAgICAgICAgICAgICAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhcmUuXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheX0gb3RoZXIgVGhlIG90aGVyIGFycmF5IHRvIGNvbXBhcmUuXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBvZiBjb21wYXJpc29uIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYFxuICAgICAgICAgICAgICAgICAqICBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBhcnJheWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFycmF5cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGVxdWFsQXJyYXlzKCBhcnJheSwgb3RoZXIsIGVxdWFsRnVuYywgY3VzdG9taXplciwgYml0bWFzaywgc3RhY2sgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgUEFSVElBTF9DT01QQVJFX0ZMQUcsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJMZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBvdGhMZW5ndGggPSBvdGhlci5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBhcnJMZW5ndGggIT0gb3RoTGVuZ3RoICYmICEoIGlzUGFydGlhbCAmJiBvdGhMZW5ndGggPiBhcnJMZW5ndGggKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KCBhcnJheSApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIHN0YWNrZWQgJiYgc3RhY2suZ2V0KCBvdGhlciApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VlbiA9ICggYml0bWFzayAmIFVOT1JERVJFRF9DT01QQVJFX0ZMQUcgKSA/IG5ldyBTZXRDYWNoZSA6IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgICAgICAgICBzdGFjay5zZXQoIGFycmF5LCBvdGhlciApO1xuICAgICAgICAgICAgICAgICAgICBzdGFjay5zZXQoIG90aGVyLCBhcnJheSApO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSBub24taW5kZXggcHJvcGVydGllcy5cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCArK2luZGV4IDwgYXJyTGVuZ3RoICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyclZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG90aFZhbHVlID0gb3RoZXJbaW5kZXhdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGN1c3RvbWl6ZXIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gY3VzdG9taXplciggb3RoVmFsdWUsIGFyclZhbHVlLCBpbmRleCwgb3RoZXIsIGFycmF5LCBzdGFjayApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogY3VzdG9taXplciggYXJyVmFsdWUsIG90aFZhbHVlLCBpbmRleCwgYXJyYXksIG90aGVyLCBzdGFjayApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBjb21wYXJlZCAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggY29tcGFyZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHNlZW4gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhYXJyYXlTb21lKCBvdGhlciwgZnVuY3Rpb24gKCBvdGhWYWx1ZSwgb3RoSW5kZXggKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggIWNhY2hlSGFzKCBzZWVuLCBvdGhJbmRleCApICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMoIGFyclZhbHVlLCBvdGhWYWx1ZSwgY3VzdG9taXplciwgYml0bWFzaywgc3RhY2sgKSApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlZW4ucHVzaCggb3RoSW5kZXggKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoICEoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXF1YWxGdW5jKCBhcnJWYWx1ZSwgb3RoVmFsdWUsIGN1c3RvbWl6ZXIsIGJpdG1hc2ssIHN0YWNrIClcbiAgICAgICAgICAgICAgICAgICAgICAgICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3RhY2tbJ2RlbGV0ZSddKCBhcnJheSApO1xuICAgICAgICAgICAgICAgICAgICBzdGFja1snZGVsZXRlJ10oIG90aGVyICk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBlcXVhbEFycmF5cztcblxuXG4gICAgICAgICAgICAgICAgLyoqKi9cbn0sXG4vKiAzOSAqL1xuLyoqKi8gZnVuY3Rpb24gKCBtb2R1bGUsIGV4cG9ydHMgKSB7XG5cblx0LyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKCBmdW5jdGlvbiAoIGdsb2JhbCApIHsvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xuICAgICAgICAgICAgICAgICAgICB2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmcmVlR2xvYmFsO1xuXG4gICAgICAgICAgICAgICAgICAgIC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL1xufS5jYWxsKCBleHBvcnRzLCAoIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0oKSApICkgKVxuXG4gICAgICAgICAgICAgICAgLyoqKi9cbn0sXG4vKiA0MCAqL1xuLyoqKi8gZnVuY3Rpb24gKCBtb2R1bGUsIGV4cG9ydHMgKSB7XG5cbiAgICAgICAgICAgICAgICAvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbiAgICAgICAgICAgICAgICB2YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbiAgICAgICAgICAgICAgICAvKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG4gICAgICAgICAgICAgICAgdmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXFxkKikkLztcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBpc0luZGV4KCB2YWx1ZSwgbGVuZ3RoICkge1xuICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhIWxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKCB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgfHwgcmVJc1VpbnQudGVzdCggdmFsdWUgKSApICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGggKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGlzSW5kZXg7XG5cblxuICAgICAgICAgICAgICAgIC8qKiovXG59LFxuLyogNDEgKi9cbi8qKiovIGZ1bmN0aW9uICggbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyggMTEgKTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlmIHN1aXRhYmxlIGZvciBzdHJpY3RcbiAgICAgICAgICAgICAgICAgKiAgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGVsc2UgYGZhbHNlYC5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBpc1N0cmljdENvbXBhcmFibGUoIHZhbHVlICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgPT09IHZhbHVlICYmICFpc09iamVjdCggdmFsdWUgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGlzU3RyaWN0Q29tcGFyYWJsZTtcblxuXG4gICAgICAgICAgICAgICAgLyoqKi9cbn0sXG4vKiA0MiAqL1xuLyoqKi8gZnVuY3Rpb24gKCBtb2R1bGUsIGV4cG9ydHMgKSB7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYG1hdGNoZXNQcm9wZXJ0eWAgZm9yIHNvdXJjZSB2YWx1ZXMgc3VpdGFibGVcbiAgICAgICAgICAgICAgICAgKiBmb3Igc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKCBrZXksIHNyY1ZhbHVlICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCBvYmplY3QgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG9iamVjdCA9PSBudWxsICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Rba2V5XSA9PT0gc3JjVmFsdWUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIHNyY1ZhbHVlICE9PSB1bmRlZmluZWQgfHwgKCBrZXkgaW4gT2JqZWN0KCBvYmplY3QgKSApICk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZTtcblxuXG4gICAgICAgICAgICAgICAgLyoqKi9cbn0sXG4vKiA0MyAqL1xuLyoqKi8gZnVuY3Rpb24gKCBtb2R1bGUsIGV4cG9ydHMgKSB7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBvdmVyQXJnKCBmdW5jLCB0cmFuc2Zvcm0gKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoIGFyZyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jKCB0cmFuc2Zvcm0oIGFyZyApICk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBvdmVyQXJnO1xuXG5cbiAgICAgICAgICAgICAgICAvKioqL1xufSxcbi8qIDQ0ICovXG4vKioqLyBmdW5jdGlvbiAoIG1vZHVsZSwgZXhwb3J0cyApIHtcblxuICAgICAgICAgICAgICAgIC8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbiAgICAgICAgICAgICAgICB2YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuXG4gICAgICAgICAgICAgICAgLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xuICAgICAgICAgICAgICAgIHZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBDb252ZXJ0cyBgZnVuY2AgdG8gaXRzIHNvdXJjZSBjb2RlLlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBwcm9jZXNzLlxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNvdXJjZSBjb2RlLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHRvU291cmNlKCBmdW5jICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIGZ1bmMgIT0gbnVsbCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmNUb1N0cmluZy5jYWxsKCBmdW5jICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoICggZSApIHsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCBmdW5jICsgJycgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKCBlICkgeyB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gdG9Tb3VyY2U7XG5cblxuICAgICAgICAgICAgICAgIC8qKiovXG59LFxuLyogNDUgKi9cbi8qKiovIGZ1bmN0aW9uICggbW9kdWxlLCBleHBvcnRzICkge1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogUGVyZm9ybXMgYVxuICAgICAgICAgICAgICAgICAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICAgICAgICAgICAgICogY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQuXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgICAgICogQG1lbWJlck9mIF9cbiAgICAgICAgICAgICAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgICAgICAgICAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAgICAgICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAgICAgICAgICAgICAgICAgKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gICAgICAgICAgICAgICAgICogLy8gPT4gdHJ1ZVxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAgICAgICAgICAgICAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogXy5lcSgnYScsICdhJyk7XG4gICAgICAgICAgICAgICAgICogLy8gPT4gdHJ1ZVxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAgICAgICAgICAgICAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogXy5lcShOYU4sIE5hTik7XG4gICAgICAgICAgICAgICAgICogLy8gPT4gdHJ1ZVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGVxKCB2YWx1ZSwgb3RoZXIgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgKCB2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBlcTtcblxuXG4gICAgICAgICAgICAgICAgLyoqKi9cbn0sXG4vKiA0NiAqL1xuLyoqKi8gZnVuY3Rpb24gKCBtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18gKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgaXNGdW5jdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oIDQ3ICksXG4gICAgICAgICAgICAgICAgICAgIGlzTGVuZ3RoID0gX193ZWJwYWNrX3JlcXVpcmVfXyggMjIgKTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhcnJheS1saWtlIGlmIGl0J3NcbiAgICAgICAgICAgICAgICAgKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gICAgICAgICAgICAgICAgICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAgICAgICAgICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAgICAgICAgICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICAgICAgICAgICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XG4gICAgICAgICAgICAgICAgICogLy8gPT4gdHJ1ZVxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICAgKiAvLyA9PiB0cnVlXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcbiAgICAgICAgICAgICAgICAgKiAvLyA9PiB0cnVlXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XG4gICAgICAgICAgICAgICAgICogLy8gPT4gZmFsc2VcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBpc0FycmF5TGlrZSggdmFsdWUgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKCB2YWx1ZS5sZW5ndGggKSAmJiAhaXNGdW5jdGlvbiggdmFsdWUgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXlMaWtlO1xuXG5cbiAgICAgICAgICAgICAgICAvKioqL1xufSxcbi8qIDQ3ICovXG4vKioqLyBmdW5jdGlvbiAoIG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyApIHtcblxuICAgICAgICAgICAgICAgIHZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oIDExICk7XG5cbiAgICAgICAgICAgICAgICAvKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG4gICAgICAgICAgICAgICAgdmFyIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgICAgICAgICAgICAgICAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nO1xuXG4gICAgICAgICAgICAgICAgLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xuICAgICAgICAgICAgICAgIHZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gICAgICAgICAgICAgICAgICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gICAgICAgICAgICAgICAgICogb2YgdmFsdWVzLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHZhciBvYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICAgICAgICAgICAgICogQHNpbmNlIDAuMS4wXG4gICAgICAgICAgICAgICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gICAgICAgICAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIF8uaXNGdW5jdGlvbihfKTtcbiAgICAgICAgICAgICAgICAgKiAvLyA9PiB0cnVlXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICAgICAgICAgICAgICAgICAqIC8vID0+IGZhbHNlXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gaXNGdW5jdGlvbiggdmFsdWUgKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAgICAgICAgICAgICAgICAgICAvLyBpbiBTYWZhcmkgOC05IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5IGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG4gICAgICAgICAgICAgICAgICAgIHZhciB0YWcgPSBpc09iamVjdCggdmFsdWUgKSA/IG9iamVjdFRvU3RyaW5nLmNhbGwoIHZhbHVlICkgOiAnJztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBpc0Z1bmN0aW9uO1xuXG5cbiAgICAgICAgICAgICAgICAvKioqL1xufSxcbi8qIDQ4ICovXG4vKioqLyBmdW5jdGlvbiAoIG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyApIHtcblxuICAgICAgICAgICAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgICAgICAgICAgIGV4cG9ydHMuZGVjb2RlID0gZXhwb3J0cy5wYXJzZSA9IF9fd2VicGFja19yZXF1aXJlX18oIDE2MCApO1xuICAgICAgICAgICAgICAgIGV4cG9ydHMuZW5jb2RlID0gZXhwb3J0cy5zdHJpbmdpZnkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCAxNjEgKTtcblxuXG4gICAgICAgICAgICAgICAgLyoqKi9cbn0sXG4vKiA0OSAqL1xuLyoqKi8gZnVuY3Rpb24gKCBtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18gKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgc2NFcnJvcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCAyNSApO1xuICAgICAgICAgICAgICAgIHZhciBJbnZhbGlkQWN0aW9uRXJyb3IgPSBzY0Vycm9ycy5JbnZhbGlkQWN0aW9uRXJyb3I7XG5cbiAgICAgICAgICAgICAgICB2YXIgUmVzcG9uc2UgPSBmdW5jdGlvbiAoIHNvY2tldCwgaWQgKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc29ja2V0ID0gc29ja2V0O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBSZXNwb25zZS5wcm90b3R5cGUuX3Jlc3BvbmQgPSBmdW5jdGlvbiAoIHJlc3BvbnNlRGF0YSApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCB0aGlzLnNlbnQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFjdGlvbkVycm9yKCAnUmVzcG9uc2UgJyArIHRoaXMuaWQgKyAnIGhhcyBhbHJlYWR5IGJlZW4gc2VudCcgKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNvY2tldC5zZW5kKCB0aGlzLnNvY2tldC5lbmNvZGUoIHJlc3BvbnNlRGF0YSApICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgUmVzcG9uc2UucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uICggZGF0YSApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCB0aGlzLmlkICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3BvbnNlRGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWQ6IHRoaXMuaWRcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGRhdGEgIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZURhdGEuZGF0YSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXNwb25kKCByZXNwb25zZURhdGEgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBSZXNwb25zZS5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoIGVycm9yLCBkYXRhICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIHRoaXMuaWQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXJyID0gc2NFcnJvcnMuZGVoeWRyYXRlRXJyb3IoIGVycm9yICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXNwb25zZURhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlkOiB0aGlzLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGRhdGEgIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZURhdGEuZGF0YSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Jlc3BvbmQoIHJlc3BvbnNlRGF0YSApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIFJlc3BvbnNlLnByb3RvdHlwZS5jYWxsYmFjayA9IGZ1bmN0aW9uICggZXJyb3IsIGRhdGEgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggZXJyb3IgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9yKCBlcnJvciwgZGF0YSApO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmQoIGRhdGEgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBtb2R1bGUuZXhwb3J0cy5SZXNwb25zZSA9IFJlc3BvbnNlO1xuXG5cbiAgICAgICAgICAgICAgICAvKioqL1xufSxcbi8qIDUwICovXG4vKioqLyBmdW5jdGlvbiAoIG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyApIHtcblxuXHQvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oIGZ1bmN0aW9uICggZ2xvYmFsLCBCdWZmZXIgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBTQ0VtaXR0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCAxMiApLlNDRW1pdHRlcjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIFNDQ2hhbm5lbCA9IF9fd2VicGFja19yZXF1aXJlX18oIDE2NiApLlNDQ2hhbm5lbDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIFJlc3BvbnNlID0gX193ZWJwYWNrX3JlcXVpcmVfXyggNDkgKS5SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIEF1dGhFbmdpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCAxNzAgKS5BdXRoRW5naW5lO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZm9ybWF0dGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyggMTY4ICk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBTQ1RyYW5zcG9ydCA9IF9fd2VicGFja19yZXF1aXJlX18oIDE3MiApLlNDVHJhbnNwb3J0O1xuICAgICAgICAgICAgICAgICAgICB2YXIgcXVlcnlzdHJpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCA0OCApO1xuICAgICAgICAgICAgICAgICAgICB2YXIgTGlua2VkTGlzdCA9IF9fd2VicGFja19yZXF1aXJlX18oIDY4ICk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiYXNlNjQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCA1NiApO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBzY0Vycm9ycyA9IF9fd2VicGFja19yZXF1aXJlX18oIDI1ICk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBJbnZhbGlkQXJndW1lbnRzRXJyb3IgPSBzY0Vycm9ycy5JbnZhbGlkQXJndW1lbnRzRXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIHZhciBJbnZhbGlkTWVzc2FnZUVycm9yID0gc2NFcnJvcnMuSW52YWxpZE1lc3NhZ2VFcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIFNvY2tldFByb3RvY29sRXJyb3IgPSBzY0Vycm9ycy5Tb2NrZXRQcm90b2NvbEVycm9yO1xuICAgICAgICAgICAgICAgICAgICB2YXIgVGltZW91dEVycm9yID0gc2NFcnJvcnMuVGltZW91dEVycm9yO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBpc0Jyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnO1xuXG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIFNDU29ja2V0ID0gZnVuY3Rpb24gKCBvcHRzICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBTQ0VtaXR0ZXIuY2FsbCggdGhpcyApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlkID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLkNMT1NFRDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXV0aFN0YXRlID0gdGhpcy5QRU5ESU5HO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zaWduZWRBdXRoVG9rZW4gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdXRoVG9rZW4gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nUmVjb25uZWN0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdSZWNvbm5lY3RUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0Nvbm5lY3RDYWxsYmFjayA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3RUaW1lb3V0ID0gb3B0cy5jb25uZWN0VGltZW91dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWNrVGltZW91dCA9IG9wdHMuYWNrVGltZW91dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhbm5lbFByZWZpeCA9IG9wdHMuY2hhbm5lbFByZWZpeCB8fCBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0T25VbmxvYWQgPSBvcHRzLmRpc2Nvbm5lY3RPblVubG9hZCA9PSBudWxsID8gdHJ1ZSA6IG9wdHMuZGlzY29ubmVjdE9uVW5sb2FkO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwaW5nVGltZW91dCB3aWxsIGJlIGFja1RpbWVvdXQgYXQgdGhlIHN0YXJ0LCBidXQgaXQgd2lsbFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYmUgdXBkYXRlZCB3aXRoIHZhbHVlcyBwcm92aWRlZCBieSB0aGUgJ2Nvbm5lY3QnIGV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBpbmdUaW1lb3V0ID0gdGhpcy5hY2tUaW1lb3V0O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWF4VGltZW91dCA9IE1hdGgucG93KCAyLCAzMSApIC0gMTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZlcmlmeUR1cmF0aW9uID0gZnVuY3Rpb24gKCBwcm9wZXJ0eU5hbWUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBzZWxmW3Byb3BlcnR5TmFtZV0gPiBtYXhUaW1lb3V0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0Vycm9yKCAnVGhlICcgKyBwcm9wZXJ0eU5hbWUgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyB2YWx1ZSBwcm92aWRlZCBleGNlZWRlZCB0aGUgbWF4aW11bSBhbW91bnQgYWxsb3dlZCcgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZXJpZnlEdXJhdGlvbiggJ2Nvbm5lY3RUaW1lb3V0JyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmVyaWZ5RHVyYXRpb24oICdhY2tUaW1lb3V0JyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmVyaWZ5RHVyYXRpb24oICdwaW5nVGltZW91dCcgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9jYWxFdmVudHMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2Nvbm5lY3QnOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdjb25uZWN0QWJvcnQnOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdkaXNjb25uZWN0JzogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbWVzc2FnZSc6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2Vycm9yJzogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAncmF3JzogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZmFpbCc6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2tpY2tPdXQnOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdzdWJzY3JpYmUnOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICd1bnN1YnNjcmliZSc6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3N1YnNjcmliZVN0YXRlQ2hhbmdlJzogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnYXV0aFN0YXRlQ2hhbmdlJzogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnYXV0aGVudGljYXRlJzogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZGVhdXRoZW50aWNhdGUnOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdyZW1vdmVBdXRoVG9rZW4nOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdzdWJzY3JpYmVSZXF1ZXN0JzogMVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0QXR0ZW1wdHMgPSAwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbWl0QnVmZmVyID0gbmV3IExpbmtlZExpc3QoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5uZWxzID0ge307XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdHM7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NpZCA9IDE7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5jYWxsSWRHZW5lcmF0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2NhbGxJZEdlbmVyYXRvcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB0aGlzLm9wdGlvbnMuYXV0b1JlY29ubmVjdCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHRoaXMub3B0aW9ucy5hdXRvUmVjb25uZWN0T3B0aW9ucyA9PSBudWxsICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuYXV0b1JlY29ubmVjdE9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGQgcHJvcGVydGllcyB0byB0aGUgdGhpcy5vcHRpb25zLmF1dG9SZWNvbm5lY3RPcHRpb25zIG9iamVjdC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBhc3NpZ24gdGhlIHJlZmVyZW5jZSB0byBhIHJlY29ubmVjdE9wdGlvbnMgdmFyaWFibGUgdG8gYXZvaWQgcmVwZXRpdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVjb25uZWN0T3B0aW9ucyA9IHRoaXMub3B0aW9ucy5hdXRvUmVjb25uZWN0T3B0aW9ucztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHJlY29ubmVjdE9wdGlvbnMuaW5pdGlhbERlbGF5ID09IG51bGwgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY29ubmVjdE9wdGlvbnMuaW5pdGlhbERlbGF5ID0gMTAwMDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggcmVjb25uZWN0T3B0aW9ucy5yYW5kb21uZXNzID09IG51bGwgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY29ubmVjdE9wdGlvbnMucmFuZG9tbmVzcyA9IDEwMDAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHJlY29ubmVjdE9wdGlvbnMubXVsdGlwbGllciA9PSBudWxsICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWNvbm5lY3RPcHRpb25zLm11bHRpcGxpZXIgPSAxLjU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggcmVjb25uZWN0T3B0aW9ucy5tYXhEZWxheSA9PSBudWxsICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWNvbm5lY3RPcHRpb25zLm1heERlbGF5ID0gNjAwMDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHRoaXMub3B0aW9ucy5zdWJzY3JpcHRpb25SZXRyeU9wdGlvbnMgPT0gbnVsbCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuc3Vic2NyaXB0aW9uUmV0cnlPcHRpb25zID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdGhpcy5vcHRpb25zLmF1dGhFbmdpbmUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdXRoID0gdGhpcy5vcHRpb25zLmF1dGhFbmdpbmU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXV0aCA9IG5ldyBBdXRoRW5naW5lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdGhpcy5vcHRpb25zLmNvZGVjRW5naW5lICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29kZWMgPSB0aGlzLm9wdGlvbnMuY29kZWNFbmdpbmU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlZmF1bHQgY29kZWMgZW5naW5lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2RlYyA9IGZvcm1hdHRlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnBhdGggPSB0aGlzLm9wdGlvbnMucGF0aC5yZXBsYWNlKCAvXFwvJC8sICcnICkgKyAnLyc7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5xdWVyeSA9IG9wdHMucXVlcnkgfHwge307XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHR5cGVvZiB0aGlzLm9wdGlvbnMucXVlcnkgPT0gJ3N0cmluZycgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnF1ZXJ5ID0gcXVlcnlzdHJpbmcucGFyc2UoIHRoaXMub3B0aW9ucy5xdWVyeSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3QoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hhbm5lbEVtaXR0ZXIgPSBuZXcgU0NFbWl0dGVyKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggaXNCcm93c2VyICYmIHRoaXMuZGlzY29ubmVjdE9uVW5sb2FkICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1bmxvYWRIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB0eXBlb2YgYXR0YWNoRXZlbnQgIT09ICd1bmRlZmluZWQnICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRhY2hFdmVudCggJ29udW5sb2FkJywgdW5sb2FkSGFuZGxlciApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIHR5cGVvZiBhZGRFdmVudExpc3RlbmVyICE9PSAndW5kZWZpbmVkJyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lciggJ2JlZm9yZXVubG9hZCcsIHVubG9hZEhhbmRsZXIsIGZhbHNlICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIFNDU29ja2V0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFNDRW1pdHRlci5wcm90b3R5cGUgKTtcblxuICAgICAgICAgICAgICAgICAgICBTQ1NvY2tldC5DT05ORUNUSU5HID0gU0NTb2NrZXQucHJvdG90eXBlLkNPTk5FQ1RJTkcgPSBTQ1RyYW5zcG9ydC5wcm90b3R5cGUuQ09OTkVDVElORztcbiAgICAgICAgICAgICAgICAgICAgU0NTb2NrZXQuT1BFTiA9IFNDU29ja2V0LnByb3RvdHlwZS5PUEVOID0gU0NUcmFuc3BvcnQucHJvdG90eXBlLk9QRU47XG4gICAgICAgICAgICAgICAgICAgIFNDU29ja2V0LkNMT1NFRCA9IFNDU29ja2V0LnByb3RvdHlwZS5DTE9TRUQgPSBTQ1RyYW5zcG9ydC5wcm90b3R5cGUuQ0xPU0VEO1xuXG4gICAgICAgICAgICAgICAgICAgIFNDU29ja2V0LkFVVEhFTlRJQ0FURUQgPSBTQ1NvY2tldC5wcm90b3R5cGUuQVVUSEVOVElDQVRFRCA9ICdhdXRoZW50aWNhdGVkJztcbiAgICAgICAgICAgICAgICAgICAgU0NTb2NrZXQuVU5BVVRIRU5USUNBVEVEID0gU0NTb2NrZXQucHJvdG90eXBlLlVOQVVUSEVOVElDQVRFRCA9ICd1bmF1dGhlbnRpY2F0ZWQnO1xuICAgICAgICAgICAgICAgICAgICBTQ1NvY2tldC5QRU5ESU5HID0gU0NTb2NrZXQucHJvdG90eXBlLlBFTkRJTkcgPSAncGVuZGluZyc7XG5cbiAgICAgICAgICAgICAgICAgICAgU0NTb2NrZXQuaWdub3JlU3RhdHVzZXMgPSBzY0Vycm9ycy5zb2NrZXRQcm90b2NvbElnbm9yZVN0YXR1c2VzO1xuICAgICAgICAgICAgICAgICAgICBTQ1NvY2tldC5lcnJvclN0YXR1c2VzID0gc2NFcnJvcnMuc29ja2V0UHJvdG9jb2xFcnJvclN0YXR1c2VzO1xuXG4gICAgICAgICAgICAgICAgICAgIFNDU29ja2V0LnByb3RvdHlwZS5fcHJpdmF0ZUV2ZW50SGFuZGxlck1hcCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICcjcHVibGlzaCc6IGZ1bmN0aW9uICggZGF0YSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdW5kZWNvcmF0ZWRDaGFubmVsTmFtZSA9IHRoaXMuX3VuZGVjb3JhdGVDaGFubmVsTmFtZSggZGF0YS5jaGFubmVsICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlzU3Vic2NyaWJlZCA9IHRoaXMuaXNTdWJzY3JpYmVkKCB1bmRlY29yYXRlZENoYW5uZWxOYW1lLCB0cnVlICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGlzU3Vic2NyaWJlZCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hhbm5lbEVtaXR0ZXIuZW1pdCggdW5kZWNvcmF0ZWRDaGFubmVsTmFtZSwgZGF0YS5kYXRhICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICcja2lja091dCc6IGZ1bmN0aW9uICggZGF0YSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdW5kZWNvcmF0ZWRDaGFubmVsTmFtZSA9IHRoaXMuX3VuZGVjb3JhdGVDaGFubmVsTmFtZSggZGF0YS5jaGFubmVsICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoYW5uZWwgPSB0aGlzLl9jaGFubmVsc1t1bmRlY29yYXRlZENoYW5uZWxOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGNoYW5uZWwgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNDRW1pdHRlci5wcm90b3R5cGUuZW1pdC5jYWxsKCB0aGlzLCAna2lja091dCcsIGRhdGEubWVzc2FnZSwgdW5kZWNvcmF0ZWRDaGFubmVsTmFtZSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsLmVtaXQoICdraWNrT3V0JywgZGF0YS5tZXNzYWdlLCB1bmRlY29yYXRlZENoYW5uZWxOYW1lICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3RyaWdnZXJDaGFubmVsVW5zdWJzY3JpYmUoIGNoYW5uZWwgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgJyNzZXRBdXRoVG9rZW4nOiBmdW5jdGlvbiAoIGRhdGEsIHJlc3BvbnNlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZGF0YSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRyaWdnZXJBdXRoZW50aWNhdGUgPSBmdW5jdGlvbiAoIGVyciApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZXJyICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBub24tZmF0YWwgZXJyb3IsIHdlIGRvbid0IHdhbnQgdG8gY2xvc2UgdGhlIGNvbm5lY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBiZWNhdXNlIG9mIHRoaXMgYnV0IHdlIGRvIHdhbnQgdG8gbm90aWZ5IHRoZSBzZXJ2ZXIgYW5kIHRocm93IGFuIGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb24gdGhlIGNsaWVudC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5lcnJvciggZXJyICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fb25TQ0Vycm9yKCBlcnIgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fY2hhbmdlVG9BdXRoZW50aWNhdGVkU3RhdGUoIGRhdGEudG9rZW4gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5lbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF1dGguc2F2ZVRva2VuKCB0aGlzLm9wdGlvbnMuYXV0aFRva2VuTmFtZSwgZGF0YS50b2tlbiwge30sIHRyaWdnZXJBdXRoZW50aWNhdGUgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5lcnJvciggbmV3IEludmFsaWRNZXNzYWdlRXJyb3IoICdObyB0b2tlbiBkYXRhIHByb3ZpZGVkIGJ5ICNzZXRBdXRoVG9rZW4gZXZlbnQnICkgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgJyNyZW1vdmVBdXRoVG9rZW4nOiBmdW5jdGlvbiAoIGRhdGEsIHJlc3BvbnNlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXV0aC5yZW1vdmVUb2tlbiggdGhpcy5vcHRpb25zLmF1dGhUb2tlbk5hbWUsIGZ1bmN0aW9uICggZXJyLCBvbGRUb2tlbiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBlcnIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOb24tZmF0YWwgZXJyb3IgLSBEbyBub3QgY2xvc2UgdGhlIGNvbm5lY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLmVycm9yKCBlcnIgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX29uU0NFcnJvciggZXJyICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTQ0VtaXR0ZXIucHJvdG90eXBlLmVtaXQuY2FsbCggc2VsZiwgJ3JlbW92ZUF1dGhUb2tlbicsIG9sZFRva2VuICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9jaGFuZ2VUb1VuYXV0aGVudGljYXRlZFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5lbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAnI2Rpc2Nvbm5lY3QnOiBmdW5jdGlvbiAoIGRhdGEgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQuY2xvc2UoIGRhdGEuY29kZSwgZGF0YS5kYXRhICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgU0NTb2NrZXQucHJvdG90eXBlLl9jYWxsSWRHZW5lcmF0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY2lkKys7XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgU0NTb2NrZXQucHJvdG90eXBlLmdldFN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGU7XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgU0NTb2NrZXQucHJvdG90eXBlLmdldEJ5dGVzUmVjZWl2ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc3BvcnQuZ2V0Qnl0ZXNSZWNlaXZlZCgpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIFNDU29ja2V0LnByb3RvdHlwZS5kZWF1dGhlbnRpY2F0ZSA9IGZ1bmN0aW9uICggY2FsbGJhY2sgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXV0aC5yZW1vdmVUb2tlbiggdGhpcy5vcHRpb25zLmF1dGhUb2tlbk5hbWUsIGZ1bmN0aW9uICggZXJyLCBvbGRUb2tlbiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGVyciApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm9uLWZhdGFsIGVycm9yIC0gRG8gbm90IGNsb3NlIHRoZSBjb25uZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX29uU0NFcnJvciggZXJyICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5lbWl0KCAnI3JlbW92ZUF1dGhUb2tlbicgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU0NFbWl0dGVyLnByb3RvdHlwZS5lbWl0LmNhbGwoIHNlbGYsICdyZW1vdmVBdXRoVG9rZW4nLCBvbGRUb2tlbiApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9jaGFuZ2VUb1VuYXV0aGVudGljYXRlZFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCBlcnIgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICBTQ1NvY2tldC5wcm90b3R5cGUuY29ubmVjdCA9IFNDU29ja2V0LnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHRoaXMuc3RhdGUgPT0gdGhpcy5DTE9TRUQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nUmVjb25uZWN0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nUmVjb25uZWN0VGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KCB0aGlzLl9yZWNvbm5lY3RUaW1lb3V0UmVmICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gdGhpcy5DT05ORUNUSU5HO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZVRvUGVuZGluZ0F1dGhTdGF0ZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB0aGlzLnRyYW5zcG9ydCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQub2ZmKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQgPSBuZXcgU0NUcmFuc3BvcnQoIHRoaXMuYXV0aCwgdGhpcy5jb2RlYywgdGhpcy5vcHRpb25zICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYW5zcG9ydC5vbiggJ29wZW4nLCBmdW5jdGlvbiAoIHN0YXR1cyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5zdGF0ZSA9IHNlbGYuT1BFTjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fb25TQ09wZW4oIHN0YXR1cyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0Lm9uKCAnZXJyb3InLCBmdW5jdGlvbiAoIGVyciApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fb25TQ0Vycm9yKCBlcnIgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYW5zcG9ydC5vbiggJ2Nsb3NlJywgZnVuY3Rpb24gKCBjb2RlLCBkYXRhICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnN0YXRlID0gc2VsZi5DTE9TRUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX29uU0NDbG9zZSggY29kZSwgZGF0YSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0Lm9uKCAnb3BlbkFib3J0JywgZnVuY3Rpb24gKCBjb2RlLCBkYXRhICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnN0YXRlID0gc2VsZi5DTE9TRUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX29uU0NDbG9zZSggY29kZSwgZGF0YSwgdHJ1ZSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0Lm9uKCAnZXZlbnQnLCBmdW5jdGlvbiAoIGV2ZW50LCBkYXRhLCByZXMgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX29uU0NFdmVudCggZXZlbnQsIGRhdGEsIHJlcyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICBTQ1NvY2tldC5wcm90b3R5cGUucmVjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICBTQ1NvY2tldC5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uICggY29kZSwgZGF0YSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUgPSBjb2RlIHx8IDEwMDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdGhpcy5zdGF0ZSA9PSB0aGlzLk9QRU4gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhY2tldCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogY29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQuZW1pdCggJyNkaXNjb25uZWN0JywgcGFja2V0ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQuY2xvc2UoIGNvZGUsIGRhdGEgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICggdGhpcy5zdGF0ZSA9PSB0aGlzLkNPTk5FQ1RJTkcgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQuY2xvc2UoIGNvZGUsIGRhdGEgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nUmVjb25uZWN0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nUmVjb25uZWN0VGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KCB0aGlzLl9yZWNvbm5lY3RUaW1lb3V0UmVmICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgU0NTb2NrZXQucHJvdG90eXBlLl9jaGFuZ2VUb1BlbmRpbmdBdXRoU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHRoaXMuYXV0aFN0YXRlICE9IHRoaXMuUEVORElORyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2xkU3RhdGUgPSB0aGlzLmF1dGhTdGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF1dGhTdGF0ZSA9IHRoaXMuUEVORElORztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RhdGVDaGFuZ2VEYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbGRTdGF0ZTogb2xkU3RhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1N0YXRlOiB0aGlzLmF1dGhTdGF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgU0NFbWl0dGVyLnByb3RvdHlwZS5lbWl0LmNhbGwoIHRoaXMsICdhdXRoU3RhdGVDaGFuZ2UnLCBzdGF0ZUNoYW5nZURhdGEgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICBTQ1NvY2tldC5wcm90b3R5cGUuX2NoYW5nZVRvVW5hdXRoZW50aWNhdGVkU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHRoaXMuYXV0aFN0YXRlICE9IHRoaXMuVU5BVVRIRU5USUNBVEVEICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvbGRTdGF0ZSA9IHRoaXMuYXV0aFN0YXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXV0aFN0YXRlID0gdGhpcy5VTkFVVEhFTlRJQ0FURUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zaWduZWRBdXRoVG9rZW4gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXV0aFRva2VuID0gbnVsbDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdGF0ZUNoYW5nZURhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9sZFN0YXRlOiBvbGRTdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3U3RhdGU6IHRoaXMuYXV0aFN0YXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTQ0VtaXR0ZXIucHJvdG90eXBlLmVtaXQuY2FsbCggdGhpcywgJ2F1dGhTdGF0ZUNoYW5nZScsIHN0YXRlQ2hhbmdlRGF0YSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggb2xkU3RhdGUgPT0gdGhpcy5BVVRIRU5USUNBVEVEICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTQ0VtaXR0ZXIucHJvdG90eXBlLmVtaXQuY2FsbCggdGhpcywgJ2RlYXV0aGVudGljYXRlJyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTQ0VtaXR0ZXIucHJvdG90eXBlLmVtaXQuY2FsbCggdGhpcywgJ2F1dGhUb2tlbkNoYW5nZScsIHRoaXMuc2lnbmVkQXV0aFRva2VuICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgU0NTb2NrZXQucHJvdG90eXBlLl9jaGFuZ2VUb0F1dGhlbnRpY2F0ZWRTdGF0ZSA9IGZ1bmN0aW9uICggc2lnbmVkQXV0aFRva2VuICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zaWduZWRBdXRoVG9rZW4gPSBzaWduZWRBdXRoVG9rZW47XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF1dGhUb2tlbiA9IHRoaXMuX2V4dHJhY3RBdXRoVG9rZW5EYXRhKCBzaWduZWRBdXRoVG9rZW4gKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB0aGlzLmF1dGhTdGF0ZSAhPSB0aGlzLkFVVEhFTlRJQ0FURUQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9sZFN0YXRlID0gdGhpcy5hdXRoU3RhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdXRoU3RhdGUgPSB0aGlzLkFVVEhFTlRJQ0FURUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXRlQ2hhbmdlRGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkU3RhdGU6IG9sZFN0YXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdTdGF0ZTogdGhpcy5hdXRoU3RhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25lZEF1dGhUb2tlbjogc2lnbmVkQXV0aFRva2VuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdXRoVG9rZW46IHRoaXMuYXV0aFRva2VuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NQZW5kaW5nU3Vic2NyaXB0aW9ucygpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgU0NFbWl0dGVyLnByb3RvdHlwZS5lbWl0LmNhbGwoIHRoaXMsICdhdXRoU3RhdGVDaGFuZ2UnLCBzdGF0ZUNoYW5nZURhdGEgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTQ0VtaXR0ZXIucHJvdG90eXBlLmVtaXQuY2FsbCggdGhpcywgJ2F1dGhlbnRpY2F0ZScsIHNpZ25lZEF1dGhUb2tlbiApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgU0NFbWl0dGVyLnByb3RvdHlwZS5lbWl0LmNhbGwoIHRoaXMsICdhdXRoVG9rZW5DaGFuZ2UnLCBzaWduZWRBdXRoVG9rZW4gKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICBTQ1NvY2tldC5wcm90b3R5cGUuZGVjb2RlQmFzZTY0ID0gZnVuY3Rpb24gKCBlbmNvZGVkU3RyaW5nICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlY29kZWRTdHJpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHR5cGVvZiBCdWZmZXIgPT0gJ3VuZGVmaW5lZCcgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB0eXBlb2YgYXRvYiAhPT0gJ3VuZGVmaW5lZCcgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRTdHJpbmcgPSBhdG9iKCBlbmNvZGVkU3RyaW5nICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZFN0cmluZyA9IGJhc2U2NC5kZWNvZGUoIGVuY29kZWRTdHJpbmcgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBidWZmZXIgPSBuZXcgQnVmZmVyKCBlbmNvZGVkU3RyaW5nLCAnYmFzZTY0JyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRTdHJpbmcgPSBidWZmZXIudG9TdHJpbmcoICd1dGY4JyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlY29kZWRTdHJpbmc7XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgU0NTb2NrZXQucHJvdG90eXBlLmVuY29kZUJhc2U2NCA9IGZ1bmN0aW9uICggZGVjb2RlZFN0cmluZyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbmNvZGVkU3RyaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB0eXBlb2YgQnVmZmVyID09ICd1bmRlZmluZWQnICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdHlwZW9mIGJ0b2EgIT09ICd1bmRlZmluZWQnICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGVkU3RyaW5nID0gYnRvYSggZGVjb2RlZFN0cmluZyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kZWRTdHJpbmcgPSBiYXNlNjQuZW5jb2RlKCBkZWNvZGVkU3RyaW5nICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYnVmZmVyID0gbmV3IEJ1ZmZlciggZGVjb2RlZFN0cmluZywgJ3V0ZjgnICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RlZFN0cmluZyA9IGJ1ZmZlci50b1N0cmluZyggJ2Jhc2U2NCcgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbmNvZGVkU3RyaW5nO1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIFNDU29ja2V0LnByb3RvdHlwZS5fZXh0cmFjdEF1dGhUb2tlbkRhdGEgPSBmdW5jdGlvbiAoIHNpZ25lZEF1dGhUb2tlbiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0b2tlblBhcnRzID0gKCBzaWduZWRBdXRoVG9rZW4gfHwgJycgKS5zcGxpdCggJy4nICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5jb2RlZFRva2VuRGF0YSA9IHRva2VuUGFydHNbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGVuY29kZWRUb2tlbkRhdGEgIT0gbnVsbCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG9rZW5EYXRhID0gZW5jb2RlZFRva2VuRGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbkRhdGEgPSB0aGlzLmRlY29kZUJhc2U2NCggdG9rZW5EYXRhICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKCB0b2tlbkRhdGEgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoICggZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuRGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICBTQ1NvY2tldC5wcm90b3R5cGUuZ2V0QXV0aFRva2VuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXV0aFRva2VuO1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIFNDU29ja2V0LnByb3RvdHlwZS5nZXRTaWduZWRBdXRoVG9rZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zaWduZWRBdXRoVG9rZW47XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUGVyZm9ybSBjbGllbnQtaW5pdGlhdGVkIGF1dGhlbnRpY2F0aW9uIGJ5IHByb3ZpZGluZyBhbiBlbmNyeXB0ZWQgdG9rZW4gc3RyaW5nXG4gICAgICAgICAgICAgICAgICAgIFNDU29ja2V0LnByb3RvdHlwZS5hdXRoZW50aWNhdGUgPSBmdW5jdGlvbiAoIHNpZ25lZEF1dGhUb2tlbiwgY2FsbGJhY2sgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZVRvUGVuZGluZ0F1dGhTdGF0ZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoICcjYXV0aGVudGljYXRlJywgc2lnbmVkQXV0aFRva2VuLCBmdW5jdGlvbiAoIGVyciwgYXV0aFN0YXR1cyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGF1dGhTdGF0dXMgJiYgYXV0aFN0YXR1cy5hdXRoRXJyb3IgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dGhTdGF0dXMuYXV0aEVycm9yID0gc2NFcnJvcnMuaHlkcmF0ZUVycm9yKCBhdXRoU3RhdHVzLmF1dGhFcnJvciApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGVyciApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fY2hhbmdlVG9VbmF1dGhlbnRpY2F0ZWRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayggZXJyLCBhdXRoU3RhdHVzICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5hdXRoLnNhdmVUb2tlbiggc2VsZi5vcHRpb25zLmF1dGhUb2tlbk5hbWUsIHNpZ25lZEF1dGhUb2tlbiwge30sIGZ1bmN0aW9uICggZXJyICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soIGVyciwgYXV0aFN0YXR1cyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBlcnIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fY2hhbmdlVG9VbmF1dGhlbnRpY2F0ZWRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX29uU0NFcnJvciggZXJyICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggYXV0aFN0YXR1cy5pc0F1dGhlbnRpY2F0ZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2NoYW5nZVRvQXV0aGVudGljYXRlZFN0YXRlKCBzaWduZWRBdXRoVG9rZW4gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9jaGFuZ2VUb1VuYXV0aGVudGljYXRlZFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSApO1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIFNDU29ja2V0LnByb3RvdHlwZS5fdHJ5UmVjb25uZWN0ID0gZnVuY3Rpb24gKCBpbml0aWFsRGVsYXkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBleHBvbmVudCA9IHRoaXMuY29ubmVjdEF0dGVtcHRzKys7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVjb25uZWN0T3B0aW9ucyA9IHRoaXMub3B0aW9ucy5hdXRvUmVjb25uZWN0T3B0aW9ucztcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aW1lb3V0O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGluaXRpYWxEZWxheSA9PSBudWxsIHx8IGV4cG9uZW50ID4gMCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5pdGlhbFRpbWVvdXQgPSBNYXRoLnJvdW5kKCByZWNvbm5lY3RPcHRpb25zLmluaXRpYWxEZWxheSArICggcmVjb25uZWN0T3B0aW9ucy5yYW5kb21uZXNzIHx8IDAgKSAqIE1hdGgucmFuZG9tKCkgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBNYXRoLnJvdW5kKCBpbml0aWFsVGltZW91dCAqIE1hdGgucG93KCByZWNvbm5lY3RPcHRpb25zLm11bHRpcGxpZXIsIGV4cG9uZW50ICkgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZW91dCA9IGluaXRpYWxEZWxheTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB0aW1lb3V0ID4gcmVjb25uZWN0T3B0aW9ucy5tYXhEZWxheSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lb3V0ID0gcmVjb25uZWN0T3B0aW9ucy5tYXhEZWxheTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KCB0aGlzLl9yZWNvbm5lY3RUaW1lb3V0UmVmICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ1JlY29ubmVjdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdSZWNvbm5lY3RUaW1lb3V0ID0gdGltZW91dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlY29ubmVjdFRpbWVvdXRSZWYgPSBzZXRUaW1lb3V0KCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCB0aW1lb3V0ICk7XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgU0NTb2NrZXQucHJvdG90eXBlLl9vblNDT3BlbiA9IGZ1bmN0aW9uICggc3RhdHVzICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHN0YXR1cyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlkID0gc3RhdHVzLmlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGluZ1RpbWVvdXQgPSBzdGF0dXMucGluZ1RpbWVvdXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQucGluZ1RpbWVvdXQgPSB0aGlzLnBpbmdUaW1lb3V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggc3RhdHVzLmlzQXV0aGVudGljYXRlZCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlVG9BdXRoZW50aWNhdGVkU3RhdGUoIHN0YXR1cy5hdXRoVG9rZW4gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VUb1VuYXV0aGVudGljYXRlZFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VUb1VuYXV0aGVudGljYXRlZFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdEF0dGVtcHRzID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdGhpcy5vcHRpb25zLmF1dG9Qcm9jZXNzU3Vic2NyaXB0aW9ucyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NQZW5kaW5nU3Vic2NyaXB0aW9ucygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdDb25uZWN0Q2FsbGJhY2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgdXNlciBpbnZva2VzIHRoZSBjYWxsYmFjayB3aGlsZSBpbiBhdXRvUHJvY2Vzc1N1YnNjcmlwdGlvbnMgbW9kZSwgaXRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdvbid0IGJyZWFrIGFueXRoaW5nIC0gVGhlIHByb2Nlc3NQZW5kaW5nU3Vic2NyaXB0aW9ucygpIGNhbGwgd2lsbCBiZSBhIG5vLW9wLlxuICAgICAgICAgICAgICAgICAgICAgICAgU0NFbWl0dGVyLnByb3RvdHlwZS5lbWl0LmNhbGwoIHRoaXMsICdjb25uZWN0Jywgc3RhdHVzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5wcm9jZXNzUGVuZGluZ1N1YnNjcmlwdGlvbnMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZmx1c2hFbWl0QnVmZmVyKCk7XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgU0NTb2NrZXQucHJvdG90eXBlLl9vblNDRXJyb3IgPSBmdW5jdGlvbiAoIGVyciApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhyb3cgZXJyb3IgaW4gZGlmZmVyZW50IHN0YWNrIGZyYW1lIHNvIHRoYXQgZXJyb3IgaGFuZGxpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhbm5vdCBpbnRlcmZlcmUgd2l0aCBhIHJlY29ubmVjdCBhY3Rpb24uXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBzZWxmLmxpc3RlbmVycyggJ2Vycm9yJyApLmxlbmd0aCA8IDEgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTQ0VtaXR0ZXIucHJvdG90eXBlLmVtaXQuY2FsbCggc2VsZiwgJ2Vycm9yJywgZXJyICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgMCApO1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIFNDU29ja2V0LnByb3RvdHlwZS5fc3VzcGVuZFN1YnNjcmlwdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hhbm5lbCwgbmV3U3RhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCB2YXIgY2hhbm5lbE5hbWUgaW4gdGhpcy5fY2hhbm5lbHMgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB0aGlzLl9jaGFubmVscy5oYXNPd25Qcm9wZXJ0eSggY2hhbm5lbE5hbWUgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbCA9IHRoaXMuX2NoYW5uZWxzW2NoYW5uZWxOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBjaGFubmVsLnN0YXRlID09IGNoYW5uZWwuU1VCU0NSSUJFRCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbC5zdGF0ZSA9PSBjaGFubmVsLlBFTkRJTkcgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1N0YXRlID0gY2hhbm5lbC5QRU5ESU5HO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3U3RhdGUgPSBjaGFubmVsLlVOU1VCU0NSSUJFRDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3RyaWdnZXJDaGFubmVsVW5zdWJzY3JpYmUoIGNoYW5uZWwsIG5ld1N0YXRlICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIFNDU29ja2V0LnByb3RvdHlwZS5fb25TQ0Nsb3NlID0gZnVuY3Rpb24gKCBjb2RlLCBkYXRhLCBvcGVuQWJvcnQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaWQgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHRoaXMudHJhbnNwb3J0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0Lm9mZigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nUmVjb25uZWN0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdSZWNvbm5lY3RUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCggdGhpcy5fcmVjb25uZWN0VGltZW91dFJlZiApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VUb1BlbmRpbmdBdXRoU3RhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N1c3BlbmRTdWJzY3JpcHRpb25zKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyeSB0byByZWNvbm5lY3RcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9uIHNlcnZlciBwaW5nIHRpbWVvdXQgKDQwMDApXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvciBvbiBjbGllbnQgcG9uZyB0aW1lb3V0ICg0MDAxKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3Igb24gY2xvc2Ugd2l0aG91dCBzdGF0dXMgKDEwMDUpXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvciBvbiBoYW5kc2hha2UgZmFpbHVyZSAoNDAwMylcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9yIG9uIHNvY2tldCBodW5nIHVwICgxMDA2KVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB0aGlzLm9wdGlvbnMuYXV0b1JlY29ubmVjdCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGNvZGUgPT0gNDAwMCB8fCBjb2RlID09IDQwMDEgfHwgY29kZSA9PSAxMDA1ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhIHBpbmcgb3IgcG9uZyB0aW1lb3V0IG9yIHNvY2tldCBjbG9zZXMgd2l0aG91dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzdGF0dXMsIGRvbid0IHdhaXQgYmVmb3JlIHRyeWluZyB0byByZWNvbm5lY3QgLSBUaGVzZSBjb3VsZCBoYXBwZW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIGNsaWVudCB3YWtlcyB1cCBhZnRlciBhIHBlcmlvZCBvZiBpbmFjdGl2aXR5IGFuZCBpbiB0aGlzIGNhc2Ugd2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2FudCB0byByZS1lc3RhYmxpc2ggdGhlIGNvbm5lY3Rpb24gYXMgc29vbiBhcyBwb3NzaWJsZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdHJ5UmVjb25uZWN0KCAwICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29kZXMgNDUwMCBhbmQgYWJvdmUgd2lsbCBiZSB0cmVhdGVkIGFzIHBlcm1hbmVudCBkaXNjb25uZWN0cy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU29ja2V0IHdpbGwgbm90IHRyeSB0byBhdXRvLXJlY29ubmVjdC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBjb2RlICE9IDEwMDAgJiYgY29kZSA8IDQ1MDAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3RyeVJlY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBvcGVuQWJvcnQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgU0NFbWl0dGVyLnByb3RvdHlwZS5lbWl0LmNhbGwoIHNlbGYsICdjb25uZWN0QWJvcnQnLCBjb2RlLCBkYXRhICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNDRW1pdHRlci5wcm90b3R5cGUuZW1pdC5jYWxsKCBzZWxmLCAnZGlzY29ubmVjdCcsIGNvZGUsIGRhdGEgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhU0NTb2NrZXQuaWdub3JlU3RhdHVzZXNbY29kZV0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZhaWx1cmVNZXNzYWdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZGF0YSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFpbHVyZU1lc3NhZ2UgPSAnU29ja2V0IGNvbm5lY3Rpb24gZmFpbGVkOiAnICsgZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWlsdXJlTWVzc2FnZSA9ICdTb2NrZXQgY29ubmVjdGlvbiBmYWlsZWQgZm9yIHVua25vd24gcmVhc29ucyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlcnIgPSBuZXcgU29ja2V0UHJvdG9jb2xFcnJvciggU0NTb2NrZXQuZXJyb3JTdGF0dXNlc1tjb2RlXSB8fCBmYWlsdXJlTWVzc2FnZSwgY29kZSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29uU0NFcnJvciggZXJyICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgU0NTb2NrZXQucHJvdG90eXBlLl9vblNDRXZlbnQgPSBmdW5jdGlvbiAoIGV2ZW50LCBkYXRhLCByZXMgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGFuZGxlciA9IHRoaXMuX3ByaXZhdGVFdmVudEhhbmRsZXJNYXBbZXZlbnRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBoYW5kbGVyICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXIuY2FsbCggdGhpcywgZGF0YSwgcmVzICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNDRW1pdHRlci5wcm90b3R5cGUuZW1pdC5jYWxsKCB0aGlzLCBldmVudCwgZGF0YSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMgJiYgcmVzLmNhbGxiYWNrLmFwcGx5KCByZXMsIGFyZ3VtZW50cyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICBTQ1NvY2tldC5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24gKCBtZXNzYWdlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNwb3J0LmRlY29kZSggbWVzc2FnZSApO1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIFNDU29ja2V0LnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbiAoIG9iamVjdCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zcG9ydC5lbmNvZGUoIG9iamVjdCApO1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIFNDU29ja2V0LnByb3RvdHlwZS5fZmx1c2hFbWl0QnVmZmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJlbnROb2RlID0gdGhpcy5fZW1pdEJ1ZmZlci5oZWFkO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5leHROb2RlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIGN1cnJlbnROb2RlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gY3VycmVudE5vZGUubmV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXZlbnRPYmplY3QgPSBjdXJyZW50Tm9kZS5kYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlLmRldGFjaCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0LmVtaXRSYXcoIGV2ZW50T2JqZWN0ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudE5vZGUgPSBuZXh0Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICBTQ1NvY2tldC5wcm90b3R5cGUuX2hhbmRsZUV2ZW50QWNrVGltZW91dCA9IGZ1bmN0aW9uICggZXZlbnRPYmplY3QsIGV2ZW50Tm9kZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZXZlbnROb2RlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50Tm9kZS5kZXRhY2goKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBUaW1lb3V0RXJyb3IoIFwiRXZlbnQgcmVzcG9uc2UgZm9yICdcIiArIGV2ZW50T2JqZWN0LmV2ZW50ICsgXCInIHRpbWVkIG91dFwiICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBldmVudE9iamVjdC5jYWxsYmFjaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggY2FsbGJhY2sgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGV2ZW50T2JqZWN0LmNhbGxiYWNrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwoIGV2ZW50T2JqZWN0LCBlcnJvciwgZXZlbnRPYmplY3QgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICBTQ1NvY2tldC5wcm90b3R5cGUuX2VtaXQgPSBmdW5jdGlvbiAoIGV2ZW50LCBkYXRhLCBjYWxsYmFjayApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB0aGlzLnN0YXRlID09IHRoaXMuQ0xPU0VEICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV2ZW50T2JqZWN0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV2ZW50Tm9kZSA9IG5ldyBMaW5rZWRMaXN0Lkl0ZW0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50Tm9kZS5kYXRhID0gZXZlbnRPYmplY3Q7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50T2JqZWN0LnRpbWVvdXQgPSBzZXRUaW1lb3V0KCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5faGFuZGxlRXZlbnRBY2tUaW1lb3V0KCBldmVudE9iamVjdCwgZXZlbnROb2RlICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCB0aGlzLmFja1RpbWVvdXQgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZW1pdEJ1ZmZlci5hcHBlbmQoIGV2ZW50Tm9kZSApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHRoaXMuc3RhdGUgPT0gdGhpcy5PUEVOICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZsdXNoRW1pdEJ1ZmZlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIFNDU29ja2V0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKCBkYXRhICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQuc2VuZCggZGF0YSApO1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIFNDU29ja2V0LnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gKCBldmVudCwgZGF0YSwgY2FsbGJhY2sgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHRoaXMuX2xvY2FsRXZlbnRzW2V2ZW50XSA9PSBudWxsICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2VtaXQoIGV2ZW50LCBkYXRhLCBjYWxsYmFjayApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTQ0VtaXR0ZXIucHJvdG90eXBlLmVtaXQuY2FsbCggdGhpcywgZXZlbnQsIGRhdGEgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICBTQ1NvY2tldC5wcm90b3R5cGUucHVibGlzaCA9IGZ1bmN0aW9uICggY2hhbm5lbE5hbWUsIGRhdGEsIGNhbGxiYWNrICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHB1YkRhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbDogdGhpcy5fZGVjb3JhdGVDaGFubmVsTmFtZSggY2hhbm5lbE5hbWUgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCAnI3B1Ymxpc2gnLCBwdWJEYXRhLCBjYWxsYmFjayApO1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIFNDU29ja2V0LnByb3RvdHlwZS5fdHJpZ2dlckNoYW5uZWxTdWJzY3JpYmUgPSBmdW5jdGlvbiAoIGNoYW5uZWwsIHN1YnNjcmlwdGlvbk9wdGlvbnMgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hhbm5lbE5hbWUgPSBjaGFubmVsLm5hbWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggY2hhbm5lbC5zdGF0ZSAhPSBjaGFubmVsLlNVQlNDUklCRUQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9sZFN0YXRlID0gY2hhbm5lbC5zdGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsLnN0YXRlID0gY2hhbm5lbC5TVUJTQ1JJQkVEO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXRlQ2hhbmdlRGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbDogY2hhbm5lbE5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9sZFN0YXRlOiBvbGRTdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3U3RhdGU6IGNoYW5uZWwuc3RhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbk9wdGlvbnM6IHN1YnNjcmlwdGlvbk9wdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWwuZW1pdCggJ3N1YnNjcmliZVN0YXRlQ2hhbmdlJywgc3RhdGVDaGFuZ2VEYXRhICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbC5lbWl0KCAnc3Vic2NyaWJlJywgY2hhbm5lbE5hbWUsIHN1YnNjcmlwdGlvbk9wdGlvbnMgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTQ0VtaXR0ZXIucHJvdG90eXBlLmVtaXQuY2FsbCggdGhpcywgJ3N1YnNjcmliZVN0YXRlQ2hhbmdlJywgc3RhdGVDaGFuZ2VEYXRhICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgU0NFbWl0dGVyLnByb3RvdHlwZS5lbWl0LmNhbGwoIHRoaXMsICdzdWJzY3JpYmUnLCBjaGFubmVsTmFtZSwgc3Vic2NyaXB0aW9uT3B0aW9ucyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIFNDU29ja2V0LnByb3RvdHlwZS5fdHJpZ2dlckNoYW5uZWxTdWJzY3JpYmVGYWlsID0gZnVuY3Rpb24gKCBlcnIsIGNoYW5uZWwsIHN1YnNjcmlwdGlvbk9wdGlvbnMgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hhbm5lbE5hbWUgPSBjaGFubmVsLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWVldHNBdXRoUmVxdWlyZW1lbnRzID0gIWNoYW5uZWwud2FpdEZvckF1dGggfHwgdGhpcy5hdXRoU3RhdGUgPT0gdGhpcy5BVVRIRU5USUNBVEVEO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGNoYW5uZWwuc3RhdGUgIT0gY2hhbm5lbC5VTlNVQlNDUklCRUQgJiYgbWVldHNBdXRoUmVxdWlyZW1lbnRzICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWwuc3RhdGUgPSBjaGFubmVsLlVOU1VCU0NSSUJFRDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWwuZW1pdCggJ3N1YnNjcmliZUZhaWwnLCBlcnIsIGNoYW5uZWxOYW1lLCBzdWJzY3JpcHRpb25PcHRpb25zICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgU0NFbWl0dGVyLnByb3RvdHlwZS5lbWl0LmNhbGwoIHRoaXMsICdzdWJzY3JpYmVGYWlsJywgZXJyLCBjaGFubmVsTmFtZSwgc3Vic2NyaXB0aW9uT3B0aW9ucyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIENhbmNlbCBhbnkgcGVuZGluZyBzdWJzY3JpYmUgY2FsbGJhY2tcbiAgICAgICAgICAgICAgICAgICAgU0NTb2NrZXQucHJvdG90eXBlLl9jYW5jZWxQZW5kaW5nU3Vic2NyaWJlQ2FsbGJhY2sgPSBmdW5jdGlvbiAoIGNoYW5uZWwgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGNoYW5uZWwuX3BlbmRpbmdTdWJzY3JpcHRpb25DaWQgIT0gbnVsbCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYW5zcG9ydC5jYW5jZWxQZW5kaW5nUmVzcG9uc2UoIGNoYW5uZWwuX3BlbmRpbmdTdWJzY3JpcHRpb25DaWQgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgY2hhbm5lbC5fcGVuZGluZ1N1YnNjcmlwdGlvbkNpZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICBTQ1NvY2tldC5wcm90b3R5cGUuX2RlY29yYXRlQ2hhbm5lbE5hbWUgPSBmdW5jdGlvbiAoIGNoYW5uZWxOYW1lICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB0aGlzLmNoYW5uZWxQcmVmaXggKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbE5hbWUgPSB0aGlzLmNoYW5uZWxQcmVmaXggKyBjaGFubmVsTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGFubmVsTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICBTQ1NvY2tldC5wcm90b3R5cGUuX3VuZGVjb3JhdGVDaGFubmVsTmFtZSA9IGZ1bmN0aW9uICggZGVjb3JhdGVkQ2hhbm5lbE5hbWUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHRoaXMuY2hhbm5lbFByZWZpeCAmJiBkZWNvcmF0ZWRDaGFubmVsTmFtZS5pbmRleE9mKCB0aGlzLmNoYW5uZWxQcmVmaXggKSA9PSAwICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWNvcmF0ZWRDaGFubmVsTmFtZS5yZXBsYWNlKCB0aGlzLmNoYW5uZWxQcmVmaXgsICcnICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVjb3JhdGVkQ2hhbm5lbE5hbWU7XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgU0NTb2NrZXQucHJvdG90eXBlLl90cnlTdWJzY3JpYmUgPSBmdW5jdGlvbiAoIGNoYW5uZWwgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtZWV0c0F1dGhSZXF1aXJlbWVudHMgPSAhY2hhbm5lbC53YWl0Rm9yQXV0aCB8fCB0aGlzLmF1dGhTdGF0ZSA9PSB0aGlzLkFVVEhFTlRJQ0FURUQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGNhbiBvbmx5IGV2ZXIgaGF2ZSBvbmUgcGVuZGluZyBzdWJzY3JpYmUgYWN0aW9uIGF0IGFueSBnaXZlbiB0aW1lIG9uIGEgY2hhbm5lbFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB0aGlzLnN0YXRlID09IHRoaXMuT1BFTiAmJiAhdGhpcy5wZW5kaW5nQ29ubmVjdENhbGxiYWNrICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbC5fcGVuZGluZ1N1YnNjcmlwdGlvbkNpZCA9PSBudWxsICYmIG1lZXRzQXV0aFJlcXVpcmVtZW50cyApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub1RpbWVvdXQ6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN1YnNjcmlwdGlvbk9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWw6IHRoaXMuX2RlY29yYXRlQ2hhbm5lbE5hbWUoIGNoYW5uZWwubmFtZSApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGNoYW5uZWwud2FpdEZvckF1dGggKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMud2FpdEZvckF1dGggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb25PcHRpb25zLndhaXRGb3JBdXRoID0gb3B0aW9ucy53YWl0Rm9yQXV0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBjaGFubmVsLmRhdGEgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbk9wdGlvbnMuZGF0YSA9IGNoYW5uZWwuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsLl9wZW5kaW5nU3Vic2NyaXB0aW9uQ2lkID0gdGhpcy50cmFuc3BvcnQuZW1pdChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyNzdWJzY3JpYmUnLCBzdWJzY3JpcHRpb25PcHRpb25zLCBvcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoIGVyciApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBjaGFubmVsLl9wZW5kaW5nU3Vic2NyaXB0aW9uQ2lkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBlcnIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fdHJpZ2dlckNoYW5uZWxTdWJzY3JpYmVGYWlsKCBlcnIsIGNoYW5uZWwsIHN1YnNjcmlwdGlvbk9wdGlvbnMgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fdHJpZ2dlckNoYW5uZWxTdWJzY3JpYmUoIGNoYW5uZWwsIHN1YnNjcmlwdGlvbk9wdGlvbnMgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgU0NFbWl0dGVyLnByb3RvdHlwZS5lbWl0LmNhbGwoIHRoaXMsICdzdWJzY3JpYmVSZXF1ZXN0JywgY2hhbm5lbC5uYW1lLCBzdWJzY3JpcHRpb25PcHRpb25zICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgU0NTb2NrZXQucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uICggY2hhbm5lbE5hbWUsIG9wdGlvbnMgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hhbm5lbCA9IHRoaXMuX2NoYW5uZWxzW2NoYW5uZWxOYW1lXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhY2hhbm5lbCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsID0gbmV3IFNDQ2hhbm5lbCggY2hhbm5lbE5hbWUsIHRoaXMsIG9wdGlvbnMgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGFubmVsc1tjaGFubmVsTmFtZV0gPSBjaGFubmVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICggb3B0aW9ucyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsLnNldE9wdGlvbnMoIG9wdGlvbnMgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBjaGFubmVsLnN0YXRlID09IGNoYW5uZWwuVU5TVUJTQ1JJQkVEICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWwuc3RhdGUgPSBjaGFubmVsLlBFTkRJTkc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdHJ5U3Vic2NyaWJlKCBjaGFubmVsICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGFubmVsO1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIFNDU29ja2V0LnByb3RvdHlwZS5fdHJpZ2dlckNoYW5uZWxVbnN1YnNjcmliZSA9IGZ1bmN0aW9uICggY2hhbm5lbCwgbmV3U3RhdGUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hhbm5lbE5hbWUgPSBjaGFubmVsLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2xkU3RhdGUgPSBjaGFubmVsLnN0YXRlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG5ld1N0YXRlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWwuc3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbC5zdGF0ZSA9IGNoYW5uZWwuVU5TVUJTQ1JJQkVEO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FuY2VsUGVuZGluZ1N1YnNjcmliZUNhbGxiYWNrKCBjaGFubmVsICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggb2xkU3RhdGUgPT0gY2hhbm5lbC5TVUJTQ1JJQkVEICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdGF0ZUNoYW5nZURhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWw6IGNoYW5uZWxOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbGRTdGF0ZTogb2xkU3RhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1N0YXRlOiBjaGFubmVsLnN0YXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsLmVtaXQoICdzdWJzY3JpYmVTdGF0ZUNoYW5nZScsIHN0YXRlQ2hhbmdlRGF0YSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWwuZW1pdCggJ3Vuc3Vic2NyaWJlJywgY2hhbm5lbE5hbWUgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTQ0VtaXR0ZXIucHJvdG90eXBlLmVtaXQuY2FsbCggdGhpcywgJ3N1YnNjcmliZVN0YXRlQ2hhbmdlJywgc3RhdGVDaGFuZ2VEYXRhICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgU0NFbWl0dGVyLnByb3RvdHlwZS5lbWl0LmNhbGwoIHRoaXMsICd1bnN1YnNjcmliZScsIGNoYW5uZWxOYW1lICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgU0NTb2NrZXQucHJvdG90eXBlLl90cnlVbnN1YnNjcmliZSA9IGZ1bmN0aW9uICggY2hhbm5lbCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB0aGlzLnN0YXRlID09IHRoaXMuT1BFTiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9UaW1lb3V0OiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhIHBlbmRpbmcgc3Vic2NyaWJlIGFjdGlvbiwgY2FuY2VsIHRoZSBjYWxsYmFja1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhbmNlbFBlbmRpbmdTdWJzY3JpYmVDYWxsYmFjayggY2hhbm5lbCApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBvcGVyYXRpb24gY2Fubm90IGZhaWwgYmVjYXVzZSB0aGUgVENQIHByb3RvY29sIGd1YXJhbnRlZXMgZGVsaXZlcnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzbyBsb25nIGFzIHRoZSBjb25uZWN0aW9uIHJlbWFpbnMgb3Blbi4gSWYgdGhlIGNvbm5lY3Rpb24gY2xvc2VzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBzZXJ2ZXIgd2lsbCBhdXRvbWF0aWNhbGx5IHVuc3Vic2NyaWJlIHRoZSBzb2NrZXQgYW5kIHRodXMgY29tcGxldGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgb3BlcmF0aW9uIG9uIHRoZSBzZXJ2ZXIgc2lkZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVjb3JhdGVkQ2hhbm5lbE5hbWUgPSB0aGlzLl9kZWNvcmF0ZUNoYW5uZWxOYW1lKCBjaGFubmVsLm5hbWUgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYW5zcG9ydC5lbWl0KCAnI3Vuc3Vic2NyaWJlJywgZGVjb3JhdGVkQ2hhbm5lbE5hbWUsIG9wdGlvbnMgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICBTQ1NvY2tldC5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoIGNoYW5uZWxOYW1lICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hhbm5lbCA9IHRoaXMuX2NoYW5uZWxzW2NoYW5uZWxOYW1lXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBjaGFubmVsICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggY2hhbm5lbC5zdGF0ZSAhPSBjaGFubmVsLlVOU1VCU0NSSUJFRCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90cmlnZ2VyQ2hhbm5lbFVuc3Vic2NyaWJlKCBjaGFubmVsICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3RyeVVuc3Vic2NyaWJlKCBjaGFubmVsICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIFNDU29ja2V0LnByb3RvdHlwZS5jaGFubmVsID0gZnVuY3Rpb24gKCBjaGFubmVsTmFtZSwgb3B0aW9ucyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50Q2hhbm5lbCA9IHRoaXMuX2NoYW5uZWxzW2NoYW5uZWxOYW1lXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhY3VycmVudENoYW5uZWwgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudENoYW5uZWwgPSBuZXcgU0NDaGFubmVsKCBjaGFubmVsTmFtZSwgdGhpcywgb3B0aW9ucyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5uZWxzW2NoYW5uZWxOYW1lXSA9IGN1cnJlbnRDaGFubmVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRDaGFubmVsO1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIFNDU29ja2V0LnByb3RvdHlwZS5kZXN0cm95Q2hhbm5lbCA9IGZ1bmN0aW9uICggY2hhbm5lbE5hbWUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hhbm5lbCA9IHRoaXMuX2NoYW5uZWxzW2NoYW5uZWxOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWwudW53YXRjaCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbC51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2NoYW5uZWxzW2NoYW5uZWxOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICBTQ1NvY2tldC5wcm90b3R5cGUuc3Vic2NyaXB0aW9ucyA9IGZ1bmN0aW9uICggaW5jbHVkZVBlbmRpbmcgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3VicyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoYW5uZWwsIGluY2x1ZGVDaGFubmVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggdmFyIGNoYW5uZWxOYW1lIGluIHRoaXMuX2NoYW5uZWxzICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdGhpcy5fY2hhbm5lbHMuaGFzT3duUHJvcGVydHkoIGNoYW5uZWxOYW1lICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWwgPSB0aGlzLl9jaGFubmVsc1tjaGFubmVsTmFtZV07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBpbmNsdWRlUGVuZGluZyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1ZGVDaGFubmVsID0gY2hhbm5lbCAmJiAoIGNoYW5uZWwuc3RhdGUgPT0gY2hhbm5lbC5TVUJTQ1JJQkVEIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbC5zdGF0ZSA9PSBjaGFubmVsLlBFTkRJTkcgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1ZGVDaGFubmVsID0gY2hhbm5lbCAmJiBjaGFubmVsLnN0YXRlID09IGNoYW5uZWwuU1VCU0NSSUJFRDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggaW5jbHVkZUNoYW5uZWwgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJzLnB1c2goIGNoYW5uZWxOYW1lICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3VicztcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICBTQ1NvY2tldC5wcm90b3R5cGUuaXNTdWJzY3JpYmVkID0gZnVuY3Rpb24gKCBjaGFubmVsTmFtZSwgaW5jbHVkZVBlbmRpbmcgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hhbm5lbCA9IHRoaXMuX2NoYW5uZWxzW2NoYW5uZWxOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggaW5jbHVkZVBlbmRpbmcgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEhY2hhbm5lbCAmJiAoIGNoYW5uZWwuc3RhdGUgPT0gY2hhbm5lbC5TVUJTQ1JJQkVEIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWwuc3RhdGUgPT0gY2hhbm5lbC5QRU5ESU5HICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gISFjaGFubmVsICYmIGNoYW5uZWwuc3RhdGUgPT0gY2hhbm5lbC5TVUJTQ1JJQkVEO1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIFNDU29ja2V0LnByb3RvdHlwZS5wcm9jZXNzUGVuZGluZ1N1YnNjcmlwdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0Nvbm5lY3RDYWxsYmFjayA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSBpbiB0aGlzLl9jaGFubmVscyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHRoaXMuX2NoYW5uZWxzLmhhc093blByb3BlcnR5KCBpICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggZnVuY3Rpb24gKCBjaGFubmVsICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBjaGFubmVsLnN0YXRlID09IGNoYW5uZWwuUEVORElORyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl90cnlTdWJzY3JpYmUoIGNoYW5uZWwgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSApKCB0aGlzLl9jaGFubmVsc1tpXSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICBTQ1NvY2tldC5wcm90b3R5cGUud2F0Y2ggPSBmdW5jdGlvbiAoIGNoYW5uZWxOYW1lLCBoYW5kbGVyICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB0eXBlb2YgaGFuZGxlciAhPSAnZnVuY3Rpb24nICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzRXJyb3IoICdObyBoYW5kbGVyIGZ1bmN0aW9uIHdhcyBwcm92aWRlZCcgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5uZWxFbWl0dGVyLm9uKCBjaGFubmVsTmFtZSwgaGFuZGxlciApO1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIFNDU29ja2V0LnByb3RvdHlwZS51bndhdGNoID0gZnVuY3Rpb24gKCBjaGFubmVsTmFtZSwgaGFuZGxlciApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggaGFuZGxlciApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGFubmVsRW1pdHRlci5yZW1vdmVMaXN0ZW5lciggY2hhbm5lbE5hbWUsIGhhbmRsZXIgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hhbm5lbEVtaXR0ZXIucmVtb3ZlQWxsTGlzdGVuZXJzKCBjaGFubmVsTmFtZSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIFNDU29ja2V0LnByb3RvdHlwZS53YXRjaGVycyA9IGZ1bmN0aW9uICggY2hhbm5lbE5hbWUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY2hhbm5lbEVtaXR0ZXIubGlzdGVuZXJzKCBjaGFubmVsTmFtZSApO1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gU0NTb2NrZXQ7XG5cbiAgICAgICAgICAgICAgICAgICAgLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovXG59LmNhbGwoIGV4cG9ydHMsICggZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSgpICksIF9fd2VicGFja19yZXF1aXJlX18oIDI2ICkuQnVmZmVyICkgKVxuXG4gICAgICAgICAgICAgICAgLyoqKi9cbn0sXG4vKiA1MSAqL1xuLyoqKi8gZnVuY3Rpb24gKCBtb2R1bGUsIGV4cG9ydHMgKSB7XG5cbiAgICAgICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICggbW9kdWxlICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoICFtb2R1bGUud2VicGFja1BvbHlmaWxsICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZHVsZS5wYXRocyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtb2R1bGU7XG4gICAgICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgICAgICAvKioqL1xufSxcbi8qIDUyICovXG4vKioqLyBmdW5jdGlvbiAoIG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyApIHtcblxuICAgICAgICAgICAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgICAgICAgICAgIGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgZXhwb3J0cy5kZWZhdWx0ID0gY29uZmlndXJlU3RvcmU7XG5cbiAgICAgICAgICAgICAgICB2YXIgX3JlZHV4RGV2dG9vbHNJbnN0cnVtZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyggMTYyICk7XG5cbiAgICAgICAgICAgICAgICB2YXIgX3JlZHV4RGV2dG9vbHNJbnN0cnVtZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoIF9yZWR1eERldnRvb2xzSW5zdHJ1bWVudCApO1xuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdCggb2JqICkgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gY29uZmlndXJlU3RvcmUoIG5leHQsIHN1YnNjcmliZXIsIG9wdGlvbnMgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoIDAsIF9yZWR1eERldnRvb2xzSW5zdHJ1bWVudDIuZGVmYXVsdCApKCBzdWJzY3JpYmVyLCBvcHRpb25zICkoIG5leHQgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvKioqL1xufSxcbi8qIDUzICovXG4vKioqLyBmdW5jdGlvbiAoIG1vZHVsZSwgZXhwb3J0cyApIHtcblxuICAgICAgICAgICAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgICAgICAgICAgIGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdmFyIGRlZmF1bHRTb2NrZXRPcHRpb25zID0gZXhwb3J0cy5kZWZhdWx0U29ja2V0T3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgc2VjdXJlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBob3N0bmFtZTogJ3JlbW90ZWRldi5pbycsXG4gICAgICAgICAgICAgICAgICAgIHBvcnQ6IDQ0MyxcbiAgICAgICAgICAgICAgICAgICAgYXV0b1JlY29ubmVjdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgYXV0b1JlY29ubmVjdE9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmRvbW5lc3M6IDMwMDAwXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLyoqKi9cbn0sXG4vKiA1NCAqL1xuLyoqKi8gZnVuY3Rpb24gKCBtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18gKSB7XG5cbiAgICAgICAgICAgICAgICAndXNlIHN0cmljdCc7XG5cbiAgICAgICAgICAgICAgICBleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgdmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uICggb2JqICkgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uICggb2JqICkgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuICAgICAgICAgICAgICAgIHZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKCB0YXJnZXQgKSB7IGZvciAoIHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKyApIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICggdmFyIGtleSBpbiBzb3VyY2UgKSB7IGlmICggT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKCBzb3VyY2UsIGtleSApICkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG4gICAgICAgICAgICAgICAgZXhwb3J0cy5kZWZhdWx0ID0gZGV2VG9vbHM7XG4gICAgICAgICAgICAgICAgZXhwb3J0cy5wcmVEZXZUb29scyA9IHByZURldlRvb2xzO1xuICAgICAgICAgICAgICAgIGV4cG9ydHMuY29tcG9zZVdpdGhEZXZUb29scyA9IGNvbXBvc2VXaXRoRGV2VG9vbHM7XG5cbiAgICAgICAgICAgICAgICB2YXIgX2pzYW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCA2MyApO1xuXG4gICAgICAgICAgICAgICAgdmFyIF9zb2NrZXRjbHVzdGVyQ2xpZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyggMTY5ICk7XG5cbiAgICAgICAgICAgICAgICB2YXIgX3NvY2tldGNsdXN0ZXJDbGllbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdCggX3NvY2tldGNsdXN0ZXJDbGllbnQgKTtcblxuICAgICAgICAgICAgICAgIHZhciBfY29uZmlndXJlU3RvcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCA1MiApO1xuXG4gICAgICAgICAgICAgICAgdmFyIF9jb25maWd1cmVTdG9yZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KCBfY29uZmlndXJlU3RvcmUgKTtcblxuICAgICAgICAgICAgICAgIHZhciBfY29uc3RhbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyggNTMgKTtcblxuICAgICAgICAgICAgICAgIHZhciBfcmVhY3ROYXRpdmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCA1NSApO1xuXG4gICAgICAgICAgICAgICAgdmFyIF9yZW1vdGVkZXZVdGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oIDE2NSApO1xuXG4gICAgICAgICAgICAgICAgdmFyIF9jYXRjaEVycm9ycyA9IF9fd2VicGFja19yZXF1aXJlX18oIDE2MyApO1xuXG4gICAgICAgICAgICAgICAgdmFyIF9jYXRjaEVycm9yczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KCBfY2F0Y2hFcnJvcnMgKTtcblxuICAgICAgICAgICAgICAgIHZhciBfZmlsdGVycyA9IF9fd2VicGFja19yZXF1aXJlX18oIDE2NCApO1xuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdCggb2JqICkgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGluc3RhbmNlSWQgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgdmFyIGluc3RhbmNlTmFtZSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICB2YXIgc29ja2V0T3B0aW9ucyA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICB2YXIgc29ja2V0ID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIHZhciBjaGFubmVsID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIHZhciBzdG9yZSA9IHt9O1xuICAgICAgICAgICAgICAgIHZhciBsYXN0QWN0aW9uID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIHZhciBmaWx0ZXJzID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIHZhciBpc0V4Y2VzcyA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICB2YXIgaXNNb25pdG9yZWQgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0ZWQgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0T24gPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgdmFyIHN0b3BPbiA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICB2YXIgc2VuZE9uID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIHZhciBzZW5kT25FcnJvciA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICB2YXIgc2VuZFRvID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIHZhciBsYXN0RXJyb3JNc2cgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgdmFyIGxvY2tlZCA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICB2YXIgcGF1c2VkID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIHZhciBhY3Rpb25DcmVhdG9ycyA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICB2YXIgc3RhdGVTYW5pdGl6ZXIgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgdmFyIGFjdGlvblNhbml0aXplciA9IHZvaWQgMDtcblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGdldExpZnRlZFN0YXRlKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCAwLCBfZmlsdGVycy5maWx0ZXJTdGFnZWRBY3Rpb25zICkoIHN0b3JlLmxpZnRlZFN0b3JlLmdldFN0YXRlKCksIGZpbHRlcnMgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBzZW5kKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoICFpbnN0YW5jZUlkICkgaW5zdGFuY2VJZCA9IHNvY2tldCAmJiBzb2NrZXQuaWQgfHwgTWF0aC5yYW5kb20oKS50b1N0cmluZyggMzYgKS5zdWJzdHIoIDIgKTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZldGNoKCBzZW5kVG8sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdTVEFURScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBpbnN0YW5jZUlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBpbnN0YW5jZU5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQ6ICggMCwgX2pzYW4uc3RyaW5naWZ5ICkoIGdldExpZnRlZFN0YXRlKCkgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSApLmNhdGNoKCBmdW5jdGlvbiAoIGVyciApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyggZXJyICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9ICk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKCBlcnIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyggZXJyICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiByZWxheSggdHlwZSwgc3RhdGUsIGFjdGlvbiwgbmV4dEFjdGlvbklkICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoICggMCwgX2ZpbHRlcnMuaXNGaWx0ZXJlZCApKCBhY3Rpb24sIGZpbHRlcnMgKSApIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHNvY2tldC5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGluc3RhbmNlTmFtZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBpZiAoIHN0YXRlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wYXlsb2FkID0gdHlwZSA9PT0gJ0VSUk9SJyA/IHN0YXRlIDogKCAwLCBfanNhbi5zdHJpbmdpZnkgKSggKCAwLCBfZmlsdGVycy5maWx0ZXJTdGF0ZSApKCBzdGF0ZSwgdHlwZSwgZmlsdGVycywgc3RhdGVTYW5pdGl6ZXIsIGFjdGlvblNhbml0aXplciwgbmV4dEFjdGlvbklkICkgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIHR5cGUgPT09ICdBQ1RJT04nICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5hY3Rpb24gPSAoIDAsIF9qc2FuLnN0cmluZ2lmeSApKCAhYWN0aW9uU2FuaXRpemVyID8gYWN0aW9uIDogYWN0aW9uU2FuaXRpemVyKCBhY3Rpb24uYWN0aW9uLCBuZXh0QWN0aW9uSWQgLSAxICkgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaXNFeGNlc3MgPSBpc0V4Y2VzcztcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubmV4dEFjdGlvbklkID0gbmV4dEFjdGlvbklkO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBhY3Rpb24gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmFjdGlvbiA9IGFjdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzb2NrZXQuZW1pdCggc29ja2V0LmlkID8gJ2xvZycgOiAnbG9nLW5vaWQnLCBtZXNzYWdlICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZGlzcGF0Y2hSZW1vdGVseSggYWN0aW9uICkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9ICggMCwgX3JlbW90ZWRldlV0aWxzLmV2YWxBY3Rpb24gKSggYWN0aW9uLCBhY3Rpb25DcmVhdG9ycyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmUuZGlzcGF0Y2goIHJlc3VsdCApO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoICggZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbGF5KCAnRVJST1InLCBlLm1lc3NhZ2UgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGhhbmRsZU1lc3NhZ2VzKCBtZXNzYWdlICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIG1lc3NhZ2UudHlwZSA9PT0gJ0lNUE9SVCcgfHwgbWVzc2FnZS50eXBlID09PSAnU1lOQycgJiYgc29ja2V0LmlkICYmIG1lc3NhZ2UuaWQgIT09IHNvY2tldC5pZCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlLmxpZnRlZFN0b3JlLmRpc3BhdGNoKCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0lNUE9SVF9TVEFURScsIG5leHRMaWZ0ZWRTdGF0ZTogKCAwLCBfanNhbi5wYXJzZSApKCBtZXNzYWdlLnN0YXRlIClcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICggbWVzc2FnZS50eXBlID09PSAnVVBEQVRFJyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbGF5KCAnU1RBVEUnLCBnZXRMaWZ0ZWRTdGF0ZSgpICk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIG1lc3NhZ2UudHlwZSA9PT0gJ1NUQVJUJyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzTW9uaXRvcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdHlwZW9mIGFjdGlvbkNyZWF0b3JzID09PSAnZnVuY3Rpb24nICkgYWN0aW9uQ3JlYXRvcnMgPSBhY3Rpb25DcmVhdG9ycygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVsYXkoICdTVEFURScsIGdldExpZnRlZFN0YXRlKCksIGFjdGlvbkNyZWF0b3JzICk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIG1lc3NhZ2UudHlwZSA9PT0gJ1NUT1AnIHx8IG1lc3NhZ2UudHlwZSA9PT0gJ0RJU0NPTk5FQ1RFRCcgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc01vbml0b3JlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVsYXkoICdTVE9QJyApO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBtZXNzYWdlLnR5cGUgPT09ICdBQ1RJT04nICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2hSZW1vdGVseSggbWVzc2FnZS5hY3Rpb24gKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICggbWVzc2FnZS50eXBlID09PSAnRElTUEFUQ0gnICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmUubGlmdGVkU3RvcmUuZGlzcGF0Y2goIG1lc3NhZ2UuYWN0aW9uICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBhc3luYyggZm4gKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoIGZuLCAwICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gc2VuZEVycm9yKCBlcnJvckFjdGlvbiApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUHJldmVudCBmbG9vZGluZ1xuICAgICAgICAgICAgICAgICAgICBpZiAoIGVycm9yQWN0aW9uLm1lc3NhZ2UgJiYgZXJyb3JBY3Rpb24ubWVzc2FnZSA9PT0gbGFzdEVycm9yTXNnICkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBsYXN0RXJyb3JNc2cgPSBlcnJvckFjdGlvbi5tZXNzYWdlO1xuXG4gICAgICAgICAgICAgICAgICAgIGFzeW5jKCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9yZS5kaXNwYXRjaCggZXJyb3JBY3Rpb24gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggIXN0YXJ0ZWQgKSBzZW5kKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBzdHIyYXJyYXkoIHN0ciApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnID8gW3N0cl0gOiBzdHIgJiYgc3RyLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBpbml0KCBvcHRpb25zICkge1xuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZU5hbWUgPSBvcHRpb25zLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICggb3B0aW9ucy5maWx0ZXJzICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVycyA9IG9wdGlvbnMuZmlsdGVycztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIG9wdGlvbnMucG9ydCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvY2tldE9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9ydDogb3B0aW9ucy5wb3J0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvc3RuYW1lOiBvcHRpb25zLmhvc3RuYW1lIHx8ICdsb2NhbGhvc3QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlY3VyZTogb3B0aW9ucy5zZWN1cmVcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBzb2NrZXRPcHRpb25zID0gX2NvbnN0YW50cy5kZWZhdWx0U29ja2V0T3B0aW9ucztcblxuICAgICAgICAgICAgICAgICAgICBzdGFydE9uID0gc3RyMmFycmF5KCBvcHRpb25zLnN0YXJ0T24gKTtcbiAgICAgICAgICAgICAgICAgICAgc3RvcE9uID0gc3RyMmFycmF5KCBvcHRpb25zLnN0b3BPbiApO1xuICAgICAgICAgICAgICAgICAgICBzZW5kT24gPSBzdHIyYXJyYXkoIG9wdGlvbnMuc2VuZE9uICk7XG4gICAgICAgICAgICAgICAgICAgIHNlbmRPbkVycm9yID0gb3B0aW9ucy5zZW5kT25FcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBzZW5kT24gfHwgc2VuZE9uRXJyb3IgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZW5kVG8gPSBvcHRpb25zLnNlbmRUbyB8fCAoIHNvY2tldE9wdGlvbnMuc2VjdXJlID8gJ2h0dHBzJyA6ICdodHRwJyApICsgJzovLycgKyBzb2NrZXRPcHRpb25zLmhvc3RuYW1lICsgJzonICsgc29ja2V0T3B0aW9ucy5wb3J0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VJZCA9IG9wdGlvbnMuaWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBzZW5kT25FcnJvciA9PT0gMSApICggMCwgX2NhdGNoRXJyb3JzMi5kZWZhdWx0ICkoIHNlbmRFcnJvciApO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggb3B0aW9ucy5hY3Rpb25DcmVhdG9ycyApIGFjdGlvbkNyZWF0b3JzID0gZnVuY3Rpb24gYWN0aW9uQ3JlYXRvcnMoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCAwLCBfcmVtb3RlZGV2VXRpbHMuZ2V0QWN0aW9uc0FycmF5ICkoIG9wdGlvbnMuYWN0aW9uQ3JlYXRvcnMgKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVTYW5pdGl6ZXIgPSBvcHRpb25zLnN0YXRlU2FuaXRpemVyO1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb25TYW5pdGl6ZXIgPSBvcHRpb25zLmFjdGlvblNhbml0aXplcjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBsb2dpbigpIHtcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0LmVtaXQoICdsb2dpbicsICdtYXN0ZXInLCBmdW5jdGlvbiAoIGVyciwgY2hhbm5lbE5hbWUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGVyciApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyggZXJyICk7IHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWwgPSBjaGFubmVsTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvY2tldC5zdWJzY3JpYmUoIGNoYW5uZWxOYW1lICkud2F0Y2goIGhhbmRsZU1lc3NhZ2VzICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb2NrZXQub24oIGNoYW5uZWxOYW1lLCBoYW5kbGVNZXNzYWdlcyApO1xuICAgICAgICAgICAgICAgICAgICB9ICk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZWxheSggJ1NUQVJUJyApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHN0b3AoIGtlZXBDb25uZWN0ZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaXNNb25pdG9yZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhc29ja2V0ICkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBzb2NrZXQuZGVzdHJveUNoYW5uZWwoIGNoYW5uZWwgKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBrZWVwQ29ubmVjdGVkICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc29ja2V0Lm9mZiggY2hhbm5lbCwgaGFuZGxlTWVzc2FnZXMgKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvY2tldC5vZmYoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvY2tldC5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBzdGFydGVkIHx8IHNvY2tldCAmJiBzb2NrZXQuZ2V0U3RhdGUoKSA9PT0gc29ja2V0LkNPTk5FQ1RJTkcgKSByZXR1cm47XG5cbiAgICAgICAgICAgICAgICAgICAgc29ja2V0ID0gX3NvY2tldGNsdXN0ZXJDbGllbnQyLmRlZmF1bHQuY29ubmVjdCggc29ja2V0T3B0aW9ucyApO1xuICAgICAgICAgICAgICAgICAgICBzb2NrZXQub24oICdlcnJvcicsIGZ1bmN0aW9uICggZXJyICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coIGVyciApO1xuICAgICAgICAgICAgICAgICAgICB9ICk7XG4gICAgICAgICAgICAgICAgICAgIHNvY2tldC5vbiggJ2Nvbm5lY3QnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dpbigpO1xuICAgICAgICAgICAgICAgICAgICB9ICk7XG4gICAgICAgICAgICAgICAgICAgIHNvY2tldC5vbiggJ2Rpc2Nvbm5lY3QnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9wKCB0cnVlICk7XG4gICAgICAgICAgICAgICAgICAgIH0gKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBjaGVja0ZvclJlZHVjZXJFcnJvcnMoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsaWZ0ZWRTdGF0ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogc3RvcmUubGlmdGVkU3RvcmUuZ2V0U3RhdGUoKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIGxpZnRlZFN0YXRlLmNvbXB1dGVkU3RhdGVzW2xpZnRlZFN0YXRlLmN1cnJlbnRTdGF0ZUluZGV4XS5lcnJvciApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggc3RhcnRlZCApIHJlbGF5KCAnU1RBVEUnLCAoIDAsIF9maWx0ZXJzLmZpbHRlclN0YWdlZEFjdGlvbnMgKSggbGlmdGVkU3RhdGUsIGZpbHRlcnMgKSApOyBlbHNlIHNlbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBtb25pdG9yUmVkdWNlcigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFjdGlvbiA9IGFyZ3VtZW50c1sxXTtcblxuICAgICAgICAgICAgICAgICAgICBsYXN0QWN0aW9uID0gYWN0aW9uLnR5cGU7XG4gICAgICAgICAgICAgICAgICAgIGlmICggIXN0YXJ0ZWQgJiYgc2VuZE9uRXJyb3IgPT09IDIgJiYgc3RvcmUubGlmdGVkU3RvcmUgKSBhc3luYyggY2hlY2tGb3JSZWR1Y2VyRXJyb3JzICk7IGVsc2UgaWYgKCBhY3Rpb24uYWN0aW9uICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBzdGFydE9uICYmICFzdGFydGVkICYmIHN0YXJ0T24uaW5kZXhPZiggYWN0aW9uLmFjdGlvbi50eXBlICkgIT09IC0xICkgYXN5bmMoIHN0YXJ0ICk7IGVsc2UgaWYgKCBzdG9wT24gJiYgc3RhcnRlZCAmJiBzdG9wT24uaW5kZXhPZiggYWN0aW9uLmFjdGlvbi50eXBlICkgIT09IC0xICkgYXN5bmMoIHN0b3AgKTsgZWxzZSBpZiAoIHNlbmRPbiAmJiAhc3RhcnRlZCAmJiBzZW5kT24uaW5kZXhPZiggYWN0aW9uLmFjdGlvbi50eXBlICkgIT09IC0xICkgYXN5bmMoIHNlbmQgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gaGFuZGxlQ2hhbmdlKCBzdGF0ZSwgbGlmdGVkU3RhdGUsIG1heEFnZSApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBjaGVja0ZvclJlZHVjZXJFcnJvcnMoIGxpZnRlZFN0YXRlICkgKSByZXR1cm47XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBsYXN0QWN0aW9uID09PSAnUEVSRk9STV9BQ1RJT04nICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5leHRBY3Rpb25JZCA9IGxpZnRlZFN0YXRlLm5leHRBY3Rpb25JZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsaWZ0ZWRBY3Rpb24gPSBsaWZ0ZWRTdGF0ZS5hY3Rpb25zQnlJZFtuZXh0QWN0aW9uSWQgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbGF5KCAnQUNUSU9OJywgc3RhdGUsIGxpZnRlZEFjdGlvbiwgbmV4dEFjdGlvbklkICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoICFpc0V4Y2VzcyAmJiBtYXhBZ2UgKSBpc0V4Y2VzcyA9IGxpZnRlZFN0YXRlLnN0YWdlZEFjdGlvbklkcy5sZW5ndGggPj0gbWF4QWdlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBsYXN0QWN0aW9uID09PSAnSlVNUF9UT19TVEFURScgKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGxhc3RBY3Rpb24gPT09ICdQQVVTRV9SRUNPUkRJTkcnICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdXNlZCA9IGxpZnRlZFN0YXRlLmlzUGF1c2VkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICggbGFzdEFjdGlvbiA9PT0gJ0xPQ0tfQ0hBTkdFUycgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9ja2VkID0gbGlmdGVkU3RhdGUuaXNMb2NrZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHBhdXNlZCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGxhc3RBY3Rpb24gKSBsYXN0QWN0aW9uID0gdW5kZWZpbmVkOyBlbHNlIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbGF5KCAnU1RBVEUnLCAoIDAsIF9maWx0ZXJzLmZpbHRlclN0YWdlZEFjdGlvbnMgKSggbGlmdGVkU3RhdGUsIGZpbHRlcnMgKSApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZGV2VG9vbHMoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgICAgICAgICAgICAgICBpbml0KCBfZXh0ZW5kcygge30sIG9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvc3RuYW1lOiAoIDAsIF9yZWFjdE5hdGl2ZS5nZXRIb3N0Rm9yUk4gKSggb3B0aW9ucy5ob3N0bmFtZSApXG4gICAgICAgICAgICAgICAgICAgIH0gKSApO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVhbHRpbWUgPSB0eXBlb2Ygb3B0aW9ucy5yZWFsdGltZSA9PT0gJ3VuZGVmaW5lZCcgPyAoIFwiZGV2ZWxvcG1lbnRcIiApID09PSAnZGV2ZWxvcG1lbnQnIDogb3B0aW9ucy5yZWFsdGltZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhcmVhbHRpbWUgJiYgISggc3RhcnRPbiB8fCBzZW5kT24gfHwgc2VuZE9uRXJyb3IgKSApIHJldHVybiBmdW5jdGlvbiAoIGYgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZjtcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgbWF4QWdlID0gb3B0aW9ucy5tYXhBZ2UgfHwgMzA7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoIG5leHQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCByZWR1Y2VyLCBpbml0aWFsU3RhdGUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmUgPSAoIDAsIF9jb25maWd1cmVTdG9yZTIuZGVmYXVsdCApKCBuZXh0LCBtb25pdG9yUmVkdWNlciwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhBZ2U6IG1heEFnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkQ2F0Y2hFcnJvcnM6ICEhc2VuZE9uRXJyb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3VsZEhvdFJlbG9hZDogb3B0aW9ucy5zaG91bGRIb3RSZWxvYWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3VsZFJlY29yZENoYW5nZXM6IG9wdGlvbnMuc2hvdWxkUmVjb3JkQ2hhbmdlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkU3RhcnRMb2NrZWQ6IG9wdGlvbnMuc2hvdWxkU3RhcnRMb2NrZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdXNlQWN0aW9uVHlwZTogb3B0aW9ucy5wYXVzZUFjdGlvblR5cGUgfHwgJ0BAUEFVU0VEJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gKSggcmVkdWNlciwgaW5pdGlhbFN0YXRlICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHJlYWx0aW1lICkgc3RhcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9yZS5zdWJzY3JpYmUoIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBpc01vbml0b3JlZCApIGhhbmRsZUNoYW5nZSggc3RvcmUuZ2V0U3RhdGUoKSwgc3RvcmUubGlmdGVkU3RvcmUuZ2V0U3RhdGUoKSwgbWF4QWdlICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdG9yZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gcHJlRGV2VG9vbHMoIGNyZWF0ZVN0b3JlICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCByZWR1Y2VyLCBwcmVsb2FkZWRTdGF0ZSwgZW5oYW5jZXIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9yZSA9IGNyZWF0ZVN0b3JlKCByZWR1Y2VyLCBwcmVsb2FkZWRTdGF0ZSwgZW5oYW5jZXIgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfZXh0ZW5kcygge30sIHN0b3JlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2g6IGZ1bmN0aW9uIGRpc3BhdGNoKCBhY3Rpb24gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsb2NrZWQgPyBhY3Rpb24gOiBzdG9yZS5kaXNwYXRjaCggYWN0aW9uICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSApO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRldlRvb2xzLnVwZGF0ZVN0b3JlID0gZnVuY3Rpb24gKCBuZXdTdG9yZSApIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcmUgPSBuZXdTdG9yZTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gY29tcG9zZVdpdGhEZXZUb29scygpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICggdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBmdW5jcyA9IEFycmF5KCBfbGVuICksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoIGZ1bmNzLmxlbmd0aCA9PT0gMCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkZXZUb29scztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICggZnVuY3MubGVuZ3RoID09PSAxICYmIF90eXBlb2YoIGZ1bmNzWzBdICkgPT09ICdvYmplY3QnICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRldlRvb2xzKCBmdW5jc1swXSApO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICggb3B0aW9ucyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtwcmVEZXZUb29sc10uY29uY2F0KCBmdW5jcyApLnJlZHVjZVJpZ2h0KCBmdW5jdGlvbiAoIGNvbXBvc2VkLCBmICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZiggY29tcG9zZWQgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBkZXZUb29scyggb3B0aW9ucyApLmFwcGx5KCB1bmRlZmluZWQsIGFyZ3VtZW50cyApICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8qKiovXG59LFxuLyogNTUgKi9cbi8qKiovIGZ1bmN0aW9uICggbW9kdWxlLCBleHBvcnRzICkge1xuXG4gICAgICAgICAgICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgICAgICAgICAgICAgZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBleHBvcnRzLmdldEhvc3RGb3JSTiA9IGdldEhvc3RGb3JSTjtcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIEdldCBSZWFjdCBOYXRpdmUgc2VydmVyIElQIGlmIGhvc3RuYW1lIGlzIGBsb2NhbGhvc3RgXG4gICAgICAgICAgICAgICAgICogT24gQW5kcm9pZCBlbXVsYXRvciwgdGhlIElQIG9mIGhvc3QgaXMgYDEwLjAuMi4yYCAoR2VueW1vdGlvbjogMTAuMC4zLjIpXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZ2V0SG9zdEZvclJOKCBob3N0bmFtZSApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAoIGhvc3RuYW1lID09PSAnbG9jYWxob3N0JyB8fCBob3N0bmFtZSA9PT0gJzEyNy4wLjAuMScgKSAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuX19mYkJhdGNoZWRCcmlkZ2UgJiYgd2luZG93Ll9fZmJCYXRjaGVkQnJpZGdlLlJlbW90ZU1vZHVsZXMgJiYgd2luZG93Ll9fZmJCYXRjaGVkQnJpZGdlLlJlbW90ZU1vZHVsZXMuQW5kcm9pZENvbnN0YW50cyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfd2luZG93JF9fZmJCYXRjaGVkQnIgPSB3aW5kb3cuX19mYkJhdGNoZWRCcmlkZ2UuUmVtb3RlTW9kdWxlcy5BbmRyb2lkQ29uc3RhbnRzLlNlcnZlckhvc3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgU2VydmVySG9zdCA9IF93aW5kb3ckX19mYkJhdGNoZWRCciA9PT0gdW5kZWZpbmVkID8gaG9zdG5hbWUgOiBfd2luZG93JF9fZmJCYXRjaGVkQnI7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBTZXJ2ZXJIb3N0LnNwbGl0KCAnOicgKVswXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBob3N0bmFtZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvKioqL1xufSxcbi8qIDU2ICovXG4vKioqLyBmdW5jdGlvbiAoIG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyApIHtcblxuICAgICAgICAgICAgICAgIHZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzsvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oIGZ1bmN0aW9uICggbW9kdWxlLCBnbG9iYWwgKSB7LyohIGh0dHA6Ly9tdGhzLmJlL2Jhc2U2NCB2MC4xLjAgYnkgQG1hdGhpYXMgfCBNSVQgbGljZW5zZSAqL1xuICAgICAgICAgICAgICAgICAgICA7ICggZnVuY3Rpb24gKCByb290ICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEZXRlY3QgZnJlZSB2YXJpYWJsZXMgYGV4cG9ydHNgLlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZnJlZU1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPT0gZnJlZUV4cG9ydHMgJiYgbW9kdWxlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCwgZnJvbSBOb2RlLmpzIG9yIEJyb3dzZXJpZmllZCBjb2RlLCBhbmQgdXNlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpdCBhcyBgcm9vdGAuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCB8fCBmcmVlR2xvYmFsLndpbmRvdyA9PT0gZnJlZUdsb2JhbCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb290ID0gZnJlZUdsb2JhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBJbnZhbGlkQ2hhcmFjdGVyRXJyb3IgPSBmdW5jdGlvbiAoIG1lc3NhZ2UgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBJbnZhbGlkQ2hhcmFjdGVyRXJyb3IucHJvdG90eXBlID0gbmV3IEVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgSW52YWxpZENoYXJhY3RlckVycm9yLnByb3RvdHlwZS5uYW1lID0gJ0ludmFsaWRDaGFyYWN0ZXJFcnJvcic7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9IGZ1bmN0aW9uICggbWVzc2FnZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3RlOiB0aGUgZXJyb3IgbWVzc2FnZXMgdXNlZCB0aHJvdWdob3V0IHRoaXMgZmlsZSBtYXRjaCB0aG9zZSB1c2VkIGJ5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIG5hdGl2ZSBgYXRvYmAvYGJ0b2FgIGltcGxlbWVudGF0aW9uIGluIENocm9taXVtLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQ2hhcmFjdGVyRXJyb3IoIG1lc3NhZ2UgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBUQUJMRSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJztcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly93aGF0d2cub3JnL2h0bWwvY29tbW9uLW1pY3Jvc3ludGF4ZXMuaHRtbCNzcGFjZS1jaGFyYWN0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBSRUdFWF9TUEFDRV9DSEFSQUNURVJTID0gL1tcXHRcXG5cXGZcXHIgXS9nO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBgZGVjb2RlYCBpcyBkZXNpZ25lZCB0byBiZSBmdWxseSBjb21wYXRpYmxlIHdpdGggYGF0b2JgIGFzIGRlc2NyaWJlZCBpbiB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhUTUwgU3RhbmRhcmQuIGh0dHA6Ly93aGF0d2cub3JnL2h0bWwvd2ViYXBwYXBpcy5odG1sI2RvbS13aW5kb3diYXNlNjQtYXRvYlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG9wdGltaXplZCBiYXNlNjQtZGVjb2RpbmcgYWxnb3JpdGhtIHVzZWQgaXMgYmFzZWQgb24gQGF0a+KAmXMgZXhjZWxsZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpbXBsZW1lbnRhdGlvbi4gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vYXRrLzEwMjAzOTZcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWNvZGUgPSBmdW5jdGlvbiAoIGlucHV0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0ID0gU3RyaW5nKCBpbnB1dCApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKCBSRUdFWF9TUEFDRV9DSEFSQUNURVJTLCAnJyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZW5ndGggPSBpbnB1dC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBsZW5ndGggJSA0ID09IDAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZSggLz09PyQvLCAnJyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSBpbnB1dC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoICUgNCA9PSAxIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly93aGF0d2cub3JnL0MjYWxwaGFudW1lcmljLWFzY2lpLWNoYXJhY3RlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgL1teK2EtekEtWjAtOS9dLy50ZXN0KCBpbnB1dCApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0ludmFsaWQgY2hhcmFjdGVyOiB0aGUgc3RyaW5nIHRvIGJlIGRlY29kZWQgaXMgbm90IGNvcnJlY3RseSBlbmNvZGVkLidcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJpdENvdW50ZXIgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiaXRTdG9yYWdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBidWZmZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG91dHB1dCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICggKytwb3NpdGlvbiA8IGxlbmd0aCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyID0gVEFCTEUuaW5kZXhPZiggaW5wdXQuY2hhckF0KCBwb3NpdGlvbiApICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpdFN0b3JhZ2UgPSBiaXRDb3VudGVyICUgNCA/IGJpdFN0b3JhZ2UgKiA2NCArIGJ1ZmZlciA6IGJ1ZmZlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVW5sZXNzIHRoaXMgaXMgdGhlIGZpcnN0IG9mIGEgZ3JvdXAgb2YgNCBjaGFyYWN0ZXJz4oCmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggYml0Q291bnRlcisrICUgNCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIOKApmNvbnZlcnQgdGhlIGZpcnN0IDggYml0cyB0byBhIHNpbmdsZSBBU0NJSSBjaGFyYWN0ZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweEZGICYgYml0U3RvcmFnZSA+PiAoIC0yICogYml0Q291bnRlciAmIDYgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYGVuY29kZWAgaXMgZGVzaWduZWQgdG8gYmUgZnVsbHkgY29tcGF0aWJsZSB3aXRoIGBidG9hYCBhcyBkZXNjcmliZWQgaW4gdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBIVE1MIFN0YW5kYXJkOiBodHRwOi8vd2hhdHdnLm9yZy9odG1sL3dlYmFwcGFwaXMuaHRtbCNkb20td2luZG93YmFzZTY0LWJ0b2FcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbmNvZGUgPSBmdW5jdGlvbiAoIGlucHV0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0ID0gU3RyaW5nKCBpbnB1dCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggL1teXFwwLVxceEZGXS8udGVzdCggaW5wdXQgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90ZTogbm8gbmVlZCB0byBzcGVjaWFsLWNhc2UgYXN0cmFsIHN5bWJvbHMgaGVyZSwgYXMgc3Vycm9nYXRlcyBhcmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWF0Y2hlZCwgYW5kIHRoZSBpbnB1dCBpcyBzdXBwb3NlZCB0byBvbmx5IGNvbnRhaW4gQVNDSUkgYW55d2F5LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdUaGUgc3RyaW5nIHRvIGJlIGVuY29kZWQgY29udGFpbnMgY2hhcmFjdGVycyBvdXRzaWRlIG9mIHRoZSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdMYXRpbjEgcmFuZ2UuJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFkZGluZyA9IGlucHV0Lmxlbmd0aCAlIDM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG91dHB1dCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBidWZmZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIGFueSBwYWRkaW5nIGlzIGhhbmRsZWQgb3V0c2lkZSBvZiB0aGUgbG9vcC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoID0gaW5wdXQubGVuZ3RoIC0gcGFkZGluZztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICggKytwb3NpdGlvbiA8IGxlbmd0aCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVhZCB0aHJlZSBieXRlcywgaS5lLiAyNCBiaXRzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhID0gaW5wdXQuY2hhckNvZGVBdCggcG9zaXRpb24gKSA8PCAxNjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYiA9IGlucHV0LmNoYXJDb2RlQXQoICsrcG9zaXRpb24gKSA8PCA4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjID0gaW5wdXQuY2hhckNvZGVBdCggKytwb3NpdGlvbiApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIgPSBhICsgYiArIGM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFR1cm4gdGhlIDI0IGJpdHMgaW50byBmb3VyIGNodW5rcyBvZiA2IGJpdHMgZWFjaCwgYW5kIGFwcGVuZCB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWF0Y2hpbmcgY2hhcmFjdGVyIGZvciBlYWNoIG9mIHRoZW0gdG8gdGhlIG91dHB1dC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0ICs9IChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRBQkxFLmNoYXJBdCggYnVmZmVyID4+IDE4ICYgMHgzRiApICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRBQkxFLmNoYXJBdCggYnVmZmVyID4+IDEyICYgMHgzRiApICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRBQkxFLmNoYXJBdCggYnVmZmVyID4+IDYgJiAweDNGICkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVEFCTEUuY2hhckF0KCBidWZmZXIgJiAweDNGIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHBhZGRpbmcgPT0gMiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSA9IGlucHV0LmNoYXJDb2RlQXQoIHBvc2l0aW9uICkgPDwgODtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYiA9IGlucHV0LmNoYXJDb2RlQXQoICsrcG9zaXRpb24gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyID0gYSArIGI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dCArPSAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUQUJMRS5jaGFyQXQoIGJ1ZmZlciA+PiAxMCApICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRBQkxFLmNoYXJBdCggKCBidWZmZXIgPj4gNCApICYgMHgzRiApICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRBQkxFLmNoYXJBdCggKCBidWZmZXIgPDwgMiApICYgMHgzRiApICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICc9J1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIHBhZGRpbmcgPT0gMSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyID0gaW5wdXQuY2hhckNvZGVBdCggcG9zaXRpb24gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0ICs9IChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRBQkxFLmNoYXJBdCggYnVmZmVyID4+IDIgKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUQUJMRS5jaGFyQXQoICggYnVmZmVyIDw8IDQgKSAmIDB4M0YgKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPT0nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiYXNlNjQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2VuY29kZSc6IGVuY29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZGVjb2RlJzogZGVjb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICd2ZXJzaW9uJzogJzAuMS4wJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3Igc3BlY2lmaWMgY29uZGl0aW9uIHBhdHRlcm5zXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBsaWtlIHRoZSBmb2xsb3dpbmc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgISggX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBiYXNlNjQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfS5jYWxsKCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fLCBleHBvcnRzLCBtb2R1bGUgKSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAoIG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gKSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICggZnJlZUV4cG9ydHMgJiYgIWZyZWVFeHBvcnRzLm5vZGVUeXBlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZnJlZU1vZHVsZSApIHsgLy8gaW4gTm9kZS5qcyBvciBSaW5nb0pTIHYwLjguMCtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJlZU1vZHVsZS5leHBvcnRzID0gYmFzZTY0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7IC8vIGluIE5hcndoYWwgb3IgUmluZ29KUyB2MC43LjAtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIHZhciBrZXkgaW4gYmFzZTY0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFzZTY0Lmhhc093blByb3BlcnR5KCBrZXkgKSAmJiAoIGZyZWVFeHBvcnRzW2tleV0gPSBiYXNlNjRba2V5XSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsgLy8gaW4gUmhpbm8gb3IgYSB3ZWIgYnJvd3NlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvb3QuYmFzZTY0ID0gYmFzZTY0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIH0oIHRoaXMgKSApO1xuXG4gICAgICAgICAgICAgICAgICAgIC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL1xufS5jYWxsKCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKCA1MSApKCBtb2R1bGUgKSwgKCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KCkgKSApIClcblxuICAgICAgICAgICAgICAgIC8qKiovXG59LFxuLyogNTcgKi9cbi8qKiovIGZ1bmN0aW9uICggbW9kdWxlLCBleHBvcnRzICkge1xuXG4gICAgICAgICAgICAgICAgJ3VzZSBzdHJpY3QnXG5cbiAgICAgICAgICAgICAgICBleHBvcnRzLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG4gICAgICAgICAgICAgICAgZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG4gICAgICAgICAgICAgICAgZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG4gICAgICAgICAgICAgICAgdmFyIGxvb2t1cCA9IFtdXG4gICAgICAgICAgICAgICAgdmFyIHJldkxvb2t1cCA9IFtdXG4gICAgICAgICAgICAgICAgdmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG4gICAgICAgICAgICAgICAgdmFyIGNvZGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLydcbiAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kgKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvb2t1cFtpXSA9IGNvZGVbaV1cbiAgICAgICAgICAgICAgICAgICAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdCggaSApXSA9IGlcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoIDAgKV0gPSA2MlxuICAgICAgICAgICAgICAgIHJldkxvb2t1cFsnXycuY2hhckNvZGVBdCggMCApXSA9IDYzXG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBwbGFjZUhvbGRlcnNDb3VudCggYjY0ICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICBpZiAoIGxlbiAlIDQgPiAwICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCAnSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcgKVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIG51bWJlciBvZiBlcXVhbCBzaWducyAocGxhY2UgaG9sZGVycylcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgYXJlIHR3byBwbGFjZWhvbGRlcnMsIHRoYW4gdGhlIHR3byBjaGFyYWN0ZXJzIGJlZm9yZSBpdFxuICAgICAgICAgICAgICAgICAgICAvLyByZXByZXNlbnQgb25lIGJ5dGVcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgb25seSBvbmUsIHRoZW4gdGhlIHRocmVlIGNoYXJhY3RlcnMgYmVmb3JlIGl0IHJlcHJlc2VudCAyIGJ5dGVzXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMganVzdCBhIGNoZWFwIGhhY2sgdG8gbm90IGRvIGluZGV4T2YgdHdpY2VcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGI2NFtsZW4gLSAyXSA9PT0gJz0nID8gMiA6IGI2NFtsZW4gLSAxXSA9PT0gJz0nID8gMSA6IDBcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBieXRlTGVuZ3RoKCBiNjQgKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYjY0Lmxlbmd0aCAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzQ291bnQoIGI2NCApXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gdG9CeXRlQXJyYXkoIGI2NCApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGksIGosIGwsIHRtcCwgcGxhY2VIb2xkZXJzLCBhcnJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgcGxhY2VIb2xkZXJzID0gcGxhY2VIb2xkZXJzQ291bnQoIGI2NCApXG5cbiAgICAgICAgICAgICAgICAgICAgYXJyID0gbmV3IEFyciggbGVuICogMyAvIDQgLSBwbGFjZUhvbGRlcnMgKVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgICAgICAgICAgICAgICAgICAgbCA9IHBsYWNlSG9sZGVycyA+IDAgPyBsZW4gLSA0IDogbGVuXG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIEwgPSAwXG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICggaSA9IDAsIGogPSAwOyBpIDwgbDsgaSArPSA0LCBqICs9IDMgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0bXAgPSAoIHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdCggaSApXSA8PCAxOCApIHwgKCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoIGkgKyAxICldIDw8IDEyICkgfCAoIHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdCggaSArIDIgKV0gPDwgNiApIHwgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KCBpICsgMyApXVxuICAgICAgICAgICAgICAgICAgICAgICAgYXJyW0wrK10gPSAoIHRtcCA+PiAxNiApICYgMHhGRlxuICAgICAgICAgICAgICAgICAgICAgICAgYXJyW0wrK10gPSAoIHRtcCA+PiA4ICkgJiAweEZGXG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkZcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICggcGxhY2VIb2xkZXJzID09PSAyICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG1wID0gKCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoIGkgKV0gPDwgMiApIHwgKCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoIGkgKyAxICldID4+IDQgKVxuICAgICAgICAgICAgICAgICAgICAgICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIHBsYWNlSG9sZGVycyA9PT0gMSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRtcCA9ICggcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KCBpICldIDw8IDEwICkgfCAoIHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdCggaSArIDEgKV0gPDwgNCApIHwgKCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoIGkgKyAyICldID4+IDIgKVxuICAgICAgICAgICAgICAgICAgICAgICAgYXJyW0wrK10gPSAoIHRtcCA+PiA4ICkgJiAweEZGXG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkZcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhcnJcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQoIG51bSApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICsgbG9va3VwW251bSAmIDB4M0ZdXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZW5jb2RlQ2h1bmsoIHVpbnQ4LCBzdGFydCwgZW5kICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdG1wXG4gICAgICAgICAgICAgICAgICAgIHZhciBvdXRwdXQgPSBbXVxuICAgICAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0bXAgPSAoIHVpbnQ4W2ldIDw8IDE2ICkgKyAoIHVpbnQ4W2kgKyAxXSA8PCA4ICkgKyAoIHVpbnQ4W2kgKyAyXSApXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaCggdHJpcGxldFRvQmFzZTY0KCB0bXAgKSApXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG91dHB1dC5qb2luKCAnJyApXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSggdWludDggKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0bXBcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDMgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcbiAgICAgICAgICAgICAgICAgICAgdmFyIG91dHB1dCA9ICcnXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJ0cyA9IFtdXG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzIC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcbiAgICAgICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsZW4yID0gbGVuIC0gZXh0cmFCeXRlczsgaSA8IGxlbjI7IGkgKz0gbWF4Q2h1bmtMZW5ndGggKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKCBlbmNvZGVDaHVuayggdWludDgsIGksICggaSArIG1heENodW5rTGVuZ3RoICkgPiBsZW4yID8gbGVuMiA6ICggaSArIG1heENodW5rTGVuZ3RoICkgKSApXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG4gICAgICAgICAgICAgICAgICAgIGlmICggZXh0cmFCeXRlcyA9PT0gMSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQgKz0gbG9va3VwW3RtcCA+PiAyXVxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0ICs9IGxvb2t1cFsoIHRtcCA8PCA0ICkgJiAweDNGXVxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0ICs9ICc9PSdcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICggZXh0cmFCeXRlcyA9PT0gMiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRtcCA9ICggdWludDhbbGVuIC0gMl0gPDwgOCApICsgKCB1aW50OFtsZW4gLSAxXSApXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQgKz0gbG9va3VwW3RtcCA+PiAxMF1cbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dCArPSBsb29rdXBbKCB0bXAgPj4gNCApICYgMHgzRl1cbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dCArPSBsb29rdXBbKCB0bXAgPDwgMiApICYgMHgzRl1cbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dCArPSAnPSdcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goIG91dHB1dCApXG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnRzLmpvaW4oICcnIClcbiAgICAgICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgICAgIC8qKiovXG59LFxuLyogNTggKi9cbi8qKiovIGZ1bmN0aW9uICggbW9kdWxlLCBleHBvcnRzICkge1xuXG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBFeHBvc2UgYEVtaXR0ZXJgLlxuICAgICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBFbWl0dGVyO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogSW5pdGlhbGl6ZSBhIG5ldyBgRW1pdHRlcmAuXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gRW1pdHRlciggb2JqICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIG9iaiApIHJldHVybiBtaXhpbiggb2JqICk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIE1peGluIHRoZSBlbWl0dGVyIHByb3BlcnRpZXMuXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gICAgICAgICAgICAgICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAgICAgICAgICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gbWl4aW4oIG9iaiApIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICggdmFyIGtleSBpbiBFbWl0dGVyLnByb3RvdHlwZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ialtrZXldID0gRW1pdHRlci5wcm90b3R5cGVba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIExpc3RlbiBvbiB0aGUgZ2l2ZW4gYGV2ZW50YCB3aXRoIGBmbmAuXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICAgICAgICAgICAgICAgICAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gICAgICAgICAgICAgICAgICogQGFwaSBwdWJsaWNcbiAgICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgICAgIEVtaXR0ZXIucHJvdG90eXBlLm9uID1cbiAgICAgICAgICAgICAgICAgICAgRW1pdHRlci5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uICggZXZlbnQsIGZuICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgKCB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSB8fCBbXSApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnB1c2goIGZuICk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEFkZHMgYW4gYGV2ZW50YCBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgaW52b2tlZCBhIHNpbmdsZVxuICAgICAgICAgICAgICAgICAqIHRpbWUgdGhlbiBhdXRvbWF0aWNhbGx5IHJlbW92ZWQuXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICAgICAgICAgICAgICAgICAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gICAgICAgICAgICAgICAgICogQGFwaSBwdWJsaWNcbiAgICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgICAgIEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiAoIGV2ZW50LCBmbiApIHtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9mZiggZXZlbnQsIG9uICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmbi5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBvbi5mbiA9IGZuO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uKCBldmVudCwgb24gKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFJlbW92ZSB0aGUgZ2l2ZW4gY2FsbGJhY2sgZm9yIGBldmVudGAgb3IgYWxsXG4gICAgICAgICAgICAgICAgICogcmVnaXN0ZXJlZCBjYWxsYmFja3MuXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICAgICAgICAgICAgICAgICAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gICAgICAgICAgICAgICAgICogQGFwaSBwdWJsaWNcbiAgICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgICAgIEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9XG4gICAgICAgICAgICAgICAgICAgIEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cbiAgICAgICAgICAgICAgICAgICAgRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cbiAgICAgICAgICAgICAgICAgICAgRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uICggZXZlbnQsIGZuICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbGxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggMCA9PSBhcmd1bWVudHMubGVuZ3RoICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhbGxiYWNrcyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzcGVjaWZpYyBldmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoICFjYWxsYmFja3MgKSByZXR1cm4gdGhpcztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGFsbCBoYW5kbGVyc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAxID09IGFyZ3VtZW50cy5sZW5ndGggKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBzcGVjaWZpYyBoYW5kbGVyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2I7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2IgPSBjYWxsYmFja3NbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3Muc3BsaWNlKCBpLCAxICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogRW1pdCBgZXZlbnRgIHdpdGggdGhlIGdpdmVuIGFyZ3MuXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge01peGVkfSAuLi5cbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHtFbWl0dGVyfVxuICAgICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICAgICAgRW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uICggZXZlbnQgKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKCBhcmd1bWVudHMsIDEgKVxuICAgICAgICAgICAgICAgICAgICAgICAgLCBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggY2FsbGJhY2tzICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzID0gY2FsbGJhY2tzLnNsaWNlKCAwICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGxlbiA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsZW47ICsraSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3NbaV0uYXBwbHkoIHRoaXMsIGFyZ3MgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBSZXR1cm4gYXJyYXkgb2YgY2FsbGJhY2tzIGZvciBgZXZlbnRgLlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gICAgICAgICAgICAgICAgICogQHJldHVybiB7QXJyYXl9XG4gICAgICAgICAgICAgICAgICogQGFwaSBwdWJsaWNcbiAgICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgICAgIEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uICggZXZlbnQgKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gfHwgW107XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIENoZWNrIGlmIHRoaXMgZW1pdHRlciBoYXMgYGV2ZW50YCBoYW5kbGVycy5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICAgICAgICAgICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICAgICAgICAgICAgICogQGFwaSBwdWJsaWNcbiAgICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgICAgIEVtaXR0ZXIucHJvdG90eXBlLmhhc0xpc3RlbmVycyA9IGZ1bmN0aW9uICggZXZlbnQgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhIXRoaXMubGlzdGVuZXJzKCBldmVudCApLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9O1xuXG5cbiAgICAgICAgICAgICAgICAvKioqL1xufSxcbi8qIDU5ICovXG4vKioqLyBmdW5jdGlvbiAoIG1vZHVsZSwgZXhwb3J0cyApIHtcblxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgIGN5Y2xlLmpzXG4gICAgICAgICAgICAgICAgICAgIDIwMTMtMDItMTlcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBQdWJsaWMgRG9tYWluLlxuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIE5PIFdBUlJBTlRZIEVYUFJFU1NFRCBPUiBJTVBMSUVELiBVU0UgQVQgWU9VUiBPV04gUklTSy5cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBUaGlzIGNvZGUgc2hvdWxkIGJlIG1pbmlmaWVkIGJlZm9yZSBkZXBsb3ltZW50LlxuICAgICAgICAgICAgICAgICAgICBTZWUgaHR0cDovL2phdmFzY3JpcHQuY3JvY2tmb3JkLmNvbS9qc21pbi5odG1sXG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgVVNFIFlPVVIgT1dOIENPUFkuIElUIElTIEVYVFJFTUVMWSBVTldJU0UgVE8gTE9BRCBDT0RFIEZST00gU0VSVkVSUyBZT1UgRE9cbiAgICAgICAgICAgICAgICAgICAgTk9UIENPTlRST0wuXG4gICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgICAgIC8qanNsaW50IGV2aWw6IHRydWUsIHJlZ2V4cDogdHJ1ZSAqL1xuXG4gICAgICAgICAgICAgICAgLyptZW1iZXJzICRyZWYsIGFwcGx5LCBjYWxsLCBkZWN5Y2xlLCBoYXNPd25Qcm9wZXJ0eSwgbGVuZ3RoLCBwcm90b3R5cGUsIHB1c2gsXG4gICAgICAgICAgICAgICAgICAgIHJldHJvY3ljbGUsIHN0cmluZ2lmeSwgdGVzdCwgdG9TdHJpbmdcbiAgICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICAgICAgdmFyIGN5Y2xlID0gZXhwb3J0cztcblxuICAgICAgICAgICAgICAgIGN5Y2xlLmRlY3ljbGUgPSBmdW5jdGlvbiBkZWN5Y2xlKCBvYmplY3QgKSB7XG4gICAgICAgICAgICAgICAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIGEgZGVlcCBjb3B5IG9mIGFuIG9iamVjdCBvciBhcnJheSwgYXNzdXJpbmcgdGhhdCB0aGVyZSBpcyBhdCBtb3N0XG4gICAgICAgICAgICAgICAgICAgIC8vIG9uZSBpbnN0YW5jZSBvZiBlYWNoIG9iamVjdCBvciBhcnJheSBpbiB0aGUgcmVzdWx0aW5nIHN0cnVjdHVyZS4gVGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIGR1cGxpY2F0ZSByZWZlcmVuY2VzICh3aGljaCBtaWdodCBiZSBmb3JtaW5nIGN5Y2xlcykgYXJlIHJlcGxhY2VkIHdpdGhcbiAgICAgICAgICAgICAgICAgICAgLy8gYW4gb2JqZWN0IG9mIHRoZSBmb3JtXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgeyRyZWY6IFBBVEh9XG4gICAgICAgICAgICAgICAgICAgIC8vIHdoZXJlIHRoZSBQQVRIIGlzIGEgSlNPTlBhdGggc3RyaW5nIHRoYXQgbG9jYXRlcyB0aGUgZmlyc3Qgb2NjdXJhbmNlLlxuICAgICAgICAgICAgICAgICAgICAvLyBTbyxcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICB2YXIgYSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAvLyAgICAgIGFbMF0gPSBhO1xuICAgICAgICAgICAgICAgICAgICAvLyAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShKU09OLmRlY3ljbGUoYSkpO1xuICAgICAgICAgICAgICAgICAgICAvLyBwcm9kdWNlcyB0aGUgc3RyaW5nICdbe1wiJHJlZlwiOlwiJFwifV0nLlxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEpTT05QYXRoIGlzIHVzZWQgdG8gbG9jYXRlIHRoZSB1bmlxdWUgb2JqZWN0LiAkIGluZGljYXRlcyB0aGUgdG9wIGxldmVsIG9mXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBvYmplY3Qgb3IgYXJyYXkuIFtOVU1CRVJdIG9yIFtTVFJJTkddIGluZGljYXRlcyBhIGNoaWxkIG1lbWJlciBvclxuICAgICAgICAgICAgICAgICAgICAvLyBwcm9wZXJ0eS5cblxuICAgICAgICAgICAgICAgICAgICB2YXIgb2JqZWN0cyA9IFtdLCAgIC8vIEtlZXAgYSByZWZlcmVuY2UgdG8gZWFjaCB1bmlxdWUgb2JqZWN0IG9yIGFycmF5XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRocyA9IFtdOyAgICAgLy8gS2VlcCB0aGUgcGF0aCB0byBlYWNoIHVuaXF1ZSBvYmplY3Qgb3IgYXJyYXlcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCBmdW5jdGlvbiBkZXJleiggdmFsdWUsIHBhdGggKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBkZXJleiByZWN1cnNlcyB0aHJvdWdoIHRoZSBvYmplY3QsIHByb2R1Y2luZyB0aGUgZGVlcCBjb3B5LlxuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSwgICAgICAgICAgLy8gVGhlIGxvb3AgY291bnRlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUsICAgICAgIC8vIFByb3BlcnR5IG5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBudTsgICAgICAgICAvLyBUaGUgbmV3IG9iamVjdCBvciBhcnJheVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0eXBlb2YgbnVsbCA9PT0gJ29iamVjdCcsIHNvIGdvIG9uIGlmIHRoaXMgdmFsdWUgaXMgcmVhbGx5IGFuIG9iamVjdCBidXQgbm90XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvbmUgb2YgdGhlIHdlaXJkIGJ1aWx0aW4gb2JqZWN0cy5cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgISggdmFsdWUgaW5zdGFuY2VvZiBCb29sZWFuICkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhKCB2YWx1ZSBpbnN0YW5jZW9mIERhdGUgKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICEoIHZhbHVlIGluc3RhbmNlb2YgTnVtYmVyICkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhKCB2YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCApICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgISggdmFsdWUgaW5zdGFuY2VvZiBTdHJpbmcgKSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSB2YWx1ZSBpcyBhbiBvYmplY3Qgb3IgYXJyYXksIGxvb2sgdG8gc2VlIGlmIHdlIGhhdmUgYWxyZWFkeVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVuY291bnRlcmVkIGl0LiBJZiBzbywgcmV0dXJuIGEgJHJlZi9wYXRoIG9iamVjdC4gVGhpcyBpcyBhIGhhcmQgd2F5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxpbmVhciBzZWFyY2ggdGhhdCB3aWxsIGdldCBzbG93ZXIgYXMgdGhlIG51bWJlciBvZiB1bmlxdWUgb2JqZWN0cyBncm93cy5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIGkgPSAwOyBpIDwgb2JqZWN0cy5sZW5ndGg7IGkgKz0gMSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBvYmplY3RzW2ldID09PSB2YWx1ZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7ICRyZWY6IHBhdGhzW2ldIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIGFjY3VtdWxhdGUgdGhlIHVuaXF1ZSB2YWx1ZSBhbmQgaXRzIHBhdGguXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3RzLnB1c2goIHZhbHVlICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aHMucHVzaCggcGF0aCApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgaXQgaXMgYW4gYXJyYXksIHJlcGxpY2F0ZSB0aGUgYXJyYXkuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuYXBwbHkoIHZhbHVlICkgPT09ICdbb2JqZWN0IEFycmF5XScgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51ID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpICs9IDEgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudVtpXSA9IGRlcmV6KCB2YWx1ZVtpXSwgcGF0aCArICdbJyArIGkgKyAnXScgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgaXQgaXMgYW4gb2JqZWN0LCByZXBsaWNhdGUgdGhlIG9iamVjdC5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCBuYW1lIGluIHZhbHVlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoIHZhbHVlLCBuYW1lICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVbbmFtZV0gPSBkZXJleiggdmFsdWVbbmFtZV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGggKyAnWycgKyBKU09OLnN0cmluZ2lmeSggbmFtZSApICsgJ10nICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9KCBvYmplY3QsICckJyApICk7XG4gICAgICAgICAgICAgICAgfTtcblxuXG4gICAgICAgICAgICAgICAgY3ljbGUucmV0cm9jeWNsZSA9IGZ1bmN0aW9uIHJldHJvY3ljbGUoICQgKSB7XG4gICAgICAgICAgICAgICAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgICAgICAgICAgICAgICAvLyBSZXN0b3JlIGFuIG9iamVjdCB0aGF0IHdhcyByZWR1Y2VkIGJ5IGRlY3ljbGUuIE1lbWJlcnMgd2hvc2UgdmFsdWVzIGFyZVxuICAgICAgICAgICAgICAgICAgICAvLyBvYmplY3RzIG9mIHRoZSBmb3JtXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgeyRyZWY6IFBBVEh9XG4gICAgICAgICAgICAgICAgICAgIC8vIGFyZSByZXBsYWNlZCB3aXRoIHJlZmVyZW5jZXMgdG8gdGhlIHZhbHVlIGZvdW5kIGJ5IHRoZSBQQVRILiBUaGlzIHdpbGxcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVzdG9yZSBjeWNsZXMuIFRoZSBvYmplY3Qgd2lsbCBiZSBtdXRhdGVkLlxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBldmFsIGZ1bmN0aW9uIGlzIHVzZWQgdG8gbG9jYXRlIHRoZSB2YWx1ZXMgZGVzY3JpYmVkIGJ5IGEgUEFUSC4gVGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIHJvb3Qgb2JqZWN0IGlzIGtlcHQgaW4gYSAkIHZhcmlhYmxlLiBBIHJlZ3VsYXIgZXhwcmVzc2lvbiBpcyB1c2VkIHRvXG4gICAgICAgICAgICAgICAgICAgIC8vIGFzc3VyZSB0aGF0IHRoZSBQQVRIIGlzIGV4dHJlbWVseSB3ZWxsIGZvcm1lZC4gVGhlIHJlZ2V4cCBjb250YWlucyBuZXN0ZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gKiBxdWFudGlmaWVycy4gVGhhdCBoYXMgYmVlbiBrbm93biB0byBoYXZlIGV4dHJlbWVseSBiYWQgcGVyZm9ybWFuY2VcbiAgICAgICAgICAgICAgICAgICAgLy8gcHJvYmxlbXMgb24gc29tZSBicm93c2VycyBmb3IgdmVyeSBsb25nIHN0cmluZ3MuIEEgUEFUSCBpcyBleHBlY3RlZCB0byBiZVxuICAgICAgICAgICAgICAgICAgICAvLyByZWFzb25hYmx5IHNob3J0LiBBIFBBVEggaXMgYWxsb3dlZCB0byBiZWxvbmcgdG8gYSB2ZXJ5IHJlc3RyaWN0ZWQgc3Vic2V0IG9mXG4gICAgICAgICAgICAgICAgICAgIC8vIEdvZXNzbmVyJ3MgSlNPTlBhdGguXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU28sXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgdmFyIHMgPSAnW3tcIiRyZWZcIjpcIiRcIn1dJztcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICByZXR1cm4gSlNPTi5yZXRyb2N5Y2xlKEpTT04ucGFyc2UocykpO1xuICAgICAgICAgICAgICAgICAgICAvLyBwcm9kdWNlcyBhbiBhcnJheSBjb250YWluaW5nIGEgc2luZ2xlIGVsZW1lbnQgd2hpY2ggaXMgdGhlIGFycmF5IGl0c2VsZi5cblxuICAgICAgICAgICAgICAgICAgICB2YXIgcHggPVxuICAgICAgICAgICAgICAgICAgICAgICAgL15cXCQoPzpcXFsoPzpcXGQrfFxcXCIoPzpbXlxcXFxcXFwiXFx1MDAwMC1cXHUwMDFmXXxcXFxcKFtcXFxcXFxcIlxcL2JmbnJ0XXx1WzAtOWEtekEtWl17NH0pKSpcXFwiKVxcXSkqJC87XG5cbiAgICAgICAgICAgICAgICAgICAgKCBmdW5jdGlvbiByZXooIHZhbHVlICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgcmV6IGZ1bmN0aW9uIHdhbGtzIHJlY3Vyc2l2ZWx5IHRocm91Z2ggdGhlIG9iamVjdCBsb29raW5nIGZvciAkcmVmXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwcm9wZXJ0aWVzLiBXaGVuIGl0IGZpbmRzIG9uZSB0aGF0IGhhcyBhIHZhbHVlIHRoYXQgaXMgYSBwYXRoLCB0aGVuIGl0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZXBsYWNlcyB0aGUgJHJlZiBvYmplY3Qgd2l0aCBhIHJlZmVyZW5jZSB0byB0aGUgdmFsdWUgdGhhdCBpcyBmb3VuZCBieVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHBhdGguXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpLCBpdGVtLCBuYW1lLCBwYXRoO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmFwcGx5KCB2YWx1ZSApID09PSAnW29iamVjdCBBcnJheV0nICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSArPSAxICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbSA9IHZhbHVlW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBpdGVtICYmIHR5cGVvZiBpdGVtID09PSAnb2JqZWN0JyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoID0gaXRlbS4kcmVmO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdHlwZW9mIHBhdGggPT09ICdzdHJpbmcnICYmIHB4LnRlc3QoIHBhdGggKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVbaV0gPSBldmFsKCBwYXRoICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV6KCBpdGVtICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggbmFtZSBpbiB2YWx1ZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdHlwZW9mIHZhbHVlW25hbWVdID09PSAnb2JqZWN0JyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtID0gdmFsdWVbbmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBpdGVtICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoID0gaXRlbS4kcmVmO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJyAmJiBweC50ZXN0KCBwYXRoICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVtuYW1lXSA9IGV2YWwoIHBhdGggKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJleiggaXRlbSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KCAkICkgKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICQ7XG4gICAgICAgICAgICAgICAgfTtcblxuXG4gICAgICAgICAgICAgICAgLyoqKi9cbn0sXG4vKiA2MCAqL1xuLyoqKi8gZnVuY3Rpb24gKCBtb2R1bGUsIGV4cG9ydHMgKSB7XG5cbiAgICAgICAgICAgICAgICAvKiBnbG9iYWwgd2luZG93ICovXG4gICAgICAgICAgICAgICAgdmFyIEdldFBhcmFtcyA9IGZ1bmN0aW9uICggZnVuYyApIHtcbiAgICAgICAgICAgICAgICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggdHlwZW9mIGZ1bmMgIT09ICdmdW5jdGlvbicgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgcGF0dGVybkNvbW1lbnRzID0gLygoXFwvXFwvLiokKXwoXFwvXFwqW1xcc1xcU10qP1xcKlxcLykpL21nO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGF0dGVybkFyZ3VtZW50cyA9IC8oW15cXHMsXSspL2c7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGZ1bmNTdHJpbmcgPSBmdW5jXG4gICAgICAgICAgICAgICAgICAgICAgICAudG9TdHJpbmcoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoIHBhdHRlcm5Db21tZW50cywgJycgKTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gZnVuY1N0cmluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgLnNsaWNlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmNTdHJpbmcuaW5kZXhPZiggJygnICkgKyAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmNTdHJpbmcuaW5kZXhPZiggJyknIClcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXRjaCggcGF0dGVybkFyZ3VtZW50cyApO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggcmVzdWx0ID09PSBudWxsICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgaWYgKCB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgIT09ICd1bmRlZmluZWQnICkge1xuICAgICAgICAgICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IEdldFBhcmFtcztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICkge1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuR2V0UGFyYW1zID0gR2V0UGFyYW1zO1xuICAgICAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICAgICAgLyoqKi9cbn0sXG4vKiA2MSAqL1xuLyoqKi8gZnVuY3Rpb24gKCBtb2R1bGUsIGV4cG9ydHMgKSB7XG5cbiAgICAgICAgICAgICAgICBleHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoIGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlLCBtXG4gICAgICAgICAgICAgICAgICAgIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxXG4gICAgICAgICAgICAgICAgICAgIHZhciBlTWF4ID0gKCAxIDw8IGVMZW4gKSAtIDFcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gICAgICAgICAgICAgICAgICAgIHZhciBuQml0cyA9IC03XG4gICAgICAgICAgICAgICAgICAgIHZhciBpID0gaXNMRSA/ICggbkJ5dGVzIC0gMSApIDogMFxuICAgICAgICAgICAgICAgICAgICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICAgICAgICAgICAgICAgICAgICBpICs9IGRcblxuICAgICAgICAgICAgICAgICAgICBlID0gcyAmICggKCAxIDw8ICggLW5CaXRzICkgKSAtIDEgKVxuICAgICAgICAgICAgICAgICAgICBzID4+PSAoIC1uQml0cyApXG4gICAgICAgICAgICAgICAgICAgIG5CaXRzICs9IGVMZW5cbiAgICAgICAgICAgICAgICAgICAgZm9yICggOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDggKSB7IH1cblxuICAgICAgICAgICAgICAgICAgICBtID0gZSAmICggKCAxIDw8ICggLW5CaXRzICkgKSAtIDEgKVxuICAgICAgICAgICAgICAgICAgICBlID4+PSAoIC1uQml0cyApXG4gICAgICAgICAgICAgICAgICAgIG5CaXRzICs9IG1MZW5cbiAgICAgICAgICAgICAgICAgICAgZm9yICggOyBuQml0cyA+IDA7IG0gPSBtICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDggKSB7IH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoIGUgPT09IDAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlID0gMSAtIGVCaWFzXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIGUgPT09IGVNYXggKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbSA/IE5hTiA6ICggKCBzID8gLTEgOiAxICkgKiBJbmZpbml0eSApXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtID0gbSArIE1hdGgucG93KCAyLCBtTGVuIClcbiAgICAgICAgICAgICAgICAgICAgICAgIGUgPSBlIC0gZUJpYXNcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCBzID8gLTEgOiAxICkgKiBtICogTWF0aC5wb3coIDIsIGUgLSBtTGVuIClcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBleHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKCBidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcyApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGUsIG0sIGNcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVNYXggPSAoIDEgPDwgZUxlbiApIC0gMVxuICAgICAgICAgICAgICAgICAgICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJ0ID0gKCBtTGVuID09PSAyMyA/IE1hdGgucG93KCAyLCAtMjQgKSAtIE1hdGgucG93KCAyLCAtNzcgKSA6IDAgKVxuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IGlzTEUgPyAwIDogKCBuQnl0ZXMgLSAxIClcbiAgICAgICAgICAgICAgICAgICAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gICAgICAgICAgICAgICAgICAgIHZhciBzID0gdmFsdWUgPCAwIHx8ICggdmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCApID8gMSA6IDBcblxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IE1hdGguYWJzKCB2YWx1ZSApXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBpc05hTiggdmFsdWUgKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtID0gaXNOYU4oIHZhbHVlICkgPyAxIDogMFxuICAgICAgICAgICAgICAgICAgICAgICAgZSA9IGVNYXhcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUgPSBNYXRoLmZsb29yKCBNYXRoLmxvZyggdmFsdWUgKSAvIE1hdGguTE4yIClcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdmFsdWUgKiAoIGMgPSBNYXRoLnBvdyggMiwgLWUgKSApIDwgMSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLS1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjICo9IDJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZSArIGVCaWFzID49IDEgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coIDIsIDEgLSBlQmlhcyApXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHZhbHVlICogYyA+PSAyICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUrK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgLz0gMlxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGUgKyBlQmlhcyA+PSBlTWF4ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0gPSAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZSA9IGVNYXhcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIGUgKyBlQmlhcyA+PSAxICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0gPSAoIHZhbHVlICogYyAtIDEgKSAqIE1hdGgucG93KCAyLCBtTGVuIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlID0gZSArIGVCaWFzXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KCAyLCBlQmlhcyAtIDEgKSAqIE1hdGgucG93KCAyLCBtTGVuIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlID0gMFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICggOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDggKSB7IH1cblxuICAgICAgICAgICAgICAgICAgICBlID0gKCBlIDw8IG1MZW4gKSB8IG1cbiAgICAgICAgICAgICAgICAgICAgZUxlbiArPSBtTGVuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDggKSB7IH1cblxuICAgICAgICAgICAgICAgICAgICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbiAgICAgICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgICAgIC8qKiovXG59LFxuLyogNjIgKi9cbi8qKiovIGZ1bmN0aW9uICggbW9kdWxlLCBleHBvcnRzICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbiAgICAgICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKCBhcnIgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKCBhcnIgKSA9PSAnW29iamVjdCBBcnJheV0nO1xuICAgICAgICAgICAgICAgIH07XG5cblxuICAgICAgICAgICAgICAgIC8qKiovXG59LFxuLyogNjMgKi9cbi8qKiovIGZ1bmN0aW9uICggbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fICkge1xuXG4gICAgICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCA2NSApO1xuXG5cbiAgICAgICAgICAgICAgICAvKioqL1xufSxcbi8qIDY0ICovXG4vKioqLyBmdW5jdGlvbiAoIG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyApIHtcblxuICAgICAgICAgICAgICAgIHZhciBwYXRoR2V0dGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyggMjcgKTtcbiAgICAgICAgICAgICAgICB2YXIgdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCA2NiApO1xuXG4gICAgICAgICAgICAgICAgLy8gQmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL2RvdWdsYXNjcm9ja2ZvcmQvSlNPTi1qcy9ibG9iL21hc3Rlci9jeWNsZS5qc1xuXG4gICAgICAgICAgICAgICAgZXhwb3J0cy5kZWN5Y2xlID0gZnVuY3Rpb24gZGVjeWNsZSggb2JqZWN0LCBvcHRpb25zLCByZXBsYWNlciApIHtcbiAgICAgICAgICAgICAgICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBvYmplY3RzID0gW10sICAgLy8gS2VlcCBhIHJlZmVyZW5jZSB0byBlYWNoIHVuaXF1ZSBvYmplY3Qgb3IgYXJyYXlcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhzID0gW107ICAgICAvLyBLZWVwIHRoZSBwYXRoIHRvIGVhY2ggdW5pcXVlIG9iamVjdCBvciBhcnJheVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoIGZ1bmN0aW9uIGRlcmV6KCBfdmFsdWUsIHBhdGgsIGtleSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGRlcmV6IHJlY3Vyc2VzIHRocm91Z2ggdGhlIG9iamVjdCwgcHJvZHVjaW5nIHRoZSBkZWVwIGNvcHkuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpLCAgICAgICAgICAvLyBUaGUgbG9vcCBjb3VudGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSwgICAgICAgLy8gUHJvcGVydHkgbmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51OyAgICAgICAgIC8vIFRoZSBuZXcgb2JqZWN0IG9yIGFycmF5XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHR5cGVvZiBudWxsID09PSAnb2JqZWN0Jywgc28gZ28gb24gaWYgdGhpcyB2YWx1ZSBpcyByZWFsbHkgYW4gb2JqZWN0IGJ1dCBub3RcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9uZSBvZiB0aGUgd2VpcmQgYnVpbHRpbiBvYmplY3RzLlxuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSByZXBsYWNlciA/IHJlcGxhY2VyKCBrZXkgfHwgJycsIF92YWx1ZSApIDogX3ZhbHVlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG9wdGlvbnMuZGF0ZSAmJiB2YWx1ZSBpbnN0YW5jZW9mIERhdGUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgJGpzYW46ICdkJyArIHZhbHVlLmdldFRpbWUoKSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBvcHRpb25zLnJlZ2V4ICYmIHZhbHVlIGluc3RhbmNlb2YgUmVnRXhwICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7ICRqc2FuOiAncicgKyB1dGlscy5nZXRSZWdleEZsYWdzKCB2YWx1ZSApICsgJywnICsgdmFsdWUuc291cmNlIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG9wdGlvbnNbJ2Z1bmN0aW9uJ10gJiYgdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7ICRqc2FuOiAnZicgKyB1dGlscy5zdHJpbmdpZnlGdW5jdGlvbiggdmFsdWUsIG9wdGlvbnNbJ2Z1bmN0aW9uJ10gKSB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG9wdGlvbnNbJ3VuZGVmaW5lZCddICYmIHZhbHVlID09PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgJGpzYW46ICd1JyB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG9wdGlvbnNbJ2Vycm9yJ10gJiYgdmFsdWUgaW5zdGFuY2VvZiBFcnJvciApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyAkanNhbjogJ2UnICsgdmFsdWUubWVzc2FnZSB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdmFsdWUgJiYgdHlwZW9mIHZhbHVlLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvSlNPTigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhKCB2YWx1ZSBpbnN0YW5jZW9mIEJvb2xlYW4gKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICEoIHZhbHVlIGluc3RhbmNlb2YgRGF0ZSApICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgISggdmFsdWUgaW5zdGFuY2VvZiBOdW1iZXIgKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICEoIHZhbHVlIGluc3RhbmNlb2YgUmVnRXhwICkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhKCB2YWx1ZSBpbnN0YW5jZW9mIFN0cmluZyApICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgISggdmFsdWUgaW5zdGFuY2VvZiBFcnJvciApICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHZhbHVlIGlzIGFuIG9iamVjdCBvciBhcnJheSwgbG9vayB0byBzZWUgaWYgd2UgaGF2ZSBhbHJlYWR5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZW5jb3VudGVyZWQgaXQuIElmIHNvLCByZXR1cm4gYSAkcmVmL3BhdGggb2JqZWN0LiBUaGlzIGlzIGEgaGFyZCB3YXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbGluZWFyIHNlYXJjaCB0aGF0IHdpbGwgZ2V0IHNsb3dlciBhcyB0aGUgbnVtYmVyIG9mIHVuaXF1ZSBvYmplY3RzIGdyb3dzLlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggaSA9IDA7IGkgPCBvYmplY3RzLmxlbmd0aDsgaSArPSAxICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG9iamVjdHNbaV0gPT09IHZhbHVlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgJGpzYW46IHBhdGhzW2ldIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIGFjY3VtdWxhdGUgdGhlIHVuaXF1ZSB2YWx1ZSBhbmQgaXRzIHBhdGguXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3RzLnB1c2goIHZhbHVlICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aHMucHVzaCggcGF0aCApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgaXQgaXMgYW4gYXJyYXksIHJlcGxpY2F0ZSB0aGUgYXJyYXkuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuYXBwbHkoIHZhbHVlICkgPT09ICdbb2JqZWN0IEFycmF5XScgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51ID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpICs9IDEgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudVtpXSA9IGRlcmV6KCB2YWx1ZVtpXSwgcGF0aCArICdbJyArIGkgKyAnXScsIGkgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgaXQgaXMgYW4gb2JqZWN0LCByZXBsaWNhdGUgdGhlIG9iamVjdC5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCBuYW1lIGluIHZhbHVlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoIHZhbHVlLCBuYW1lICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5leHRQYXRoID0gL15cXHcrJC8udGVzdCggbmFtZSApID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJy4nICsgbmFtZSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdbJyArIEpTT04uc3RyaW5naWZ5KCBuYW1lICkgKyAnXSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVbbmFtZV0gPSBuYW1lID09PSAnJGpzYW4nID8gW2RlcmV6KCB2YWx1ZVtuYW1lXSwgcGF0aCArIG5leHRQYXRoICldIDogZGVyZXooIHZhbHVlW25hbWVdLCBwYXRoICsgbmV4dFBhdGgsIG5hbWUgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH0oIG9iamVjdCwgJyQnICkgKTtcbiAgICAgICAgICAgICAgICB9O1xuXG5cbiAgICAgICAgICAgICAgICBleHBvcnRzLnJldHJvY3ljbGUgPSBmdW5jdGlvbiByZXRyb2N5Y2xlKCAkICkge1xuICAgICAgICAgICAgICAgICAgICAndXNlIHN0cmljdCc7XG5cblxuICAgICAgICAgICAgICAgICAgICAoIGZ1bmN0aW9uIHJleiggdmFsdWUgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSByZXogZnVuY3Rpb24gd2Fsa3MgcmVjdXJzaXZlbHkgdGhyb3VnaCB0aGUgb2JqZWN0IGxvb2tpbmcgZm9yICRqc2FuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwcm9wZXJ0aWVzLiBXaGVuIGl0IGZpbmRzIG9uZSB0aGF0IGhhcyBhIHZhbHVlIHRoYXQgaXMgYSBwYXRoLCB0aGVuIGl0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZXBsYWNlcyB0aGUgJGpzYW4gb2JqZWN0IHdpdGggYSByZWZlcmVuY2UgdG8gdGhlIHZhbHVlIHRoYXQgaXMgZm91bmQgYnlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBwYXRoLlxuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSwgaXRlbSwgbmFtZSwgcGF0aDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5hcHBseSggdmFsdWUgKSA9PT0gJ1tvYmplY3QgQXJyYXldJyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkgKz0gMSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0gPSB2YWx1ZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggaXRlbSAmJiB0eXBlb2YgaXRlbSA9PT0gJ29iamVjdCcgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBpdGVtLiRqc2FuICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVtpXSA9IHV0aWxzLnJlc3RvcmUoIGl0ZW0uJGpzYW4sICQgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXooIGl0ZW0gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCBuYW1lIGluIHZhbHVlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBuYW1lID09PSAnJGpzYW4nICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlW25hbWVdID0gdmFsdWVbbmFtZV1bMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHR5cGVvZiB2YWx1ZVtuYW1lXSA9PT0gJ29iamVjdCcgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbSA9IHZhbHVlW25hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggaXRlbSAmJiB0eXBlb2YgaXRlbSA9PT0gJ29iamVjdCcgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggaXRlbS4kanNhbiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlW25hbWVdID0gdXRpbHMucmVzdG9yZSggaXRlbS4kanNhbiwgJCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV6KCBpdGVtICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0oICQgKSApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJDtcbiAgICAgICAgICAgICAgICB9O1xuXG5cbiAgICAgICAgICAgICAgICAvKioqL1xufSxcbi8qIDY1ICovXG4vKioqLyBmdW5jdGlvbiAoIG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyApIHtcblxuICAgICAgICAgICAgICAgIHZhciBjeWNsZSA9IF9fd2VicGFja19yZXF1aXJlX18oIDY0ICk7XG5cbiAgICAgICAgICAgICAgICBleHBvcnRzLnN0cmluZ2lmeSA9IGZ1bmN0aW9uIHN0cmluZ2lmeSggdmFsdWUsIHJlcGxhY2VyLCBzcGFjZSwgX29wdGlvbnMgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBhcmd1bWVudHMubGVuZ3RoIDwgNCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBhcmd1bWVudHMubGVuZ3RoID09PSAxICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoIHZhbHVlICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5LmFwcGx5KCBKU09OLCBhcmd1bWVudHMgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoICggZSApIHsgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBfb3B0aW9ucyB8fCBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCB0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Jvb2xlYW4nICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZGF0ZSc6IG9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2Z1bmN0aW9uJzogb3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAncmVnZXgnOiBvcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICd1bmRlZmluZWQnOiBvcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdlcnJvcic6IG9wdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWN5Y2xlZCA9IGN5Y2xlLmRlY3ljbGUoIHZhbHVlLCBvcHRpb25zLCByZXBsYWNlciApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoIGRlY3ljbGVkICk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoIGRlY3ljbGVkLCByZXBsYWNlciwgc3BhY2UgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZXhwb3J0cy5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKCB0ZXh0LCByZXZpdmVyICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmVlZHNSZXRyb2N5Y2xlID0gL1wiXFwkanNhblwiLy50ZXN0KCB0ZXh0ICk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJzZWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICggYXJndW1lbnRzLmxlbmd0aCA9PT0gMSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZCA9IEpTT04ucGFyc2UoIHRleHQgKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZCA9IEpTT04ucGFyc2UoIHRleHQsIHJldml2ZXIgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIG5lZWRzUmV0cm9jeWNsZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZCA9IGN5Y2xlLnJldHJvY3ljbGUoIHBhcnNlZCApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgICAgICAvKioqL1xufSxcbi8qIDY2ICovXG4vKioqLyBmdW5jdGlvbiAoIG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyApIHtcblxuICAgICAgICAgICAgICAgIHZhciBwYXRoR2V0dGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyggMjcgKTtcblxuICAgICAgICAgICAgICAgIGV4cG9ydHMuZ2V0UmVnZXhGbGFncyA9IGZ1bmN0aW9uIGdldFJlZ2V4RmxhZ3MoIHJlZ2V4ICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZmxhZ3MgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCByZWdleC5pZ25vcmVDYXNlICkgZmxhZ3MgKz0gJ2knO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIHJlZ2V4Lmdsb2JhbCApIGZsYWdzICs9ICdnJztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCByZWdleC5tdWx0aWxpbmUgKSBmbGFncyArPSAnbSc7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmbGFncztcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgZXhwb3J0cy5zdHJpbmdpZnlGdW5jdGlvbiA9IGZ1bmN0aW9uIHN0cmluZ2lmeUZ1bmN0aW9uKCBmbiwgY3VzdG9tVG9TdHJpbmcgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggdHlwZW9mIGN1c3RvbVRvU3RyaW5nID09PSAnZnVuY3Rpb24nICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1c3RvbVRvU3RyaW5nKCBmbiApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHIgPSBmbi50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSBzdHIubWF0Y2goIC9eW157XSp7fF5bXj1dKj0+LyApO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSBtYXRjaCA/IG1hdGNoWzBdIDogJzxmdW5jdGlvbj4gJztcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVuZCA9IHN0cltzdHIubGVuZ3RoIC0gMV0gPT09ICd9JyA/ICd9JyA6ICcnO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnQucmVwbGFjZSggL1xcclxcbnxcXG4vZywgJyAnICkucmVwbGFjZSggL1xccysvZywgJyAnICkgKyAnIC8qIC4uLiAqLyAnICsgZW5kO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBleHBvcnRzLnJlc3RvcmUgPSBmdW5jdGlvbiByZXN0b3JlKCBvYmosIHJvb3QgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0eXBlID0gb2JqWzBdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdCA9IG9iai5zbGljZSggMSApO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKCB0eXBlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnJCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhdGhHZXR0ZXIoIHJvb3QsIG9iaiApO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbW1hID0gcmVzdC5pbmRleE9mKCAnLCcgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmxhZ3MgPSByZXN0LnNsaWNlKCAwLCBjb21tYSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzb3VyY2UgPSByZXN0LnNsaWNlKCBjb21tYSArIDEgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUmVnRXhwKCBzb3VyY2UsIGZsYWdzICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoICtyZXN0ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdmJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZm4gPSBmdW5jdGlvbiAoKSB7IHRocm93IG5ldyBFcnJvciggXCJjYW4ndCBydW4ganNhbiBwYXJzZWQgZnVuY3Rpb25cIiApIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm4udG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiByZXN0OyB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3UnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoIHJlc3QgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvci5zdGFjayA9ICdTdGFjayBpcyB1bmF2YWlsYWJsZSBmb3IganNhbiBwYXJzZWQgZXJyb3JzJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ3Vua25vd24gdHlwZScsIG9iaiApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgICAgIC8qKiovXG59LFxuLyogNjcgKi9cbi8qKiovIGZ1bmN0aW9uICggbW9kdWxlLCBleHBvcnRzICkge1xuXG4gICAgICAgICAgICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQ29uc3RhbnRzLlxuICAgICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICAgICAgdmFyIGVycm9yTWVzc2FnZTtcblxuICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9ICdBbiBhcmd1bWVudCB3aXRob3V0IGFwcGVuZCwgcHJlcGVuZCwgJyArXG4gICAgICAgICAgICAgICAgICAgICdvciBkZXRhY2ggbWV0aG9kcyB3YXMgZ2l2ZW4gdG8gYExpc3QnO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBMaXN0OiBBIGxpbmtlZCBsaXN0IGlzIGEgYml0IGxpa2UgYW4gQXJyYXksIGJ1dFxuICAgICAgICAgICAgICAgICAqIGtub3dzIG5vdGhpbmcgYWJvdXQgaG93IG1hbnkgaXRlbXMgYXJlIGluIGl0LCBhbmQga25vd3Mgb25seSBhYm91dCBpdHNcbiAgICAgICAgICAgICAgICAgKiBmaXJzdCAoYGhlYWRgKSBhbmQgbGFzdCAoYHRhaWxgKSBpdGVtcy4gRWFjaCBpdGVtIChlLmcuIGBoZWFkYCwgYHRhaWxgLFxuICAgICAgICAgICAgICAgICAqICZjLikga25vd3Mgd2hpY2ggaXRlbSBjb21lcyBiZWZvcmUgb3IgYWZ0ZXIgaXQgKGl0cyBtb3JlIGxpa2UgdGhlXG4gICAgICAgICAgICAgICAgICogaW1wbGVtZW50YXRpb24gb2YgdGhlIERPTSBpbiBKYXZhU2NyaXB0KS5cbiAgICAgICAgICAgICAgICAgKiBAZ2xvYmFsXG4gICAgICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICAgICAgICAgKiBAY2xhc3MgUmVwcmVzZW50cyBhbiBpbnN0YW5jZSBvZiBMaXN0LlxuICAgICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gTGlzdCgvKml0ZW1zLi4uKi8gKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggYXJndW1lbnRzLmxlbmd0aCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBMaXN0LmZyb20oIGFyZ3VtZW50cyApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIExpc3RQcm90b3R5cGU7XG5cbiAgICAgICAgICAgICAgICBMaXN0UHJvdG90eXBlID0gTGlzdC5wcm90b3R5cGU7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IGxpc3QgZnJvbSB0aGUgYXJndW1lbnRzIChlYWNoIGEgbGlzdCBpdGVtKSBwYXNzZWQgaW4uXG4gICAgICAgICAgICAgICAgICogQG5hbWUgTGlzdC5vZlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Li4uTGlzdEl0ZW19IFtpdGVtc10gLSBaZXJvIG9yIG1vcmUgaXRlbXMgdG8gYXR0YWNoLlxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtsaXN0fSAtIEEgbmV3IGluc3RhbmNlIG9mIExpc3QuXG4gICAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgICAgICBMaXN0Lm9mID0gZnVuY3Rpb24gKC8qaXRlbXMuLi4qLyApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIExpc3QuZnJvbS5jYWxsKCB0aGlzLCBhcmd1bWVudHMgKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBsaXN0IGZyb20gdGhlIGdpdmVuIGFycmF5LWxpa2Ugb2JqZWN0IChlYWNoIGEgbGlzdCBpdGVtKVxuICAgICAgICAgICAgICAgICAqIHBhc3NlZCBpbi5cbiAgICAgICAgICAgICAgICAgKiBAbmFtZSBMaXN0LmZyb21cbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0xpc3RJdGVtW119IFtpdGVtc10gLSBUaGUgaXRlbXMgdG8gYXBwZW5kLlxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtsaXN0fSAtIEEgbmV3IGluc3RhbmNlIG9mIExpc3QuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgTGlzdC5mcm9tID0gZnVuY3Rpb24gKCBpdGVtcyApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpc3QgPSBuZXcgdGhpcygpLCBsZW5ndGgsIGl0ZXJhdG9yLCBpdGVtO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggaXRlbXMgJiYgKCBsZW5ndGggPSBpdGVtcy5sZW5ndGggKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZXJhdG9yID0gLTE7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICggKytpdGVyYXRvciA8IGxlbmd0aCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtID0gaXRlbXNbaXRlcmF0b3JdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBpdGVtICE9PSBudWxsICYmIGl0ZW0gIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlzdC5hcHBlbmQoIGl0ZW0gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGlzdDtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogTGlzdCNoZWFkXG4gICAgICAgICAgICAgICAgICogRGVmYXVsdCB0byBgbnVsbGAuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgTGlzdFByb3RvdHlwZS5oZWFkID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIExpc3QjdGFpbFxuICAgICAgICAgICAgICAgICAqIERlZmF1bHQgdG8gYG51bGxgLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIExpc3RQcm90b3R5cGUudGFpbCA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBSZXR1cm5zIHRoZSBsaXN0J3MgaXRlbXMgYXMgYW4gYXJyYXkuIFRoaXMgZG9lcyAqbm90KiBkZXRhY2ggdGhlIGl0ZW1zLlxuICAgICAgICAgICAgICAgICAqIEBuYW1lIExpc3QjdG9BcnJheVxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtMaXN0SXRlbVtdfSAtIEFuIGFycmF5IG9mIChzdGlsbCBhdHRhY2hlZCkgTGlzdEl0ZW1zLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIExpc3RQcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLmhlYWQsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIGl0ZW0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCggaXRlbSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbSA9IGl0ZW0ubmV4dDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFByZXBlbmRzIHRoZSBnaXZlbiBpdGVtIHRvIHRoZSBsaXN0OiBJdGVtIHdpbGwgYmUgdGhlIG5ldyBmaXJzdCBpdGVtXG4gICAgICAgICAgICAgICAgICogKGBoZWFkYCkuXG4gICAgICAgICAgICAgICAgICogQG5hbWUgTGlzdCNwcmVwZW5kXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtMaXN0SXRlbX0gaXRlbSAtIFRoZSBpdGVtIHRvIHByZXBlbmQuXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge0xpc3RJdGVtfSAtIEFuIGluc3RhbmNlIG9mIExpc3RJdGVtICh0aGUgZ2l2ZW4gaXRlbSkuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgTGlzdFByb3RvdHlwZS5wcmVwZW5kID0gZnVuY3Rpb24gKCBpdGVtICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoICFpdGVtICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhaXRlbS5hcHBlbmQgfHwgIWl0ZW0ucHJlcGVuZCB8fCAhaXRlbS5kZXRhY2ggKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIGVycm9yTWVzc2FnZSArICcjcHJlcGVuZGAuJyApO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGYsIGhlYWQ7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FjaGUgc2VsZi5cbiAgICAgICAgICAgICAgICAgICAgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgc2VsZiBoYXMgYSBmaXJzdCBpdGVtLCBkZWZlciBwcmVwZW5kIHRvIHRoZSBmaXJzdCBpdGVtcyBwcmVwZW5kXG4gICAgICAgICAgICAgICAgICAgIC8vIG1ldGhvZCwgYW5kIHJldHVybiB0aGUgcmVzdWx0LlxuICAgICAgICAgICAgICAgICAgICBoZWFkID0gc2VsZi5oZWFkO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggaGVhZCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBoZWFkLnByZXBlbmQoIGl0ZW0gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIC4uLm90aGVyd2lzZSwgdGhlcmUgaXMgbm8gYGhlYWRgIChvciBgdGFpbGApIGl0ZW0geWV0LlxuXG4gICAgICAgICAgICAgICAgICAgIC8vIERldGFjaCB0aGUgcHJlcGVuZGVlLlxuICAgICAgICAgICAgICAgICAgICBpdGVtLmRldGFjaCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFNldCB0aGUgcHJlcGVuZGVlcyBwYXJlbnQgbGlzdCB0byByZWZlcmVuY2Ugc2VsZi5cbiAgICAgICAgICAgICAgICAgICAgaXRlbS5saXN0ID0gc2VsZjtcblxuICAgICAgICAgICAgICAgICAgICAvLyBTZXQgc2VsZidzIGZpcnN0IGl0ZW0gdG8gdGhlIHByZXBlbmRlZSwgYW5kIHJldHVybiB0aGUgaXRlbS5cbiAgICAgICAgICAgICAgICAgICAgc2VsZi5oZWFkID0gaXRlbTtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQXBwZW5kcyB0aGUgZ2l2ZW4gaXRlbSB0byB0aGUgbGlzdDogSXRlbSB3aWxsIGJlIHRoZSBuZXcgbGFzdCBpdGVtIChgdGFpbGApXG4gICAgICAgICAgICAgICAgICogaWYgdGhlIGxpc3QgaGFkIGEgZmlyc3QgaXRlbSwgYW5kIGl0cyBmaXJzdCBpdGVtIChgaGVhZGApIG90aGVyd2lzZS5cbiAgICAgICAgICAgICAgICAgKiBAbmFtZSBMaXN0I2FwcGVuZFxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7TGlzdEl0ZW19IGl0ZW0gLSBUaGUgaXRlbSB0byBhcHBlbmQuXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge0xpc3RJdGVtfSAtIEFuIGluc3RhbmNlIG9mIExpc3RJdGVtICh0aGUgZ2l2ZW4gaXRlbSkuXG4gICAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgICAgICBMaXN0UHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uICggaXRlbSApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhaXRlbSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICggIWl0ZW0uYXBwZW5kIHx8ICFpdGVtLnByZXBlbmQgfHwgIWl0ZW0uZGV0YWNoICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCBlcnJvck1lc3NhZ2UgKyAnI2FwcGVuZGAuJyApO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGYsIGhlYWQsIHRhaWw7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FjaGUgc2VsZi5cbiAgICAgICAgICAgICAgICAgICAgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgc2VsZiBoYXMgYSBsYXN0IGl0ZW0sIGRlZmVyIGFwcGVuZGluZyB0byB0aGUgbGFzdCBpdGVtcyBhcHBlbmRcbiAgICAgICAgICAgICAgICAgICAgLy8gbWV0aG9kLCBhbmQgcmV0dXJuIHRoZSByZXN1bHQuXG4gICAgICAgICAgICAgICAgICAgIHRhaWwgPSBzZWxmLnRhaWw7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCB0YWlsICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhaWwuYXBwZW5kKCBpdGVtICk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBzZWxmIGhhcyBhIGZpcnN0IGl0ZW0sIGRlZmVyIGFwcGVuZGluZyB0byB0aGUgZmlyc3QgaXRlbXMgYXBwZW5kXG4gICAgICAgICAgICAgICAgICAgIC8vIG1ldGhvZCwgYW5kIHJldHVybiB0aGUgcmVzdWx0LlxuICAgICAgICAgICAgICAgICAgICBoZWFkID0gc2VsZi5oZWFkO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggaGVhZCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBoZWFkLmFwcGVuZCggaXRlbSApO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gLi4ub3RoZXJ3aXNlLCB0aGVyZSBpcyBubyBgdGFpbGAgb3IgYGhlYWRgIGl0ZW0geWV0LlxuXG4gICAgICAgICAgICAgICAgICAgIC8vIERldGFjaCB0aGUgYXBwZW5kZWUuXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uZGV0YWNoKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU2V0IHRoZSBhcHBlbmRlZXMgcGFyZW50IGxpc3QgdG8gcmVmZXJlbmNlIHNlbGYuXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0ubGlzdCA9IHNlbGY7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU2V0IHNlbGYncyBmaXJzdCBpdGVtIHRvIHRoZSBhcHBlbmRlZSwgYW5kIHJldHVybiB0aGUgaXRlbS5cbiAgICAgICAgICAgICAgICAgICAgc2VsZi5oZWFkID0gaXRlbTtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBMaXN0SXRlbTogQSBsaW5rZWQgbGlzdCBpdGVtIGlzIGEgYml0IGxpa2UgRE9NIG5vZGU6XG4gICAgICAgICAgICAgICAgICogSXQga25vd3Mgb25seSBhYm91dCBpdHMgXCJwYXJlbnRcIiAoYGxpc3RgKSwgdGhlIGl0ZW0gYmVmb3JlIGl0IChgcHJldmApLFxuICAgICAgICAgICAgICAgICAqIGFuZCB0aGUgaXRlbSBhZnRlciBpdCAoYG5leHRgKS5cbiAgICAgICAgICAgICAgICAgKiBAZ2xvYmFsXG4gICAgICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICAgICAgICAgKiBAY2xhc3MgUmVwcmVzZW50cyBhbiBpbnN0YW5jZSBvZiBMaXN0SXRlbS5cbiAgICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIExpc3RJdGVtKCkgeyB9XG5cbiAgICAgICAgICAgICAgICBMaXN0Lkl0ZW0gPSBMaXN0SXRlbTtcblxuICAgICAgICAgICAgICAgIHZhciBMaXN0SXRlbVByb3RvdHlwZSA9IExpc3RJdGVtLnByb3RvdHlwZTtcblxuICAgICAgICAgICAgICAgIExpc3RJdGVtUHJvdG90eXBlLm5leHQgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgTGlzdEl0ZW1Qcm90b3R5cGUucHJldiA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICBMaXN0SXRlbVByb3RvdHlwZS5saXN0ID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIERldGFjaGVzIHRoZSBpdGVtIG9wZXJhdGVkIG9uIGZyb20gaXRzIHBhcmVudCBsaXN0LlxuICAgICAgICAgICAgICAgICAqIEBuYW1lIExpc3RJdGVtI2RldGFjaFxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtMaXN0SXRlbX0gLSBUaGUgaXRlbSBvcGVyYXRlZCBvbi5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBMaXN0SXRlbVByb3RvdHlwZS5kZXRhY2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENhY2hlIHNlbGYsIHRoZSBwYXJlbnQgbGlzdCwgYW5kIHRoZSBwcmV2aW91cyBhbmQgbmV4dCBpdGVtcy5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdCA9IHNlbGYubGlzdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXYgPSBzZWxmLnByZXYsXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0ID0gc2VsZi5uZXh0O1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBpdGVtIGlzIGFscmVhZHkgZGV0YWNoZWQsIHJldHVybiBzZWxmLlxuICAgICAgICAgICAgICAgICAgICBpZiAoICFsaXN0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBzZWxmIGlzIHRoZSBsYXN0IGl0ZW0gaW4gdGhlIHBhcmVudCBsaXN0LCBsaW5rIHRoZSBsaXN0cyBsYXN0IGl0ZW1cbiAgICAgICAgICAgICAgICAgICAgLy8gdG8gdGhlIHByZXZpb3VzIGl0ZW0uXG4gICAgICAgICAgICAgICAgICAgIGlmICggbGlzdC50YWlsID09PSBzZWxmICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdC50YWlsID0gcHJldjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHNlbGYgaXMgdGhlIGZpcnN0IGl0ZW0gaW4gdGhlIHBhcmVudCBsaXN0LCBsaW5rIHRoZSBsaXN0cyBmaXJzdCBpdGVtXG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIHRoZSBuZXh0IGl0ZW0uXG4gICAgICAgICAgICAgICAgICAgIGlmICggbGlzdC5oZWFkID09PSBzZWxmICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdC5oZWFkID0gbmV4dDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGJvdGggdGhlIGxhc3QgYW5kIGZpcnN0IGl0ZW1zIGluIHRoZSBwYXJlbnQgbGlzdCBhcmUgdGhlIHNhbWUsXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSB0aGUgbGluayB0byB0aGUgbGFzdCBpdGVtLlxuICAgICAgICAgICAgICAgICAgICBpZiAoIGxpc3QudGFpbCA9PT0gbGlzdC5oZWFkICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdC50YWlsID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGEgcHJldmlvdXMgaXRlbSBleGlzdHMsIGxpbmsgaXRzIG5leHQgaXRlbSB0byBzZWxmcyBuZXh0IGl0ZW0uXG4gICAgICAgICAgICAgICAgICAgIGlmICggcHJldiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXYubmV4dCA9IG5leHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBhIG5leHQgaXRlbSBleGlzdHMsIGxpbmsgaXRzIHByZXZpb3VzIGl0ZW0gdG8gc2VsZnMgcHJldmlvdXMgaXRlbS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBuZXh0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dC5wcmV2ID0gcHJldjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBsaW5rcyBmcm9tIHNlbGYgdG8gYm90aCB0aGUgbmV4dCBhbmQgcHJldmlvdXMgaXRlbXMsIGFuZCB0byB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gcGFyZW50IGxpc3QuXG4gICAgICAgICAgICAgICAgICAgIHNlbGYucHJldiA9IHNlbGYubmV4dCA9IHNlbGYubGlzdCA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmV0dXJuIHNlbGYuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBQcmVwZW5kcyB0aGUgZ2l2ZW4gaXRlbSAqYmVmb3JlKiB0aGUgaXRlbSBvcGVyYXRlZCBvbi5cbiAgICAgICAgICAgICAgICAgKiBAbmFtZSBMaXN0SXRlbSNwcmVwZW5kXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtMaXN0SXRlbX0gaXRlbSAtIFRoZSBpdGVtIHRvIHByZXBlbmQuXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge0xpc3RJdGVtfSAtIFRoZSBpdGVtIG9wZXJhdGVkIG9uLCBvciBmYWxzZSB3aGVuIHRoYXQgaXRlbSBpcyBub3RcbiAgICAgICAgICAgICAgICAgKiBhdHRhY2hlZC5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBMaXN0SXRlbVByb3RvdHlwZS5wcmVwZW5kID0gZnVuY3Rpb24gKCBpdGVtICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoICFpdGVtIHx8ICFpdGVtLmFwcGVuZCB8fCAhaXRlbS5wcmVwZW5kIHx8ICFpdGVtLmRldGFjaCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvciggZXJyb3JNZXNzYWdlICsgJ0l0ZW0jcHJlcGVuZGAuJyApO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FjaGUgc2VsZiwgdGhlIHBhcmVudCBsaXN0LCBhbmQgdGhlIHByZXZpb3VzIGl0ZW0uXG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3QgPSBzZWxmLmxpc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2ID0gc2VsZi5wcmV2O1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHNlbGYgaXMgZGV0YWNoZWQsIHJldHVybiBmYWxzZS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhbGlzdCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIERldGFjaCB0aGUgcHJlcGVuZGVlLlxuICAgICAgICAgICAgICAgICAgICBpdGVtLmRldGFjaCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHNlbGYgaGFzIGEgcHJldmlvdXMgaXRlbS4uLlxuICAgICAgICAgICAgICAgICAgICBpZiAoIHByZXYgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAuLi5saW5rIHRoZSBwcmVwZW5kZWVzIHByZXZpb3VzIGl0ZW0sIHRvIHNlbGZzIHByZXZpb3VzIGl0ZW0uXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnByZXYgPSBwcmV2O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAuLi5saW5rIHRoZSBwcmV2aW91cyBpdGVtcyBuZXh0IGl0ZW0sIHRvIHNlbGYuXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2Lm5leHQgPSBpdGVtO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU2V0IHRoZSBwcmVwZW5kZWVzIG5leHQgaXRlbSB0byBzZWxmLlxuICAgICAgICAgICAgICAgICAgICBpdGVtLm5leHQgPSBzZWxmO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFNldCB0aGUgcHJlcGVuZGVlcyBwYXJlbnQgbGlzdCB0byBzZWxmcyBwYXJlbnQgbGlzdC5cbiAgICAgICAgICAgICAgICAgICAgaXRlbS5saXN0ID0gbGlzdDtcblxuICAgICAgICAgICAgICAgICAgICAvLyBTZXQgdGhlIHByZXZpb3VzIGl0ZW0gb2Ygc2VsZiB0byB0aGUgcHJlcGVuZGVlLlxuICAgICAgICAgICAgICAgICAgICBzZWxmLnByZXYgPSBpdGVtO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHNlbGYgaXMgdGhlIGZpcnN0IGl0ZW0gaW4gdGhlIHBhcmVudCBsaXN0LCBsaW5rIHRoZSBsaXN0cyBmaXJzdCBpdGVtXG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIHRoZSBwcmVwZW5kZWUuXG4gICAgICAgICAgICAgICAgICAgIGlmICggc2VsZiA9PT0gbGlzdC5oZWFkICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdC5oZWFkID0gaXRlbTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSB0aGUgcGFyZW50IGxpc3QgaGFzIG5vIGxhc3QgaXRlbSwgbGluayB0aGUgbGlzdHMgbGFzdCBpdGVtIHRvXG4gICAgICAgICAgICAgICAgICAgIC8vIHNlbGYuXG4gICAgICAgICAgICAgICAgICAgIGlmICggIWxpc3QudGFpbCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3QudGFpbCA9IHNlbGY7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBSZXR1cm4gdGhlIHByZXBlbmRlZS5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEFwcGVuZHMgdGhlIGdpdmVuIGl0ZW0gKmFmdGVyKiB0aGUgaXRlbSBvcGVyYXRlZCBvbi5cbiAgICAgICAgICAgICAgICAgKiBAbmFtZSBMaXN0SXRlbSNhcHBlbmRcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0xpc3RJdGVtfSBpdGVtIC0gVGhlIGl0ZW0gdG8gYXBwZW5kLlxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtMaXN0SXRlbX0gLSBUaGUgaXRlbSBvcGVyYXRlZCBvbiwgb3IgZmFsc2Ugd2hlbiB0aGF0IGl0ZW0gaXMgbm90XG4gICAgICAgICAgICAgICAgICogYXR0YWNoZWQuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgTGlzdEl0ZW1Qcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24gKCBpdGVtICkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBpdGVtIGlzIGZhbHNleSwgcmV0dXJuIGZhbHNlLlxuICAgICAgICAgICAgICAgICAgICBpZiAoICFpdGVtIHx8ICFpdGVtLmFwcGVuZCB8fCAhaXRlbS5wcmVwZW5kIHx8ICFpdGVtLmRldGFjaCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvciggZXJyb3JNZXNzYWdlICsgJ0l0ZW0jYXBwZW5kYC4nICk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBDYWNoZSBzZWxmLCB0aGUgcGFyZW50IGxpc3QsIGFuZCB0aGUgbmV4dCBpdGVtLlxuICAgICAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0ID0gc2VsZi5saXN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IHNlbGYubmV4dDtcblxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBzZWxmIGlzIGRldGFjaGVkLCByZXR1cm4gZmFsc2UuXG4gICAgICAgICAgICAgICAgICAgIGlmICggIWxpc3QgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBEZXRhY2ggdGhlIGFwcGVuZGVlLlxuICAgICAgICAgICAgICAgICAgICBpdGVtLmRldGFjaCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHNlbGYgaGFzIGEgbmV4dCBpdGVtLi4uXG4gICAgICAgICAgICAgICAgICAgIGlmICggbmV4dCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIC4uLmxpbmsgdGhlIGFwcGVuZGVlcyBuZXh0IGl0ZW0sIHRvIHNlbGZzIG5leHQgaXRlbS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0ubmV4dCA9IG5leHQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIC4uLmxpbmsgdGhlIG5leHQgaXRlbXMgcHJldmlvdXMgaXRlbSwgdG8gdGhlIGFwcGVuZGVlLlxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dC5wcmV2ID0gaXRlbTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFNldCB0aGUgYXBwZW5kZWVzIHByZXZpb3VzIGl0ZW0gdG8gc2VsZi5cbiAgICAgICAgICAgICAgICAgICAgaXRlbS5wcmV2ID0gc2VsZjtcblxuICAgICAgICAgICAgICAgICAgICAvLyBTZXQgdGhlIGFwcGVuZGVlcyBwYXJlbnQgbGlzdCB0byBzZWxmcyBwYXJlbnQgbGlzdC5cbiAgICAgICAgICAgICAgICAgICAgaXRlbS5saXN0ID0gbGlzdDtcblxuICAgICAgICAgICAgICAgICAgICAvLyBTZXQgdGhlIG5leHQgaXRlbSBvZiBzZWxmIHRvIHRoZSBhcHBlbmRlZS5cbiAgICAgICAgICAgICAgICAgICAgc2VsZi5uZXh0ID0gaXRlbTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgdGhlIHBhcmVudCBsaXN0IGhhcyBubyBsYXN0IGl0ZW0gb3IgaWYgc2VsZiBpcyB0aGUgcGFyZW50IGxpc3RzXG4gICAgICAgICAgICAgICAgICAgIC8vIGxhc3QgaXRlbSwgbGluayB0aGUgbGlzdHMgbGFzdCBpdGVtIHRvIHRoZSBhcHBlbmRlZS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBzZWxmID09PSBsaXN0LnRhaWwgfHwgIWxpc3QudGFpbCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3QudGFpbCA9IGl0ZW07XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBSZXR1cm4gdGhlIGFwcGVuZGVlLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogRXhwb3NlIGBMaXN0YC5cbiAgICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gTGlzdDtcblxuXG4gICAgICAgICAgICAgICAgLyoqKi9cbn0sXG4vKiA2OCAqL1xuLyoqKi8gZnVuY3Rpb24gKCBtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18gKSB7XG5cbiAgICAgICAgICAgICAgICAndXNlIHN0cmljdCc7XG5cbiAgICAgICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oIDY3ICk7XG5cblxuICAgICAgICAgICAgICAgIC8qKiovXG59LFxuLyogNjkgKi9cbi8qKiovIGZ1bmN0aW9uICggbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGdldE5hdGl2ZSA9IF9fd2VicGFja19yZXF1aXJlX18oIDIgKSxcbiAgICAgICAgICAgICAgICAgICAgcm9vdCA9IF9fd2VicGFja19yZXF1aXJlX18oIDEgKTtcblxuICAgICAgICAgICAgICAgIC8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbiAgICAgICAgICAgICAgICB2YXIgRGF0YVZpZXcgPSBnZXROYXRpdmUoIHJvb3QsICdEYXRhVmlldycgKTtcblxuICAgICAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gRGF0YVZpZXc7XG5cblxuICAgICAgICAgICAgICAgIC8qKiovXG59LFxuLyogNzAgKi9cbi8qKiovIGZ1bmN0aW9uICggbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGhhc2hDbGVhciA9IF9fd2VicGFja19yZXF1aXJlX18oIDExMiApLFxuICAgICAgICAgICAgICAgICAgICBoYXNoRGVsZXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXyggMTEzICksXG4gICAgICAgICAgICAgICAgICAgIGhhc2hHZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCAxMTQgKSxcbiAgICAgICAgICAgICAgICAgICAgaGFzaEhhcyA9IF9fd2VicGFja19yZXF1aXJlX18oIDExNSApLFxuICAgICAgICAgICAgICAgICAgICBoYXNoU2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyggMTE2ICk7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBDcmVhdGVzIGEgaGFzaCBvYmplY3QuXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIEhhc2goIGVudHJpZXMgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gZW50cmllcyA/IGVudHJpZXMubGVuZ3RoIDogMDtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICggKytpbmRleCA8IGxlbmd0aCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXQoIGVudHJ5WzBdLCBlbnRyeVsxXSApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuICAgICAgICAgICAgICAgIEhhc2gucHJvdG90eXBlLmNsZWFyID0gaGFzaENsZWFyO1xuICAgICAgICAgICAgICAgIEhhc2gucHJvdG90eXBlWydkZWxldGUnXSA9IGhhc2hEZWxldGU7XG4gICAgICAgICAgICAgICAgSGFzaC5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcbiAgICAgICAgICAgICAgICBIYXNoLnByb3RvdHlwZS5oYXMgPSBoYXNoSGFzO1xuICAgICAgICAgICAgICAgIEhhc2gucHJvdG90eXBlLnNldCA9IGhhc2hTZXQ7XG5cbiAgICAgICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IEhhc2g7XG5cblxuICAgICAgICAgICAgICAgIC8qKiovXG59LFxuLyogNzEgKi9cbi8qKiovIGZ1bmN0aW9uICggbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGdldE5hdGl2ZSA9IF9fd2VicGFja19yZXF1aXJlX18oIDIgKSxcbiAgICAgICAgICAgICAgICAgICAgcm9vdCA9IF9fd2VicGFja19yZXF1aXJlX18oIDEgKTtcblxuICAgICAgICAgICAgICAgIC8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbiAgICAgICAgICAgICAgICB2YXIgUHJvbWlzZSA9IGdldE5hdGl2ZSggcm9vdCwgJ1Byb21pc2UnICk7XG5cbiAgICAgICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IFByb21pc2U7XG5cblxuICAgICAgICAgICAgICAgIC8qKiovXG59LFxuLyogNzIgKi9cbi8qKiovIGZ1bmN0aW9uICggbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIHJvb3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCAxICk7XG5cbiAgICAgICAgICAgICAgICAvKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbiAgICAgICAgICAgICAgICB2YXIgVWludDhBcnJheSA9IHJvb3QuVWludDhBcnJheTtcblxuICAgICAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gVWludDhBcnJheTtcblxuXG4gICAgICAgICAgICAgICAgLyoqKi9cbn0sXG4vKiA3MyAqL1xuLyoqKi8gZnVuY3Rpb24gKCBtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18gKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgZ2V0TmF0aXZlID0gX193ZWJwYWNrX3JlcXVpcmVfXyggMiApLFxuICAgICAgICAgICAgICAgICAgICByb290ID0gX193ZWJwYWNrX3JlcXVpcmVfXyggMSApO1xuXG4gICAgICAgICAgICAgICAgLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xuICAgICAgICAgICAgICAgIHZhciBXZWFrTWFwID0gZ2V0TmF0aXZlKCByb290LCAnV2Vha01hcCcgKTtcblxuICAgICAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gV2Vha01hcDtcblxuXG4gICAgICAgICAgICAgICAgLyoqKi9cbn0sXG4vKiA3NCAqL1xuLyoqKi8gZnVuY3Rpb24gKCBtb2R1bGUsIGV4cG9ydHMgKSB7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBBIGZhc3RlciBhbHRlcm5hdGl2ZSB0byBgRnVuY3Rpb24jYXBwbHlgLCB0aGlzIGZ1bmN0aW9uIGludm9rZXMgYGZ1bmNgXG4gICAgICAgICAgICAgICAgICogd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgYHRoaXNBcmdgIGFuZCB0aGUgYXJndW1lbnRzIG9mIGBhcmdzYC5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gYXBwbHkoIGZ1bmMsIHRoaXNBcmcsIGFyZ3MgKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoIGFyZ3MubGVuZ3RoICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gZnVuYy5jYWxsKCB0aGlzQXJnICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBmdW5jLmNhbGwoIHRoaXNBcmcsIGFyZ3NbMF0gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIGZ1bmMuY2FsbCggdGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gZnVuYy5jYWxsKCB0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkoIHRoaXNBcmcsIGFyZ3MgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGFwcGx5O1xuXG5cbiAgICAgICAgICAgICAgICAvKioqL1xufSxcbi8qIDc1ICovXG4vKioqLyBmdW5jdGlvbiAoIG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyApIHtcblxuICAgICAgICAgICAgICAgIHZhciBiYXNlVGltZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCA5OSApLFxuICAgICAgICAgICAgICAgICAgICBpc0FyZ3VtZW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oIDIwICksXG4gICAgICAgICAgICAgICAgICAgIGlzQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCAzICksXG4gICAgICAgICAgICAgICAgICAgIGlzSW5kZXggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCA0MCApO1xuXG4gICAgICAgICAgICAgICAgLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xuICAgICAgICAgICAgICAgIHZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbiAgICAgICAgICAgICAgICAvKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbiAgICAgICAgICAgICAgICB2YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgdGhlIGFycmF5LWxpa2UgYHZhbHVlYC5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyggdmFsdWUsIGluaGVyaXRlZCApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2FmYXJpIDguMSBtYWtlcyBgYXJndW1lbnRzLmNhbGxlZWAgZW51bWVyYWJsZSBpbiBzdHJpY3QgbW9kZS5cbiAgICAgICAgICAgICAgICAgICAgLy8gU2FmYXJpIDkgbWFrZXMgYGFyZ3VtZW50cy5sZW5ndGhgIGVudW1lcmFibGUgaW4gc3RyaWN0IG1vZGUuXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSAoIGlzQXJyYXkoIHZhbHVlICkgfHwgaXNBcmd1bWVudHMoIHZhbHVlICkgKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBiYXNlVGltZXMoIHZhbHVlLmxlbmd0aCwgU3RyaW5nIClcbiAgICAgICAgICAgICAgICAgICAgICAgIDogW107XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBza2lwSW5kZXhlcyA9ICEhbGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIHZhciBrZXkgaW4gdmFsdWUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoICggaW5oZXJpdGVkIHx8IGhhc093blByb3BlcnR5LmNhbGwoIHZhbHVlLCBrZXkgKSApICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgISggc2tpcEluZGV4ZXMgJiYgKCBrZXkgPT0gJ2xlbmd0aCcgfHwgaXNJbmRleCgga2V5LCBsZW5ndGggKSApICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goIGtleSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBhcnJheUxpa2VLZXlzO1xuXG5cbiAgICAgICAgICAgICAgICAvKioqL1xufSxcbi8qIDc2ICovXG4vKioqLyBmdW5jdGlvbiAoIG1vZHVsZSwgZXhwb3J0cyApIHtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tYXBgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICAgICAgICAgICAgICAgICAqIHNob3J0aGFuZHMuXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBhcnJheU1hcCggYXJyYXksIGl0ZXJhdGVlICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IEFycmF5KCBsZW5ndGggKTtcblxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoICsraW5kZXggPCBsZW5ndGggKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoIGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5ICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGFycmF5TWFwO1xuXG5cbiAgICAgICAgICAgICAgICAvKioqL1xufSxcbi8qIDc3ICovXG4vKioqLyBmdW5jdGlvbiAoIG1vZHVsZSwgZXhwb3J0cyApIHtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEFwcGVuZHMgdGhlIGVsZW1lbnRzIG9mIGB2YWx1ZXNgIHRvIGBhcnJheWAuXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gYXBwZW5kLlxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGFycmF5UHVzaCggYXJyYXksIHZhbHVlcyApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICggKytpbmRleCA8IGxlbmd0aCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5W29mZnNldCArIGluZGV4XSA9IHZhbHVlc1tpbmRleF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gYXJyYXlQdXNoO1xuXG5cbiAgICAgICAgICAgICAgICAvKioqL1xufSxcbi8qIDc4ICovXG4vKioqLyBmdW5jdGlvbiAoIG1vZHVsZSwgZXhwb3J0cyApIHtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zb21lYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAgICAgICAgICAgICAgICAgKiBzaG9ydGhhbmRzLlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICAgICAgICAgICAgICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gYXJyYXlTb21lKCBhcnJheSwgcHJlZGljYXRlICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcblxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoICsraW5kZXggPCBsZW5ndGggKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHByZWRpY2F0ZSggYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBhcnJheVNvbWU7XG5cblxuICAgICAgICAgICAgICAgIC8qKiovXG59LFxuLyogNzkgKi9cbi8qKiovIGZ1bmN0aW9uICggbW9kdWxlLCBleHBvcnRzICkge1xuXG4gICAgICAgICAgICAgICAgLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG4gICAgICAgICAgICAgICAgdmFyIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGFzc2lnblZhbHVlYCBhbmQgYGFzc2lnbk1lcmdlVmFsdWVgIHdpdGhvdXRcbiAgICAgICAgICAgICAgICAgKiB2YWx1ZSBjaGVja3MuXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGJhc2VBc3NpZ25WYWx1ZSggb2JqZWN0LCBrZXksIHZhbHVlICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIGtleSA9PSAnX19wcm90b19fJyAmJiBkZWZpbmVQcm9wZXJ0eSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmluZVByb3BlcnR5KCBvYmplY3QsIGtleSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdlbnVtZXJhYmxlJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAndmFsdWUnOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnd3JpdGFibGUnOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9ICk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBiYXNlQXNzaWduVmFsdWU7XG5cblxuICAgICAgICAgICAgICAgIC8qKiovXG59LFxuLyogODAgKi9cbi8qKiovIGZ1bmN0aW9uICggbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIFNldENhY2hlID0gX193ZWJwYWNrX3JlcXVpcmVfXyggMTUgKSxcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlJbmNsdWRlcyA9IF9fd2VicGFja19yZXF1aXJlX18oIDMwICksXG4gICAgICAgICAgICAgICAgICAgIGFycmF5SW5jbHVkZXNXaXRoID0gX193ZWJwYWNrX3JlcXVpcmVfXyggMzEgKSxcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlNYXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCA3NiApLFxuICAgICAgICAgICAgICAgICAgICBiYXNlVW5hcnkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCAzNiApLFxuICAgICAgICAgICAgICAgICAgICBjYWNoZUhhcyA9IF9fd2VicGFja19yZXF1aXJlX18oIDE3ICk7XG5cbiAgICAgICAgICAgICAgICAvKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbiAgICAgICAgICAgICAgICB2YXIgTEFSR0VfQVJSQVlfU0laRSA9IDIwMDtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIG1ldGhvZHMgbGlrZSBgXy5kaWZmZXJlbmNlYCB3aXRob3V0IHN1cHBvcnRcbiAgICAgICAgICAgICAgICAgKiBmb3IgZXhjbHVkaW5nIG11bHRpcGxlIGFycmF5cyBvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBleGNsdWRlLlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGJhc2VEaWZmZXJlbmNlKCBhcnJheSwgdmFsdWVzLCBpdGVyYXRlZSwgY29tcGFyYXRvciApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNsdWRlcyA9IGFycmF5SW5jbHVkZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0NvbW1vbiA9IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlc0xlbmd0aCA9IHZhbHVlcy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhbGVuZ3RoICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIGl0ZXJhdGVlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzID0gYXJyYXlNYXAoIHZhbHVlcywgYmFzZVVuYXJ5KCBpdGVyYXRlZSApICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBjb21wYXJhdG9yICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVkZXMgPSBhcnJheUluY2x1ZGVzV2l0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIHZhbHVlcy5sZW5ndGggPj0gTEFSR0VfQVJSQVlfU0laRSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1ZGVzID0gY2FjaGVIYXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzID0gbmV3IFNldENhY2hlKCB2YWx1ZXMgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvdXRlcjpcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCArK2luZGV4IDwgbGVuZ3RoICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPyBpdGVyYXRlZSggdmFsdWUgKSA6IHZhbHVlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9ICggY29tcGFyYXRvciB8fCB2YWx1ZSAhPT0gMCApID8gdmFsdWUgOiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBpc0NvbW1vbiAmJiBjb21wdXRlZCA9PT0gY29tcHV0ZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlc0luZGV4ID0gdmFsdWVzTGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICggdmFsdWVzSW5kZXgtLSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB2YWx1ZXNbdmFsdWVzSW5kZXhdID09PSBjb21wdXRlZCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCB2YWx1ZSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoICFpbmNsdWRlcyggdmFsdWVzLCBjb21wdXRlZCwgY29tcGFyYXRvciApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCB2YWx1ZSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBiYXNlRGlmZmVyZW5jZTtcblxuXG4gICAgICAgICAgICAgICAgLyoqKi9cbn0sXG4vKiA4MSAqL1xuLyoqKi8gZnVuY3Rpb24gKCBtb2R1bGUsIGV4cG9ydHMgKSB7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5maW5kSW5kZXhgIGFuZCBgXy5maW5kTGFzdEluZGV4YCB3aXRob3V0XG4gICAgICAgICAgICAgICAgICogc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBiYXNlRmluZEluZGV4KCBhcnJheSwgcHJlZGljYXRlLCBmcm9tSW5kZXgsIGZyb21SaWdodCApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gZnJvbUluZGV4ICsgKCBmcm9tUmlnaHQgPyAxIDogLTEgKTtcblxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoICggZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGggKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggcHJlZGljYXRlKCBhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBiYXNlRmluZEluZGV4O1xuXG5cbiAgICAgICAgICAgICAgICAvKioqL1xufSxcbi8qIDgyICovXG4vKioqLyBmdW5jdGlvbiAoIG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyApIHtcblxuICAgICAgICAgICAgICAgIHZhciBjcmVhdGVCYXNlRm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyggMTAzICk7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYmFzZUZvck93bmAgd2hpY2ggaXRlcmF0ZXMgb3ZlciBgb2JqZWN0YFxuICAgICAgICAgICAgICAgICAqIHByb3BlcnRpZXMgcmV0dXJuZWQgYnkgYGtleXNGdW5jYCBhbmQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgICAqIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB2YXIgYmFzZUZvciA9IGNyZWF0ZUJhc2VGb3IoKTtcblxuICAgICAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gYmFzZUZvcjtcblxuXG4gICAgICAgICAgICAgICAgLyoqKi9cbn0sXG4vKiA4MyAqL1xuLyoqKi8gZnVuY3Rpb24gKCBtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18gKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgYmFzZUZvciA9IF9fd2VicGFja19yZXF1aXJlX18oIDgyICksXG4gICAgICAgICAgICAgICAgICAgIGtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCAyNCApO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yT3duYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGJhc2VGb3JPd24oIG9iamVjdCwgaXRlcmF0ZWUgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3QgJiYgYmFzZUZvciggb2JqZWN0LCBpdGVyYXRlZSwga2V5cyApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gYmFzZUZvck93bjtcblxuXG4gICAgICAgICAgICAgICAgLyoqKi9cbn0sXG4vKiA4NCAqL1xuLyoqKi8gZnVuY3Rpb24gKCBtb2R1bGUsIGV4cG9ydHMgKSB7XG5cbiAgICAgICAgICAgICAgICAvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG4gICAgICAgICAgICAgICAgdmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAgICAgICAgICAgICAgICAgKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAgICAgICAgICAgICAgICAgKiBvZiB2YWx1ZXMuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdmFyIG9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYC5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBiYXNlR2V0VGFnKCB2YWx1ZSApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdFRvU3RyaW5nLmNhbGwoIHZhbHVlICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBiYXNlR2V0VGFnO1xuXG5cbiAgICAgICAgICAgICAgICAvKioqL1xufSxcbi8qIDg1ICovXG4vKioqLyBmdW5jdGlvbiAoIG1vZHVsZSwgZXhwb3J0cyApIHtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmhhc0luYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBrZXkgVGhlIGtleSB0byBjaGVjay5cbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gYmFzZUhhc0luKCBvYmplY3QsIGtleSApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGtleSBpbiBPYmplY3QoIG9iamVjdCApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gYmFzZUhhc0luO1xuXG5cbiAgICAgICAgICAgICAgICAvKioqL1xufSxcbi8qIDg2ICovXG4vKioqLyBmdW5jdGlvbiAoIG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyApIHtcblxuICAgICAgICAgICAgICAgIHZhciBiYXNlRmluZEluZGV4ID0gX193ZWJwYWNrX3JlcXVpcmVfXyggODEgKSxcbiAgICAgICAgICAgICAgICAgICAgYmFzZUlzTmFOID0gX193ZWJwYWNrX3JlcXVpcmVfXyggODkgKSxcbiAgICAgICAgICAgICAgICAgICAgc3RyaWN0SW5kZXhPZiA9IF9fd2VicGFja19yZXF1aXJlX18oIDE0NiApO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaW5kZXhPZmAgd2l0aG91dCBgZnJvbUluZGV4YCBib3VuZHMgY2hlY2tzLlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gYmFzZUluZGV4T2YoIGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4ICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgPT09IHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHN0cmljdEluZGV4T2YoIGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4IClcbiAgICAgICAgICAgICAgICAgICAgICAgIDogYmFzZUZpbmRJbmRleCggYXJyYXksIGJhc2VJc05hTiwgZnJvbUluZGV4ICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBiYXNlSW5kZXhPZjtcblxuXG4gICAgICAgICAgICAgICAgLyoqKi9cbn0sXG4vKiA4NyAqL1xuLyoqKi8gZnVuY3Rpb24gKCBtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18gKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgU3RhY2sgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCAyOSApLFxuICAgICAgICAgICAgICAgICAgICBlcXVhbEFycmF5cyA9IF9fd2VicGFja19yZXF1aXJlX18oIDM4ICksXG4gICAgICAgICAgICAgICAgICAgIGVxdWFsQnlUYWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCAxMDUgKSxcbiAgICAgICAgICAgICAgICAgICAgZXF1YWxPYmplY3RzID0gX193ZWJwYWNrX3JlcXVpcmVfXyggMTA2ICksXG4gICAgICAgICAgICAgICAgICAgIGdldFRhZyA9IF9fd2VicGFja19yZXF1aXJlX18oIDEwOSApLFxuICAgICAgICAgICAgICAgICAgICBpc0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyggMyApLFxuICAgICAgICAgICAgICAgICAgICBpc1R5cGVkQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCAxNTMgKTtcblxuICAgICAgICAgICAgICAgIC8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIGNvbXBhcmlzb24gc3R5bGVzLiAqL1xuICAgICAgICAgICAgICAgIHZhciBQQVJUSUFMX0NPTVBBUkVfRkxBRyA9IDI7XG5cbiAgICAgICAgICAgICAgICAvKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG4gICAgICAgICAgICAgICAgdmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgICAgICAgICAgICAgICAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJztcblxuICAgICAgICAgICAgICAgIC8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbiAgICAgICAgICAgICAgICB2YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4gICAgICAgICAgICAgICAgLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG4gICAgICAgICAgICAgICAgdmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gICAgICAgICAgICAgICAgICogZGVlcCBjb21wYXJpc29ucyBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGVuYWJsaW5nIG9iamVjdHMgd2l0aCBjaXJjdWxhclxuICAgICAgICAgICAgICAgICAqIHJlZmVyZW5jZXMgdG8gYmUgY29tcGFyZWQuXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYml0bWFza10gVGhlIGJpdG1hc2sgb2YgY29tcGFyaXNvbiBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGBcbiAgICAgICAgICAgICAgICAgKiAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gYmFzZUlzRXF1YWxEZWVwKCBvYmplY3QsIG90aGVyLCBlcXVhbEZ1bmMsIGN1c3RvbWl6ZXIsIGJpdG1hc2ssIHN0YWNrICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb2JqSXNBcnIgPSBpc0FycmF5KCBvYmplY3QgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG90aElzQXJyID0gaXNBcnJheSggb3RoZXIgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ialRhZyA9IGFycmF5VGFnLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3RoVGFnID0gYXJyYXlUYWc7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhb2JqSXNBcnIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmpUYWcgPSBnZXRUYWcoIG9iamVjdCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqVGFnID0gb2JqVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvYmpUYWc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhb3RoSXNBcnIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdGhUYWcgPSBnZXRUYWcoIG90aGVyICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdGhUYWcgPSBvdGhUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG90aFRhZztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgb2JqSXNPYmogPSBvYmpUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3RoSXNPYmogPSBvdGhUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNTYW1lVGFnID0gb2JqVGFnID09IG90aFRhZztcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIGlzU2FtZVRhZyAmJiAhb2JqSXNPYmogKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFjayB8fCAoIHN0YWNrID0gbmV3IFN0YWNrICk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCBvYmpJc0FyciB8fCBpc1R5cGVkQXJyYXkoIG9iamVjdCApIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGVxdWFsQXJyYXlzKCBvYmplY3QsIG90aGVyLCBlcXVhbEZ1bmMsIGN1c3RvbWl6ZXIsIGJpdG1hc2ssIHN0YWNrIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGVxdWFsQnlUYWcoIG9iamVjdCwgb3RoZXIsIG9ialRhZywgZXF1YWxGdW5jLCBjdXN0b21pemVyLCBiaXRtYXNrLCBzdGFjayApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICggISggYml0bWFzayAmIFBBUlRJQUxfQ09NUEFSRV9GTEFHICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2JqSXNXcmFwcGVkID0gb2JqSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbCggb2JqZWN0LCAnX193cmFwcGVkX18nICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3RoSXNXcmFwcGVkID0gb3RoSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbCggb3RoZXIsICdfX3dyYXBwZWRfXycgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBvYmpJc1dyYXBwZWQgfHwgb3RoSXNXcmFwcGVkICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvYmpVbndyYXBwZWQgPSBvYmpJc1dyYXBwZWQgPyBvYmplY3QudmFsdWUoKSA6IG9iamVjdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3RoVW53cmFwcGVkID0gb3RoSXNXcmFwcGVkID8gb3RoZXIudmFsdWUoKSA6IG90aGVyO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2sgfHwgKCBzdGFjayA9IG5ldyBTdGFjayApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcXVhbEZ1bmMoIG9ialVud3JhcHBlZCwgb3RoVW53cmFwcGVkLCBjdXN0b21pemVyLCBiaXRtYXNrLCBzdGFjayApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICggIWlzU2FtZVRhZyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdGFjayB8fCAoIHN0YWNrID0gbmV3IFN0YWNrICk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlcXVhbE9iamVjdHMoIG9iamVjdCwgb3RoZXIsIGVxdWFsRnVuYywgY3VzdG9taXplciwgYml0bWFzaywgc3RhY2sgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGJhc2VJc0VxdWFsRGVlcDtcblxuXG4gICAgICAgICAgICAgICAgLyoqKi9cbn0sXG4vKiA4OCAqL1xuLyoqKi8gZnVuY3Rpb24gKCBtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18gKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgU3RhY2sgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCAyOSApLFxuICAgICAgICAgICAgICAgICAgICBiYXNlSXNFcXVhbCA9IF9fd2VicGFja19yZXF1aXJlX18oIDM0ICk7XG5cbiAgICAgICAgICAgICAgICAvKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBjb21wYXJpc29uIHN0eWxlcy4gKi9cbiAgICAgICAgICAgICAgICB2YXIgVU5PUkRFUkVEX0NPTVBBUkVfRkxBRyA9IDEsXG4gICAgICAgICAgICAgICAgICAgIFBBUlRJQUxfQ09NUEFSRV9GTEFHID0gMjtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTWF0Y2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBtYXRjaERhdGEgVGhlIHByb3BlcnR5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIHRvIG1hdGNoLlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgb2JqZWN0YCBpcyBhIG1hdGNoLCBlbHNlIGBmYWxzZWAuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gYmFzZUlzTWF0Y2goIG9iamVjdCwgc291cmNlLCBtYXRjaERhdGEsIGN1c3RvbWl6ZXIgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IG1hdGNoRGF0YS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vQ3VzdG9taXplciA9ICFjdXN0b21pemVyO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggb2JqZWN0ID09IG51bGwgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QgPSBPYmplY3QoIG9iamVjdCApO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIGluZGV4LS0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoICggbm9DdXN0b21pemVyICYmIGRhdGFbMl0gKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gZGF0YVsxXSAhPT0gb2JqZWN0W2RhdGFbMF1dXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAhKCBkYXRhWzBdIGluIG9iamVjdCApXG4gICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCArK2luZGV4IDwgbGVuZ3RoICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gZGF0YVswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNyY1ZhbHVlID0gZGF0YVsxXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgISgga2V5IGluIG9iamVjdCApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RhY2sgPSBuZXcgU3RhY2s7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBjdXN0b21pemVyICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gY3VzdG9taXplciggb2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlLCBzdGFjayApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoICEoIHJlc3VsdCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gYmFzZUlzRXF1YWwoIHNyY1ZhbHVlLCBvYmpWYWx1ZSwgY3VzdG9taXplciwgVU5PUkRFUkVEX0NPTVBBUkVfRkxBRyB8IFBBUlRJQUxfQ09NUEFSRV9GTEFHLCBzdGFjayApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGJhc2VJc01hdGNoO1xuXG5cbiAgICAgICAgICAgICAgICAvKioqL1xufSxcbi8qIDg5ICovXG4vKioqLyBmdW5jdGlvbiAoIG1vZHVsZSwgZXhwb3J0cyApIHtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmFOYCB3aXRob3V0IHN1cHBvcnQgZm9yIG51bWJlciBvYmplY3RzLlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBgTmFOYCwgZWxzZSBgZmFsc2VgLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGJhc2VJc05hTiggdmFsdWUgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNOYU47XG5cblxuICAgICAgICAgICAgICAgIC8qKiovXG59LFxuLyogOTAgKi9cbi8qKiovIGZ1bmN0aW9uICggbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGlzRnVuY3Rpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCA0NyApLFxuICAgICAgICAgICAgICAgICAgICBpc01hc2tlZCA9IF9fd2VicGFja19yZXF1aXJlX18oIDExOSApLFxuICAgICAgICAgICAgICAgICAgICBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oIDExICksXG4gICAgICAgICAgICAgICAgICAgIHRvU291cmNlID0gX193ZWJwYWNrX3JlcXVpcmVfXyggNDQgKTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcbiAgICAgICAgICAgICAgICAgKiBbc3ludGF4IGNoYXJhY3RlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXBhdHRlcm5zKS5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB2YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nO1xuXG4gICAgICAgICAgICAgICAgLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkpLiAqL1xuICAgICAgICAgICAgICAgIHZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4gICAgICAgICAgICAgICAgLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xuICAgICAgICAgICAgICAgIHZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuICAgICAgICAgICAgICAgIC8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbiAgICAgICAgICAgICAgICB2YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4gICAgICAgICAgICAgICAgLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG4gICAgICAgICAgICAgICAgdmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbiAgICAgICAgICAgICAgICAvKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xuICAgICAgICAgICAgICAgIHZhciByZUlzTmF0aXZlID0gUmVnRXhwKCAnXicgK1xuICAgICAgICAgICAgICAgICAgICBmdW5jVG9TdHJpbmcuY2FsbCggaGFzT3duUHJvcGVydHkgKS5yZXBsYWNlKCByZVJlZ0V4cENoYXIsICdcXFxcJCYnIClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKCAvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JyApICsgJyQnXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sXG4gICAgICAgICAgICAgICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBiYXNlSXNOYXRpdmUoIHZhbHVlICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoICFpc09iamVjdCggdmFsdWUgKSB8fCBpc01hc2tlZCggdmFsdWUgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgcGF0dGVybiA9IGlzRnVuY3Rpb24oIHZhbHVlICkgPyByZUlzTmF0aXZlIDogcmVJc0hvc3RDdG9yO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGF0dGVybi50ZXN0KCB0b1NvdXJjZSggdmFsdWUgKSApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gYmFzZUlzTmF0aXZlO1xuXG5cbiAgICAgICAgICAgICAgICAvKioqL1xufSxcbi8qIDkxICovXG4vKioqLyBmdW5jdGlvbiAoIG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyApIHtcblxuICAgICAgICAgICAgICAgIHZhciBpc0xlbmd0aCA9IF9fd2VicGFja19yZXF1aXJlX18oIDIyICksXG4gICAgICAgICAgICAgICAgICAgIGlzT2JqZWN0TGlrZSA9IF9fd2VicGFja19yZXF1aXJlX18oIDQgKTtcblxuICAgICAgICAgICAgICAgIC8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbiAgICAgICAgICAgICAgICB2YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgICAgICAgICAgICAgICAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgICAgICAgICAgICAgICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgICAgICAgICAgICAgICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICAgICAgICAgICAgICAgICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgICAgICAgICAgICAgICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgICAgICAgICAgICAgICAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgICAgICAgICAgICAgICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgICAgICAgICAgICAgICAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgICAgICAgICAgICAgICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbiAgICAgICAgICAgICAgICB2YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgICAgICAgICAgICAgICAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgICAgICAgICAgICAgICAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgICAgICAgICAgICAgICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgICAgICAgICAgICAgICAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICAgICAgICAgICAgICAgICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgICAgICAgICAgICAgICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgICAgICAgICAgICAgICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgICAgICAgICAgICAgICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbiAgICAgICAgICAgICAgICAvKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBvZiB0eXBlZCBhcnJheXMuICovXG4gICAgICAgICAgICAgICAgdmFyIHR5cGVkQXJyYXlUYWdzID0ge307XG4gICAgICAgICAgICAgICAgdHlwZWRBcnJheVRhZ3NbZmxvYXQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1tmbG9hdDY0VGFnXSA9XG4gICAgICAgICAgICAgICAgICAgIHR5cGVkQXJyYXlUYWdzW2ludDhUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50MTZUYWddID1cbiAgICAgICAgICAgICAgICAgICAgdHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID1cbiAgICAgICAgICAgICAgICAgICAgdHlwZWRBcnJheVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQxNlRhZ10gPVxuICAgICAgICAgICAgICAgICAgICB0eXBlZEFycmF5VGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0eXBlZEFycmF5VGFnc1thcmdzVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9XG4gICAgICAgICAgICAgICAgICAgIHR5cGVkQXJyYXlUYWdzW2FycmF5QnVmZmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Jvb2xUYWddID1cbiAgICAgICAgICAgICAgICAgICAgdHlwZWRBcnJheVRhZ3NbZGF0YVZpZXdUYWddID0gdHlwZWRBcnJheVRhZ3NbZGF0ZVRhZ10gPVxuICAgICAgICAgICAgICAgICAgICB0eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPSB0eXBlZEFycmF5VGFnc1tmdW5jVGFnXSA9XG4gICAgICAgICAgICAgICAgICAgIHR5cGVkQXJyYXlUYWdzW21hcFRhZ10gPSB0eXBlZEFycmF5VGFnc1tudW1iZXJUYWddID1cbiAgICAgICAgICAgICAgICAgICAgdHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3JlZ2V4cFRhZ10gPVxuICAgICAgICAgICAgICAgICAgICB0eXBlZEFycmF5VGFnc1tzZXRUYWddID0gdHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9XG4gICAgICAgICAgICAgICAgICAgIHR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG4gICAgICAgICAgICAgICAgdmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAgICAgICAgICAgICAgICAgKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAgICAgICAgICAgICAgICAgKiBvZiB2YWx1ZXMuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdmFyIG9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1R5cGVkQXJyYXlgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gYmFzZUlzVHlwZWRBcnJheSggdmFsdWUgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpc09iamVjdExpa2UoIHZhbHVlICkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzTGVuZ3RoKCB2YWx1ZS5sZW5ndGggKSAmJiAhIXR5cGVkQXJyYXlUYWdzW29iamVjdFRvU3RyaW5nLmNhbGwoIHZhbHVlICldO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gYmFzZUlzVHlwZWRBcnJheTtcblxuXG4gICAgICAgICAgICAgICAgLyoqKi9cbn0sXG4vKiA5MiAqL1xuLyoqKi8gZnVuY3Rpb24gKCBtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18gKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgYmFzZU1hdGNoZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCA5NCApLFxuICAgICAgICAgICAgICAgICAgICBiYXNlTWF0Y2hlc1Byb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyggOTUgKSxcbiAgICAgICAgICAgICAgICAgICAgaWRlbnRpdHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCAxOSApLFxuICAgICAgICAgICAgICAgICAgICBpc0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyggMyApLFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eSA9IF9fd2VicGFja19yZXF1aXJlX18oIDE1NyApO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXRlcmF0ZWVgLlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0geyp9IFt2YWx1ZT1fLmlkZW50aXR5XSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhbiBpdGVyYXRlZS5cbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGl0ZXJhdGVlLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGJhc2VJdGVyYXRlZSggdmFsdWUgKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIERvbid0IHN0b3JlIHRoZSBgdHlwZW9mYCByZXN1bHQgaW4gYSB2YXJpYWJsZSB0byBhdm9pZCBhIEpJVCBidWcgaW4gU2FmYXJpIDkuXG4gICAgICAgICAgICAgICAgICAgIC8vIFNlZSBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTU2MDM0IGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgICAgICAgICAgICAgIGlmICggdHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCB2YWx1ZSA9PSBudWxsICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlkZW50aXR5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICggdHlwZW9mIHZhbHVlID09ICdvYmplY3QnICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzQXJyYXkoIHZhbHVlIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGJhc2VNYXRjaGVzUHJvcGVydHkoIHZhbHVlWzBdLCB2YWx1ZVsxXSApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBiYXNlTWF0Y2hlcyggdmFsdWUgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvcGVydHkoIHZhbHVlICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBiYXNlSXRlcmF0ZWU7XG5cblxuICAgICAgICAgICAgICAgIC8qKiovXG59LFxuLyogOTMgKi9cbi8qKiovIGZ1bmN0aW9uICggbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGlzUHJvdG90eXBlID0gX193ZWJwYWNrX3JlcXVpcmVfXyggMTIwICksXG4gICAgICAgICAgICAgICAgICAgIG5hdGl2ZUtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCAxMzQgKTtcblxuICAgICAgICAgICAgICAgIC8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbiAgICAgICAgICAgICAgICB2YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4gICAgICAgICAgICAgICAgLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG4gICAgICAgICAgICAgICAgdmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGJhc2VLZXlzKCBvYmplY3QgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggIWlzUHJvdG90eXBlKCBvYmplY3QgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuYXRpdmVLZXlzKCBvYmplY3QgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZvciAoIHZhciBrZXkgaW4gT2JqZWN0KCBvYmplY3QgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggaGFzT3duUHJvcGVydHkuY2FsbCggb2JqZWN0LCBrZXkgKSAmJiBrZXkgIT0gJ2NvbnN0cnVjdG9yJyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgga2V5ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGJhc2VLZXlzO1xuXG5cbiAgICAgICAgICAgICAgICAvKioqL1xufSxcbi8qIDk0ICovXG4vKioqLyBmdW5jdGlvbiAoIG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyApIHtcblxuICAgICAgICAgICAgICAgIHZhciBiYXNlSXNNYXRjaCA9IF9fd2VicGFja19yZXF1aXJlX18oIDg4ICksXG4gICAgICAgICAgICAgICAgICAgIGdldE1hdGNoRGF0YSA9IF9fd2VicGFja19yZXF1aXJlX18oIDEwNyApLFxuICAgICAgICAgICAgICAgICAgICBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oIDQyICk7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzYCB3aGljaCBkb2Vzbid0IGNsb25lIGBzb3VyY2VgLlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gYmFzZU1hdGNoZXMoIHNvdXJjZSApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGNoRGF0YSA9IGdldE1hdGNoRGF0YSggc291cmNlICk7XG4gICAgICAgICAgICAgICAgICAgIGlmICggbWF0Y2hEYXRhLmxlbmd0aCA9PSAxICYmIG1hdGNoRGF0YVswXVsyXSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSggbWF0Y2hEYXRhWzBdWzBdLCBtYXRjaERhdGFbMF1bMV0gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCBvYmplY3QgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0ID09PSBzb3VyY2UgfHwgYmFzZUlzTWF0Y2goIG9iamVjdCwgc291cmNlLCBtYXRjaERhdGEgKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGJhc2VNYXRjaGVzO1xuXG5cbiAgICAgICAgICAgICAgICAvKioqL1xufSxcbi8qIDk1ICovXG4vKioqLyBmdW5jdGlvbiAoIG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyApIHtcblxuICAgICAgICAgICAgICAgIHZhciBiYXNlSXNFcXVhbCA9IF9fd2VicGFja19yZXF1aXJlX18oIDM0ICksXG4gICAgICAgICAgICAgICAgICAgIGdldCA9IF9fd2VicGFja19yZXF1aXJlX18oIDE1MCApLFxuICAgICAgICAgICAgICAgICAgICBoYXNJbiA9IF9fd2VicGFja19yZXF1aXJlX18oIDE1MSApLFxuICAgICAgICAgICAgICAgICAgICBpc0tleSA9IF9fd2VicGFja19yZXF1aXJlX18oIDggKSxcbiAgICAgICAgICAgICAgICAgICAgaXNTdHJpY3RDb21wYXJhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyggNDEgKSxcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlc1N0cmljdENvbXBhcmFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCA0MiApLFxuICAgICAgICAgICAgICAgICAgICB0b0tleSA9IF9fd2VicGFja19yZXF1aXJlX18oIDEwICk7XG5cbiAgICAgICAgICAgICAgICAvKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBjb21wYXJpc29uIHN0eWxlcy4gKi9cbiAgICAgICAgICAgICAgICB2YXIgVU5PUkRFUkVEX0NPTVBBUkVfRkxBRyA9IDEsXG4gICAgICAgICAgICAgICAgICAgIFBBUlRJQUxfQ09NUEFSRV9GTEFHID0gMjtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hdGNoZXNQcm9wZXJ0eWAgd2hpY2ggZG9lc24ndCBjbG9uZSBgc3JjVmFsdWVgLlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gYmFzZU1hdGNoZXNQcm9wZXJ0eSggcGF0aCwgc3JjVmFsdWUgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggaXNLZXkoIHBhdGggKSAmJiBpc1N0cmljdENvbXBhcmFibGUoIHNyY1ZhbHVlICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUoIHRvS2V5KCBwYXRoICksIHNyY1ZhbHVlICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICggb2JqZWN0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9ialZhbHVlID0gZ2V0KCBvYmplY3QsIHBhdGggKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoIG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgb2JqVmFsdWUgPT09IHNyY1ZhbHVlIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGhhc0luKCBvYmplY3QsIHBhdGggKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogYmFzZUlzRXF1YWwoIHNyY1ZhbHVlLCBvYmpWYWx1ZSwgdW5kZWZpbmVkLCBVTk9SREVSRURfQ09NUEFSRV9GTEFHIHwgUEFSVElBTF9DT01QQVJFX0ZMQUcgKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGJhc2VNYXRjaGVzUHJvcGVydHk7XG5cblxuICAgICAgICAgICAgICAgIC8qKiovXG59LFxuLyogOTYgKi9cbi8qKiovIGZ1bmN0aW9uICggbW9kdWxlLCBleHBvcnRzICkge1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHJvcGVydHlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gYmFzZVByb3BlcnR5KCBrZXkgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoIG9iamVjdCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gYmFzZVByb3BlcnR5O1xuXG5cbiAgICAgICAgICAgICAgICAvKioqL1xufSxcbi8qIDk3ICovXG4vKioqLyBmdW5jdGlvbiAoIG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyApIHtcblxuICAgICAgICAgICAgICAgIHZhciBiYXNlR2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyggMzMgKTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVByb3BlcnR5YCB3aGljaCBzdXBwb3J0cyBkZWVwIHBhdGhzLlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGJhc2VQcm9wZXJ0eURlZXAoIHBhdGggKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoIG9iamVjdCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBiYXNlR2V0KCBvYmplY3QsIHBhdGggKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGJhc2VQcm9wZXJ0eURlZXA7XG5cblxuICAgICAgICAgICAgICAgIC8qKiovXG59LFxuLyogOTggKi9cbi8qKiovIGZ1bmN0aW9uICggbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGNvbnN0YW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyggMTQ4ICksXG4gICAgICAgICAgICAgICAgICAgIGlkZW50aXR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyggMTkgKSxcbiAgICAgICAgICAgICAgICAgICAgbmF0aXZlRGVmaW5lUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCAxMzMgKTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBzZXRUb1N0cmluZ2Agd2l0aG91dCBzdXBwb3J0IGZvciBob3QgbG9vcCBzaG9ydGluZy5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZyBUaGUgYHRvU3RyaW5nYCByZXN1bHQuXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB2YXIgYmFzZVNldFRvU3RyaW5nID0gIW5hdGl2ZURlZmluZVByb3BlcnR5ID8gaWRlbnRpdHkgOiBmdW5jdGlvbiAoIGZ1bmMsIHN0cmluZyApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5hdGl2ZURlZmluZVByb3BlcnR5KCBmdW5jLCAndG9TdHJpbmcnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnY29uZmlndXJhYmxlJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdlbnVtZXJhYmxlJzogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAndmFsdWUnOiBjb25zdGFudCggc3RyaW5nICksXG4gICAgICAgICAgICAgICAgICAgICAgICAnd3JpdGFibGUnOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0gKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBiYXNlU2V0VG9TdHJpbmc7XG5cblxuICAgICAgICAgICAgICAgIC8qKiovXG59LFxuLyogOTkgKi9cbi8qKiovIGZ1bmN0aW9uICggbW9kdWxlLCBleHBvcnRzICkge1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udGltZXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kc1xuICAgICAgICAgICAgICAgICAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGJhc2VUaW1lcyggbiwgaXRlcmF0ZWUgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gQXJyYXkoIG4gKTtcblxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoICsraW5kZXggPCBuICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKCBpbmRleCApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBiYXNlVGltZXM7XG5cblxuICAgICAgICAgICAgICAgIC8qKiovXG59LFxuLyogMTAwICovXG4vKioqLyBmdW5jdGlvbiAoIG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyApIHtcblxuICAgICAgICAgICAgICAgIHZhciBTeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCAxNiApLFxuICAgICAgICAgICAgICAgICAgICBpc1N5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oIDIzICk7XG5cbiAgICAgICAgICAgICAgICAvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbiAgICAgICAgICAgICAgICB2YXIgSU5GSU5JVFkgPSAxIC8gMDtcblxuICAgICAgICAgICAgICAgIC8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xuICAgICAgICAgICAgICAgIHZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbFRvU3RyaW5nID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by50b1N0cmluZyA6IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvU3RyaW5nYCB3aGljaCBkb2Vzbid0IGNvbnZlcnQgbnVsbGlzaFxuICAgICAgICAgICAgICAgICAqIHZhbHVlcyB0byBlbXB0eSBzdHJpbmdzLlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBiYXNlVG9TdHJpbmcoIHZhbHVlICkge1xuICAgICAgICAgICAgICAgICAgICAvLyBFeGl0IGVhcmx5IGZvciBzdHJpbmdzIHRvIGF2b2lkIGEgcGVyZm9ybWFuY2UgaGl0IGluIHNvbWUgZW52aXJvbm1lbnRzLlxuICAgICAgICAgICAgICAgICAgICBpZiAoIHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIGlzU3ltYm9sKCB2YWx1ZSApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN5bWJvbFRvU3RyaW5nID8gc3ltYm9sVG9TdHJpbmcuY2FsbCggdmFsdWUgKSA6ICcnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSAoIHZhbHVlICsgJycgKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICggcmVzdWx0ID09ICcwJyAmJiAoIDEgLyB2YWx1ZSApID09IC1JTkZJTklUWSApID8gJy0wJyA6IHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGJhc2VUb1N0cmluZztcblxuXG4gICAgICAgICAgICAgICAgLyoqKi9cbn0sXG4vKiAxMDEgKi9cbi8qKiovIGZ1bmN0aW9uICggbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIFNldENhY2hlID0gX193ZWJwYWNrX3JlcXVpcmVfXyggMTUgKSxcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlJbmNsdWRlcyA9IF9fd2VicGFja19yZXF1aXJlX18oIDMwICksXG4gICAgICAgICAgICAgICAgICAgIGFycmF5SW5jbHVkZXNXaXRoID0gX193ZWJwYWNrX3JlcXVpcmVfXyggMzEgKSxcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVIYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCAxNyApLFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVTZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCAxMDQgKSxcbiAgICAgICAgICAgICAgICAgICAgc2V0VG9BcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oIDE4ICk7XG5cbiAgICAgICAgICAgICAgICAvKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbiAgICAgICAgICAgICAgICB2YXIgTEFSR0VfQVJSQVlfU0laRSA9IDIwMDtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuaXFCeWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZSBmcmVlIGFycmF5LlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGJhc2VVbmlxKCBhcnJheSwgaXRlcmF0ZWUsIGNvbXBhcmF0b3IgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVkZXMgPSBhcnJheUluY2x1ZGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNDb21tb24gPSB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gW10sXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWVuID0gcmVzdWx0O1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggY29tcGFyYXRvciApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNsdWRlcyA9IGFycmF5SW5jbHVkZXNXaXRoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCBsZW5ndGggPj0gTEFSR0VfQVJSQVlfU0laRSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZXQgPSBpdGVyYXRlZSA/IG51bGwgOiBjcmVhdGVTZXQoIGFycmF5ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHNldCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2V0VG9BcnJheSggc2V0ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVkZXMgPSBjYWNoZUhhcztcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZW4gPSBuZXcgU2V0Q2FjaGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWVuID0gaXRlcmF0ZWUgPyBbXSA6IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvdXRlcjpcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCArK2luZGV4IDwgbGVuZ3RoICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPyBpdGVyYXRlZSggdmFsdWUgKSA6IHZhbHVlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9ICggY29tcGFyYXRvciB8fCB2YWx1ZSAhPT0gMCApID8gdmFsdWUgOiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBpc0NvbW1vbiAmJiBjb21wdXRlZCA9PT0gY29tcHV0ZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNlZW5JbmRleCA9IHNlZW4ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICggc2VlbkluZGV4LS0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggc2VlbltzZWVuSW5kZXhdID09PSBjb21wdXRlZCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggaXRlcmF0ZWUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlZW4ucHVzaCggY29tcHV0ZWQgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goIHZhbHVlICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICggIWluY2x1ZGVzKCBzZWVuLCBjb21wdXRlZCwgY29tcGFyYXRvciApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggc2VlbiAhPT0gcmVzdWx0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWVuLnB1c2goIGNvbXB1dGVkICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCB2YWx1ZSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBiYXNlVW5pcTtcblxuXG4gICAgICAgICAgICAgICAgLyoqKi9cbn0sXG4vKiAxMDIgKi9cbi8qKiovIGZ1bmN0aW9uICggbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIHJvb3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCAxICk7XG5cbiAgICAgICAgICAgICAgICAvKiogVXNlZCB0byBkZXRlY3Qgb3ZlcnJlYWNoaW5nIGNvcmUtanMgc2hpbXMuICovXG4gICAgICAgICAgICAgICAgdmFyIGNvcmVKc0RhdGEgPSByb290WydfX2NvcmUtanNfc2hhcmVkX18nXTtcblxuICAgICAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gY29yZUpzRGF0YTtcblxuXG4gICAgICAgICAgICAgICAgLyoqKi9cbn0sXG4vKiAxMDMgKi9cbi8qKiovIGZ1bmN0aW9uICggbW9kdWxlLCBleHBvcnRzICkge1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQ3JlYXRlcyBhIGJhc2UgZnVuY3Rpb24gZm9yIG1ldGhvZHMgbGlrZSBgXy5mb3JJbmAgYW5kIGBfLmZvck93bmAuXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gY3JlYXRlQmFzZUZvciggZnJvbVJpZ2h0ICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCBvYmplY3QsIGl0ZXJhdGVlLCBrZXlzRnVuYyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZXJhYmxlID0gT2JqZWN0KCBvYmplY3QgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wcyA9IGtleXNGdW5jKCBvYmplY3QgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICggbGVuZ3RoLS0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IHByb3BzW2Zyb21SaWdodCA/IGxlbmd0aCA6ICsraW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggaXRlcmF0ZWUoIGl0ZXJhYmxlW2tleV0sIGtleSwgaXRlcmFibGUgKSA9PT0gZmFsc2UgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVCYXNlRm9yO1xuXG5cbiAgICAgICAgICAgICAgICAvKioqL1xufSxcbi8qIDEwNCAqL1xuLyoqKi8gZnVuY3Rpb24gKCBtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18gKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgU2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyggMjggKSxcbiAgICAgICAgICAgICAgICAgICAgbm9vcCA9IF9fd2VicGFja19yZXF1aXJlX18oIDE1NiApLFxuICAgICAgICAgICAgICAgICAgICBzZXRUb0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyggMTggKTtcblxuICAgICAgICAgICAgICAgIC8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xuICAgICAgICAgICAgICAgIHZhciBJTkZJTklUWSA9IDEgLyAwO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQ3JlYXRlcyBhIHNldCBvYmplY3Qgb2YgYHZhbHVlc2AuXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGFkZCB0byB0aGUgc2V0LlxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBzZXQuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdmFyIGNyZWF0ZVNldCA9ICEoIFNldCAmJiAoIDEgLyBzZXRUb0FycmF5KCBuZXcgU2V0KCBbLCAtMF0gKSApWzFdICkgPT0gSU5GSU5JVFkgKSA/IG5vb3AgOiBmdW5jdGlvbiAoIHZhbHVlcyApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTZXQoIHZhbHVlcyApO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVNldDtcblxuXG4gICAgICAgICAgICAgICAgLyoqKi9cbn0sXG4vKiAxMDUgKi9cbi8qKiovIGZ1bmN0aW9uICggbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIFN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oIDE2ICksXG4gICAgICAgICAgICAgICAgICAgIFVpbnQ4QXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCA3MiApLFxuICAgICAgICAgICAgICAgICAgICBlcSA9IF9fd2VicGFja19yZXF1aXJlX18oIDQ1ICksXG4gICAgICAgICAgICAgICAgICAgIGVxdWFsQXJyYXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyggMzggKSxcbiAgICAgICAgICAgICAgICAgICAgbWFwVG9BcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oIDEzMSApLFxuICAgICAgICAgICAgICAgICAgICBzZXRUb0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyggMTggKTtcblxuICAgICAgICAgICAgICAgIC8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIGNvbXBhcmlzb24gc3R5bGVzLiAqL1xuICAgICAgICAgICAgICAgIHZhciBVTk9SREVSRURfQ09NUEFSRV9GTEFHID0gMSxcbiAgICAgICAgICAgICAgICAgICAgUEFSVElBTF9DT01QQVJFX0ZMQUcgPSAyO1xuXG4gICAgICAgICAgICAgICAgLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xuICAgICAgICAgICAgICAgIHZhciBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgICAgICAgICAgICAgICAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgICAgICAgICAgICAgICAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgICAgICAgICAgICAgICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgICAgICAgICAgICAgICAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICAgICAgICAgICAgICAgICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgICAgICAgICAgICAgICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgICAgICAgICAgICAgICAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbiAgICAgICAgICAgICAgICB2YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgICAgICAgICAgICAgICAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XSc7XG5cbiAgICAgICAgICAgICAgICAvKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbiAgICAgICAgICAgICAgICB2YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBzeW1ib2xWYWx1ZU9mID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by52YWx1ZU9mIDogdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBjb21wYXJpbmcgb2JqZWN0cyBvZlxuICAgICAgICAgICAgICAgICAqIHRoZSBzYW1lIGB0b1N0cmluZ1RhZ2AuXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNvbXBhcmluZyB2YWx1ZXMgd2l0aCB0YWdzIG9mXG4gICAgICAgICAgICAgICAgICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgb3IgYFN0cmluZ2AuXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0cyB0byBjb21wYXJlLlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgb2YgY29tcGFyaXNvbiBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGBcbiAgICAgICAgICAgICAgICAgKiAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGVxdWFsQnlUYWcoIG9iamVjdCwgb3RoZXIsIHRhZywgZXF1YWxGdW5jLCBjdXN0b21pemVyLCBiaXRtYXNrLCBzdGFjayApIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICggdGFnICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBkYXRhVmlld1RhZzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoICggb2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCApIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggb2JqZWN0LmJ5dGVPZmZzZXQgIT0gb3RoZXIuYnl0ZU9mZnNldCApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdCA9IG9iamVjdC5idWZmZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3RoZXIgPSBvdGhlci5idWZmZXI7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAoIG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGggKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhZXF1YWxGdW5jKCBuZXcgVWludDhBcnJheSggb2JqZWN0ICksIG5ldyBVaW50OEFycmF5KCBvdGhlciApICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgYm9vbFRhZzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgZGF0ZVRhZzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvZXJjZSBib29sZWFucyB0byBgMWAgb3IgYDBgIGFuZCBkYXRlcyB0byBtaWxsaXNlY29uZHMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW52YWxpZCBkYXRlcyBhcmUgY29lcmNlZCB0byBgTmFOYC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXEoICtvYmplY3QsICtvdGhlciApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGVycm9yVGFnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3QubmFtZSA9PSBvdGhlci5uYW1lICYmIG9iamVjdC5tZXNzYWdlID09IG90aGVyLm1lc3NhZ2U7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgcmVnZXhwVGFnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29lcmNlIHJlZ2V4ZXMgdG8gc3RyaW5ncyBhbmQgdHJlYXQgc3RyaW5ncywgcHJpbWl0aXZlcyBhbmQgb2JqZWN0cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhcyBlcXVhbC4gU2VlIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1yZWdleHAucHJvdG90eXBlLnRvc3RyaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0ID09ICggb3RoZXIgKyAnJyApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIG1hcFRhZzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29udmVydCA9IG1hcFRvQXJyYXk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgUEFSVElBTF9DT01QQVJFX0ZMQUc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udmVydCB8fCAoIGNvbnZlcnQgPSBzZXRUb0FycmF5ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG9iamVjdC5zaXplICE9IG90aGVyLnNpemUgJiYgIWlzUGFydGlhbCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQoIG9iamVjdCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggc3RhY2tlZCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpdG1hc2sgfD0gVU5PUkRFUkVEX0NPTVBBUkVfRkxBRztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLnNldCggb2JqZWN0LCBvdGhlciApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBlcXVhbEFycmF5cyggY29udmVydCggb2JqZWN0ICksIGNvbnZlcnQoIG90aGVyICksIGVxdWFsRnVuYywgY3VzdG9taXplciwgYml0bWFzaywgc3RhY2sgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFja1snZGVsZXRlJ10oIG9iamVjdCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2Ugc3ltYm9sVGFnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggc3ltYm9sVmFsdWVPZiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN5bWJvbFZhbHVlT2YuY2FsbCggb2JqZWN0ICkgPT0gc3ltYm9sVmFsdWVPZi5jYWxsKCBvdGhlciApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBlcXVhbEJ5VGFnO1xuXG5cbiAgICAgICAgICAgICAgICAvKioqL1xufSxcbi8qIDEwNiAqL1xuLyoqKi8gZnVuY3Rpb24gKCBtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18gKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIga2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oIDI0ICk7XG5cbiAgICAgICAgICAgICAgICAvKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBjb21wYXJpc29uIHN0eWxlcy4gKi9cbiAgICAgICAgICAgICAgICB2YXIgUEFSVElBTF9DT01QQVJFX0ZMQUcgPSAyO1xuXG4gICAgICAgICAgICAgICAgLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xuICAgICAgICAgICAgICAgIHZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbiAgICAgICAgICAgICAgICAvKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbiAgICAgICAgICAgICAgICB2YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3Igb2JqZWN0cyB3aXRoIHN1cHBvcnQgZm9yXG4gICAgICAgICAgICAgICAgICogcGFydGlhbCBkZWVwIGNvbXBhcmlzb25zLlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgb2YgY29tcGFyaXNvbiBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGBcbiAgICAgICAgICAgICAgICAgKiAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGVxdWFsT2JqZWN0cyggb2JqZWN0LCBvdGhlciwgZXF1YWxGdW5jLCBjdXN0b21pemVyLCBiaXRtYXNrLCBzdGFjayApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBQQVJUSUFMX0NPTVBBUkVfRkxBRyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ialByb3BzID0ga2V5cyggb2JqZWN0ICksXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmpMZW5ndGggPSBvYmpQcm9wcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBvdGhQcm9wcyA9IGtleXMoIG90aGVyICksXG4gICAgICAgICAgICAgICAgICAgICAgICBvdGhMZW5ndGggPSBvdGhQcm9wcy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBvYmpMZW5ndGggIT0gb3RoTGVuZ3RoICYmICFpc1BhcnRpYWwgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gb2JqTGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIGluZGV4LS0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhKCBpc1BhcnRpYWwgPyBrZXkgaW4gb3RoZXIgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKCBvdGhlciwga2V5ICkgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldCggb2JqZWN0ICk7XG4gICAgICAgICAgICAgICAgICAgIGlmICggc3RhY2tlZCAmJiBzdGFjay5nZXQoIG90aGVyICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2suc2V0KCBvYmplY3QsIG90aGVyICk7XG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLnNldCggb3RoZXIsIG9iamVjdCApO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBza2lwQ3RvciA9IGlzUGFydGlhbDtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCArK2luZGV4IDwgb2JqTGVuZ3RoICkge1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltrZXldO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGN1c3RvbWl6ZXIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gY3VzdG9taXplciggb3RoVmFsdWUsIG9ialZhbHVlLCBrZXksIG90aGVyLCBvYmplY3QsIHN0YWNrIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBjdXN0b21pemVyKCBvYmpWYWx1ZSwgb3RoVmFsdWUsIGtleSwgb2JqZWN0LCBvdGhlciwgc3RhY2sgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhKCBjb21wYXJlZCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAoIG9ialZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMoIG9ialZhbHVlLCBvdGhWYWx1ZSwgY3VzdG9taXplciwgYml0bWFzaywgc3RhY2sgKSApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBjb21wYXJlZFxuICAgICAgICAgICAgICAgICAgICAgICAgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHNraXBDdG9yIHx8ICggc2tpcEN0b3IgPSBrZXkgPT0gJ2NvbnN0cnVjdG9yJyApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICggcmVzdWx0ICYmICFza2lwQ3RvciApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvYmpDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG90aEN0b3IgPSBvdGhlci5jb25zdHJ1Y3RvcjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm9uIGBPYmplY3RgIG9iamVjdCBpbnN0YW5jZXMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1YWwuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG9iakN0b3IgIT0gb3RoQ3RvciAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICggJ2NvbnN0cnVjdG9yJyBpbiBvYmplY3QgJiYgJ2NvbnN0cnVjdG9yJyBpbiBvdGhlciApICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgISggdHlwZW9mIG9iakN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvYmpDdG9yIGluc3RhbmNlb2Ygb2JqQ3RvciAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2Ygb3RoQ3RvciA9PSAnZnVuY3Rpb24nICYmIG90aEN0b3IgaW5zdGFuY2VvZiBvdGhDdG9yICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3RhY2tbJ2RlbGV0ZSddKCBvYmplY3QgKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2tbJ2RlbGV0ZSddKCBvdGhlciApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gZXF1YWxPYmplY3RzO1xuXG5cbiAgICAgICAgICAgICAgICAvKioqL1xufSxcbi8qIDEwNyAqL1xuLyoqKi8gZnVuY3Rpb24gKCBtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18gKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgaXNTdHJpY3RDb21wYXJhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyggNDEgKSxcbiAgICAgICAgICAgICAgICAgICAga2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oIDI0ICk7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBHZXRzIHRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyBvZiBgb2JqZWN0YC5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbWF0Y2ggZGF0YSBvZiBgb2JqZWN0YC5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBnZXRNYXRjaERhdGEoIG9iamVjdCApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGtleXMoIG9iamVjdCApLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIGxlbmd0aC0tICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IHJlc3VsdFtsZW5ndGhdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gb2JqZWN0W2tleV07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtsZW5ndGhdID0gW2tleSwgdmFsdWUsIGlzU3RyaWN0Q29tcGFyYWJsZSggdmFsdWUgKV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGdldE1hdGNoRGF0YTtcblxuXG4gICAgICAgICAgICAgICAgLyoqKi9cbn0sXG4vKiAxMDggKi9cbi8qKiovIGZ1bmN0aW9uICggbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIG92ZXJBcmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCA0MyApO1xuXG4gICAgICAgICAgICAgICAgLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG4gICAgICAgICAgICAgICAgdmFyIGdldFByb3RvdHlwZSA9IG92ZXJBcmcoIE9iamVjdC5nZXRQcm90b3R5cGVPZiwgT2JqZWN0ICk7XG5cbiAgICAgICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGdldFByb3RvdHlwZTtcblxuXG4gICAgICAgICAgICAgICAgLyoqKi9cbn0sXG4vKiAxMDkgKi9cbi8qKiovIGZ1bmN0aW9uICggbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIERhdGFWaWV3ID0gX193ZWJwYWNrX3JlcXVpcmVfXyggNjkgKSxcbiAgICAgICAgICAgICAgICAgICAgTWFwID0gX193ZWJwYWNrX3JlcXVpcmVfXyggMTMgKSxcbiAgICAgICAgICAgICAgICAgICAgUHJvbWlzZSA9IF9fd2VicGFja19yZXF1aXJlX18oIDcxICksXG4gICAgICAgICAgICAgICAgICAgIFNldCA9IF9fd2VicGFja19yZXF1aXJlX18oIDI4ICksXG4gICAgICAgICAgICAgICAgICAgIFdlYWtNYXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCA3MyApLFxuICAgICAgICAgICAgICAgICAgICBiYXNlR2V0VGFnID0gX193ZWJwYWNrX3JlcXVpcmVfXyggODQgKSxcbiAgICAgICAgICAgICAgICAgICAgdG9Tb3VyY2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCA0NCApO1xuXG4gICAgICAgICAgICAgICAgLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xuICAgICAgICAgICAgICAgIHZhciBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgICAgICAgICAgICAgICAgIHByb21pc2VUYWcgPSAnW29iamVjdCBQcm9taXNlXScsXG4gICAgICAgICAgICAgICAgICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgICAgICAgICAgICAgICAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG4gICAgICAgICAgICAgICAgdmFyIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJztcblxuICAgICAgICAgICAgICAgIC8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbiAgICAgICAgICAgICAgICB2YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogVXNlZCB0byByZXNvbHZlIHRoZVxuICAgICAgICAgICAgICAgICAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICAgICAgICAgICAgICAgICAqIG9mIHZhbHVlcy5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB2YXIgb2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuICAgICAgICAgICAgICAgIC8qKiBVc2VkIHRvIGRldGVjdCBtYXBzLCBzZXRzLCBhbmQgd2Vha21hcHMuICovXG4gICAgICAgICAgICAgICAgdmFyIGRhdGFWaWV3Q3RvclN0cmluZyA9IHRvU291cmNlKCBEYXRhVmlldyApLFxuICAgICAgICAgICAgICAgICAgICBtYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoIE1hcCApLFxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlQ3RvclN0cmluZyA9IHRvU291cmNlKCBQcm9taXNlICksXG4gICAgICAgICAgICAgICAgICAgIHNldEN0b3JTdHJpbmcgPSB0b1NvdXJjZSggU2V0ICksXG4gICAgICAgICAgICAgICAgICAgIHdlYWtNYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoIFdlYWtNYXAgKTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEdldHMgdGhlIGB0b1N0cmluZ1RhZ2Agb2YgYHZhbHVlYC5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB2YXIgZ2V0VGFnID0gYmFzZUdldFRhZztcblxuICAgICAgICAgICAgICAgIC8vIEZhbGxiYWNrIGZvciBkYXRhIHZpZXdzLCBtYXBzLCBzZXRzLCBhbmQgd2VhayBtYXBzIGluIElFIDExIGFuZCBwcm9taXNlcyBpbiBOb2RlLmpzIDwgNi5cbiAgICAgICAgICAgICAgICBpZiAoICggRGF0YVZpZXcgJiYgZ2V0VGFnKCBuZXcgRGF0YVZpZXcoIG5ldyBBcnJheUJ1ZmZlciggMSApICkgKSAhPSBkYXRhVmlld1RhZyApIHx8XG4gICAgICAgICAgICAgICAgICAgICggTWFwICYmIGdldFRhZyggbmV3IE1hcCApICE9IG1hcFRhZyApIHx8XG4gICAgICAgICAgICAgICAgICAgICggUHJvbWlzZSAmJiBnZXRUYWcoIFByb21pc2UucmVzb2x2ZSgpICkgIT0gcHJvbWlzZVRhZyApIHx8XG4gICAgICAgICAgICAgICAgICAgICggU2V0ICYmIGdldFRhZyggbmV3IFNldCApICE9IHNldFRhZyApIHx8XG4gICAgICAgICAgICAgICAgICAgICggV2Vha01hcCAmJiBnZXRUYWcoIG5ldyBXZWFrTWFwICkgIT0gd2Vha01hcFRhZyApICkge1xuICAgICAgICAgICAgICAgICAgICBnZXRUYWcgPSBmdW5jdGlvbiAoIHZhbHVlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG9iamVjdFRvU3RyaW5nLmNhbGwoIHZhbHVlICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQ3RvciA9IHJlc3VsdCA9PSBvYmplY3RUYWcgPyB2YWx1ZS5jb25zdHJ1Y3RvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdG9yU3RyaW5nID0gQ3RvciA/IHRvU291cmNlKCBDdG9yICkgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggY3RvclN0cmluZyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKCBjdG9yU3RyaW5nICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGRhdGFWaWV3Q3RvclN0cmluZzogcmV0dXJuIGRhdGFWaWV3VGFnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIG1hcEN0b3JTdHJpbmc6IHJldHVybiBtYXBUYWc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgcHJvbWlzZUN0b3JTdHJpbmc6IHJldHVybiBwcm9taXNlVGFnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIHNldEN0b3JTdHJpbmc6IHJldHVybiBzZXRUYWc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2Ugd2Vha01hcEN0b3JTdHJpbmc6IHJldHVybiB3ZWFrTWFwVGFnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBnZXRUYWc7XG5cblxuICAgICAgICAgICAgICAgIC8qKiovXG59LFxuLyogMTEwICovXG4vKioqLyBmdW5jdGlvbiAoIG1vZHVsZSwgZXhwb3J0cyApIHtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZ2V0VmFsdWUoIG9iamVjdCwga2V5ICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGdldFZhbHVlO1xuXG5cbiAgICAgICAgICAgICAgICAvKioqL1xufSxcbi8qIDExMSAqL1xuLyoqKi8gZnVuY3Rpb24gKCBtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18gKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgY2FzdFBhdGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCAzNyApLFxuICAgICAgICAgICAgICAgICAgICBpc0FyZ3VtZW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oIDIwICksXG4gICAgICAgICAgICAgICAgICAgIGlzQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCAzICksXG4gICAgICAgICAgICAgICAgICAgIGlzSW5kZXggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCA0MCApLFxuICAgICAgICAgICAgICAgICAgICBpc0tleSA9IF9fd2VicGFja19yZXF1aXJlX18oIDggKSxcbiAgICAgICAgICAgICAgICAgICAgaXNMZW5ndGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCAyMiApLFxuICAgICAgICAgICAgICAgICAgICB0b0tleSA9IF9fd2VicGFja19yZXF1aXJlX18oIDEwICk7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBDaGVja3MgaWYgYHBhdGhgIGV4aXN0cyBvbiBgb2JqZWN0YC5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrIHByb3BlcnRpZXMuXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBoYXNQYXRoKCBvYmplY3QsIHBhdGgsIGhhc0Z1bmMgKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGggPSBpc0tleSggcGF0aCwgb2JqZWN0ICkgPyBbcGF0aF0gOiBjYXN0UGF0aCggcGF0aCApO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoICsraW5kZXggPCBsZW5ndGggKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gdG9LZXkoIHBhdGhbaW5kZXhdICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoICEoIHJlc3VsdCA9IG9iamVjdCAhPSBudWxsICYmIGhhc0Z1bmMoIG9iamVjdCwga2V5ICkgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdCA9IG9iamVjdFtrZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICggcmVzdWx0IHx8ICsraW5kZXggIT0gbGVuZ3RoICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSBvYmplY3QgPyBvYmplY3QubGVuZ3RoIDogMDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEhbGVuZ3RoICYmIGlzTGVuZ3RoKCBsZW5ndGggKSAmJiBpc0luZGV4KCBrZXksIGxlbmd0aCApICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoIGlzQXJyYXkoIG9iamVjdCApIHx8IGlzQXJndW1lbnRzKCBvYmplY3QgKSApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gaGFzUGF0aDtcblxuXG4gICAgICAgICAgICAgICAgLyoqKi9cbn0sXG4vKiAxMTIgKi9cbi8qKiovIGZ1bmN0aW9uICggbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIG5hdGl2ZUNyZWF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oIDkgKTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGhhc2guXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICAgICAqIEBuYW1lIGNsZWFyXG4gICAgICAgICAgICAgICAgICogQG1lbWJlck9mIEhhc2hcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBoYXNoQ2xlYXIoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX19kYXRhX18gPSBuYXRpdmVDcmVhdGUgPyBuYXRpdmVDcmVhdGUoIG51bGwgKSA6IHt9O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNpemUgPSAwO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gaGFzaENsZWFyO1xuXG5cbiAgICAgICAgICAgICAgICAvKioqL1xufSxcbi8qIDExMyAqL1xuLyoqKi8gZnVuY3Rpb24gKCBtb2R1bGUsIGV4cG9ydHMgKSB7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgaGFzaC5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgICAgICogQG5hbWUgZGVsZXRlXG4gICAgICAgICAgICAgICAgICogQG1lbWJlck9mIEhhc2hcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gaGFzaCBUaGUgaGFzaCB0byBtb2RpZnkuXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGhhc2hEZWxldGUoIGtleSApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuaGFzKCBrZXkgKSAmJiBkZWxldGUgdGhpcy5fX2RhdGFfX1trZXldO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBoYXNoRGVsZXRlO1xuXG5cbiAgICAgICAgICAgICAgICAvKioqL1xufSxcbi8qIDExNCAqL1xuLyoqKi8gZnVuY3Rpb24gKCBtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18gKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgbmF0aXZlQ3JlYXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXyggOSApO1xuXG4gICAgICAgICAgICAgICAgLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xuICAgICAgICAgICAgICAgIHZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuICAgICAgICAgICAgICAgIC8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbiAgICAgICAgICAgICAgICB2YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4gICAgICAgICAgICAgICAgLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG4gICAgICAgICAgICAgICAgdmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBHZXRzIHRoZSBoYXNoIHZhbHVlIGZvciBga2V5YC5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgICAgICogQG5hbWUgZ2V0XG4gICAgICAgICAgICAgICAgICogQG1lbWJlck9mIEhhc2hcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gaGFzaEdldCgga2V5ICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gICAgICAgICAgICAgICAgICAgIGlmICggbmF0aXZlQ3JlYXRlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGRhdGFba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgPT09IEhBU0hfVU5ERUZJTkVEID8gdW5kZWZpbmVkIDogcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKCBkYXRhLCBrZXkgKSA/IGRhdGFba2V5XSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGhhc2hHZXQ7XG5cblxuICAgICAgICAgICAgICAgIC8qKiovXG59LFxuLyogMTE1ICovXG4vKioqLyBmdW5jdGlvbiAoIG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyApIHtcblxuICAgICAgICAgICAgICAgIHZhciBuYXRpdmVDcmVhdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCA5ICk7XG5cbiAgICAgICAgICAgICAgICAvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG4gICAgICAgICAgICAgICAgdmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuICAgICAgICAgICAgICAgIC8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xuICAgICAgICAgICAgICAgIHZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAgICAgKiBAbmFtZSBoYXNcbiAgICAgICAgICAgICAgICAgKiBAbWVtYmVyT2YgSGFzaFxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBoYXNoSGFzKCBrZXkgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5hdGl2ZUNyZWF0ZSA/IGRhdGFba2V5XSAhPT0gdW5kZWZpbmVkIDogaGFzT3duUHJvcGVydHkuY2FsbCggZGF0YSwga2V5ICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBoYXNoSGFzO1xuXG5cbiAgICAgICAgICAgICAgICAvKioqL1xufSxcbi8qIDExNiAqL1xuLyoqKi8gZnVuY3Rpb24gKCBtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18gKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgbmF0aXZlQ3JlYXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXyggOSApO1xuXG4gICAgICAgICAgICAgICAgLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xuICAgICAgICAgICAgICAgIHZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFNldHMgdGhlIGhhc2ggYGtleWAgdG8gYHZhbHVlYC5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgICAgICogQG5hbWUgc2V0XG4gICAgICAgICAgICAgICAgICogQG1lbWJlck9mIEhhc2hcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaGFzaCBpbnN0YW5jZS5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBoYXNoU2V0KCBrZXksIHZhbHVlICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2l6ZSArPSB0aGlzLmhhcygga2V5ICkgPyAwIDogMTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtrZXldID0gKCBuYXRpdmVDcmVhdGUgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCApID8gSEFTSF9VTkRFRklORUQgOiB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBoYXNoU2V0O1xuXG5cbiAgICAgICAgICAgICAgICAvKioqL1xufSxcbi8qIDExNyAqL1xuLyoqKi8gZnVuY3Rpb24gKCBtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18gKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXyggMTYgKSxcbiAgICAgICAgICAgICAgICAgICAgaXNBcmd1bWVudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCAyMCApLFxuICAgICAgICAgICAgICAgICAgICBpc0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyggMyApO1xuXG4gICAgICAgICAgICAgICAgLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG4gICAgICAgICAgICAgICAgdmFyIHNwcmVhZGFibGVTeW1ib2wgPSBTeW1ib2wgPyBTeW1ib2wuaXNDb25jYXRTcHJlYWRhYmxlIDogdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBmbGF0dGVuYWJsZSBgYXJndW1lbnRzYCBvYmplY3Qgb3IgYXJyYXkuXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZsYXR0ZW5hYmxlLCBlbHNlIGBmYWxzZWAuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gaXNGbGF0dGVuYWJsZSggdmFsdWUgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpc0FycmF5KCB2YWx1ZSApIHx8IGlzQXJndW1lbnRzKCB2YWx1ZSApIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAhISggc3ByZWFkYWJsZVN5bWJvbCAmJiB2YWx1ZSAmJiB2YWx1ZVtzcHJlYWRhYmxlU3ltYm9sXSApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gaXNGbGF0dGVuYWJsZTtcblxuXG4gICAgICAgICAgICAgICAgLyoqKi9cbn0sXG4vKiAxMTggKi9cbi8qKiovIGZ1bmN0aW9uICggbW9kdWxlLCBleHBvcnRzICkge1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB1bmlxdWUgb2JqZWN0IGtleS5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUsIGVsc2UgYGZhbHNlYC5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBpc0tleWFibGUoIHZhbHVlICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICggdHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicgKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyAoIHZhbHVlICE9PSAnX19wcm90b19fJyApXG4gICAgICAgICAgICAgICAgICAgICAgICA6ICggdmFsdWUgPT09IG51bGwgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGlzS2V5YWJsZTtcblxuXG4gICAgICAgICAgICAgICAgLyoqKi9cbn0sXG4vKiAxMTkgKi9cbi8qKiovIGZ1bmN0aW9uICggbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGNvcmVKc0RhdGEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCAxMDIgKTtcblxuICAgICAgICAgICAgICAgIC8qKiBVc2VkIHRvIGRldGVjdCBtZXRob2RzIG1hc3F1ZXJhZGluZyBhcyBuYXRpdmUuICovXG4gICAgICAgICAgICAgICAgdmFyIG1hc2tTcmNLZXkgPSAoIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVpZCA9IC9bXi5dKyQvLmV4ZWMoIGNvcmVKc0RhdGEgJiYgY29yZUpzRGF0YS5rZXlzICYmIGNvcmVKc0RhdGEua2V5cy5JRV9QUk9UTyB8fCAnJyApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdWlkID8gKCAnU3ltYm9sKHNyYylfMS4nICsgdWlkICkgOiAnJztcbiAgICAgICAgICAgICAgICB9KCkgKTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGl0cyBzb3VyY2UgbWFza2VkLlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2tlZCwgZWxzZSBgZmFsc2VgLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGlzTWFza2VkKCBmdW5jICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gISFtYXNrU3JjS2V5ICYmICggbWFza1NyY0tleSBpbiBmdW5jICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBpc01hc2tlZDtcblxuXG4gICAgICAgICAgICAgICAgLyoqKi9cbn0sXG4vKiAxMjAgKi9cbi8qKiovIGZ1bmN0aW9uICggbW9kdWxlLCBleHBvcnRzICkge1xuXG4gICAgICAgICAgICAgICAgLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xuICAgICAgICAgICAgICAgIHZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3RvdHlwZSwgZWxzZSBgZmFsc2VgLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGlzUHJvdG90eXBlKCB2YWx1ZSApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIEN0b3IgPSB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3RvID0gKCB0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlICkgfHwgb2JqZWN0UHJvdG87XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGlzUHJvdG90eXBlO1xuXG5cbiAgICAgICAgICAgICAgICAvKioqL1xufSxcbi8qIDEyMSAqL1xuLyoqKi8gZnVuY3Rpb24gKCBtb2R1bGUsIGV4cG9ydHMgKSB7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAgICAgKiBAbmFtZSBjbGVhclxuICAgICAgICAgICAgICAgICAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBsaXN0Q2FjaGVDbGVhcigpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2RhdGFfXyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNpemUgPSAwO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlQ2xlYXI7XG5cblxuICAgICAgICAgICAgICAgIC8qKiovXG59LFxuLyogMTIyICovXG4vKioqLyBmdW5jdGlvbiAoIG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyApIHtcblxuICAgICAgICAgICAgICAgIHZhciBhc3NvY0luZGV4T2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCA2ICk7XG5cbiAgICAgICAgICAgICAgICAvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG4gICAgICAgICAgICAgICAgdmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbiAgICAgICAgICAgICAgICAvKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbiAgICAgICAgICAgICAgICB2YXIgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2U7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgICAgICogQG5hbWUgZGVsZXRlXG4gICAgICAgICAgICAgICAgICogQG1lbWJlck9mIExpc3RDYWNoZVxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoIGtleSApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoIGRhdGEsIGtleSApO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggaW5kZXggPCAwICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBsYXN0SW5kZXggPSBkYXRhLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgICAgIGlmICggaW5kZXggPT0gbGFzdEluZGV4ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwbGljZS5jYWxsKCBkYXRhLCBpbmRleCwgMSApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC0tdGhpcy5zaXplO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZURlbGV0ZTtcblxuXG4gICAgICAgICAgICAgICAgLyoqKi9cbn0sXG4vKiAxMjMgKi9cbi8qKiovIGZ1bmN0aW9uICggbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGFzc29jSW5kZXhPZiA9IF9fd2VicGFja19yZXF1aXJlX18oIDYgKTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEdldHMgdGhlIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgLlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAgICAgKiBAbmFtZSBnZXRcbiAgICAgICAgICAgICAgICAgKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGxpc3RDYWNoZUdldCgga2V5ICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGFzc29jSW5kZXhPZiggZGF0YSwga2V5ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IGRhdGFbaW5kZXhdWzFdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlR2V0O1xuXG5cbiAgICAgICAgICAgICAgICAvKioqL1xufSxcbi8qIDEyNCAqL1xuLyoqKi8gZnVuY3Rpb24gKCBtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18gKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgYXNzb2NJbmRleE9mID0gX193ZWJwYWNrX3JlcXVpcmVfXyggNiApO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQ2hlY2tzIGlmIGEgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAgICAgKiBAbmFtZSBoYXNcbiAgICAgICAgICAgICAgICAgKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGxpc3RDYWNoZUhhcygga2V5ICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXNzb2NJbmRleE9mKCB0aGlzLl9fZGF0YV9fLCBrZXkgKSA+IC0xO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlSGFzO1xuXG5cbiAgICAgICAgICAgICAgICAvKioqL1xufSxcbi8qIDEyNSAqL1xuLyoqKi8gZnVuY3Rpb24gKCBtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18gKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgYXNzb2NJbmRleE9mID0gX193ZWJwYWNrX3JlcXVpcmVfXyggNiApO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogU2V0cyB0aGUgbGlzdCBjYWNoZSBga2V5YCB0byBgdmFsdWVgLlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAgICAgKiBAbmFtZSBzZXRcbiAgICAgICAgICAgICAgICAgKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGxpc3QgY2FjaGUgaW5zdGFuY2UuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gbGlzdENhY2hlU2V0KCBrZXksIHZhbHVlICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGFzc29jSW5kZXhPZiggZGF0YSwga2V5ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBpbmRleCA8IDAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICArK3RoaXMuc2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEucHVzaCggW2tleSwgdmFsdWVdICk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhW2luZGV4XVsxXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlU2V0O1xuXG5cbiAgICAgICAgICAgICAgICAvKioqL1xufSxcbi8qIDEyNiAqL1xuLyoqKi8gZnVuY3Rpb24gKCBtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18gKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgSGFzaCA9IF9fd2VicGFja19yZXF1aXJlX18oIDcwICksXG4gICAgICAgICAgICAgICAgICAgIExpc3RDYWNoZSA9IF9fd2VicGFja19yZXF1aXJlX18oIDUgKSxcbiAgICAgICAgICAgICAgICAgICAgTWFwID0gX193ZWJwYWNrX3JlcXVpcmVfXyggMTMgKTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIG1hcC5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgICAgICogQG5hbWUgY2xlYXJcbiAgICAgICAgICAgICAgICAgKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBtYXBDYWNoZUNsZWFyKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNpemUgPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fZGF0YV9fID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2hhc2gnOiBuZXcgSGFzaCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXAnOiBuZXcgKCBNYXAgfHwgTGlzdENhY2hlICksXG4gICAgICAgICAgICAgICAgICAgICAgICAnc3RyaW5nJzogbmV3IEhhc2hcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlQ2xlYXI7XG5cblxuICAgICAgICAgICAgICAgIC8qKiovXG59LFxuLyogMTI3ICovXG4vKioqLyBmdW5jdGlvbiAoIG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyApIHtcblxuICAgICAgICAgICAgICAgIHZhciBnZXRNYXBEYXRhID0gX193ZWJwYWNrX3JlcXVpcmVfXyggNyApO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIG1hcC5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgICAgICogQG5hbWUgZGVsZXRlXG4gICAgICAgICAgICAgICAgICogQG1lbWJlck9mIE1hcENhY2hlXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIG1hcENhY2hlRGVsZXRlKCBrZXkgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBnZXRNYXBEYXRhKCB0aGlzLCBrZXkgKVsnZGVsZXRlJ10oIGtleSApO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZURlbGV0ZTtcblxuXG4gICAgICAgICAgICAgICAgLyoqKi9cbn0sXG4vKiAxMjggKi9cbi8qKiovIGZ1bmN0aW9uICggbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGdldE1hcERhdGEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCA3ICk7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBHZXRzIHRoZSBtYXAgdmFsdWUgZm9yIGBrZXlgLlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAgICAgKiBAbmFtZSBnZXRcbiAgICAgICAgICAgICAgICAgKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gbWFwQ2FjaGVHZXQoIGtleSApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldE1hcERhdGEoIHRoaXMsIGtleSApLmdldCgga2V5ICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUdldDtcblxuXG4gICAgICAgICAgICAgICAgLyoqKi9cbn0sXG4vKiAxMjkgKi9cbi8qKiovIGZ1bmN0aW9uICggbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGdldE1hcERhdGEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCA3ICk7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBDaGVja3MgaWYgYSBtYXAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgICAgICogQG5hbWUgaGFzXG4gICAgICAgICAgICAgICAgICogQG1lbWJlck9mIE1hcENhY2hlXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIG1hcENhY2hlSGFzKCBrZXkgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRNYXBEYXRhKCB0aGlzLCBrZXkgKS5oYXMoIGtleSApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVIYXM7XG5cblxuICAgICAgICAgICAgICAgIC8qKiovXG59LFxuLyogMTMwICovXG4vKioqLyBmdW5jdGlvbiAoIG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyApIHtcblxuICAgICAgICAgICAgICAgIHZhciBnZXRNYXBEYXRhID0gX193ZWJwYWNrX3JlcXVpcmVfXyggNyApO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICAgICAqIEBuYW1lIHNldFxuICAgICAgICAgICAgICAgICAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBtYXAgY2FjaGUgaW5zdGFuY2UuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gbWFwQ2FjaGVTZXQoIGtleSwgdmFsdWUgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gZ2V0TWFwRGF0YSggdGhpcywga2V5ICksXG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplID0gZGF0YS5zaXplO1xuXG4gICAgICAgICAgICAgICAgICAgIGRhdGEuc2V0KCBrZXksIHZhbHVlICk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2l6ZSArPSBkYXRhLnNpemUgPT0gc2l6ZSA/IDAgOiAxO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlU2V0O1xuXG5cbiAgICAgICAgICAgICAgICAvKioqL1xufSxcbi8qIDEzMSAqL1xuLyoqKi8gZnVuY3Rpb24gKCBtb2R1bGUsIGV4cG9ydHMgKSB7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBDb252ZXJ0cyBgbWFwYCB0byBpdHMga2V5LXZhbHVlIHBhaXJzLlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gY29udmVydC5cbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBtYXBUb0FycmF5KCBtYXAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gQXJyYXkoIG1hcC5zaXplICk7XG5cbiAgICAgICAgICAgICAgICAgICAgbWFwLmZvckVhY2goIGZ1bmN0aW9uICggdmFsdWUsIGtleSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFsrK2luZGV4XSA9IFtrZXksIHZhbHVlXTtcbiAgICAgICAgICAgICAgICAgICAgfSApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gbWFwVG9BcnJheTtcblxuXG4gICAgICAgICAgICAgICAgLyoqKi9cbn0sXG4vKiAxMzIgKi9cbi8qKiovIGZ1bmN0aW9uICggbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIG1lbW9pemUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCAxNTUgKTtcblxuICAgICAgICAgICAgICAgIC8qKiBVc2VkIGFzIHRoZSBtYXhpbXVtIG1lbW9pemUgY2FjaGUgc2l6ZS4gKi9cbiAgICAgICAgICAgICAgICB2YXIgTUFYX01FTU9JWkVfU0laRSA9IDUwMDtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tZW1vaXplYCB3aGljaCBjbGVhcnMgdGhlIG1lbW9pemVkIGZ1bmN0aW9uJ3NcbiAgICAgICAgICAgICAgICAgKiBjYWNoZSB3aGVuIGl0IGV4Y2VlZHMgYE1BWF9NRU1PSVpFX1NJWkVgLlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gbWVtb2l6ZUNhcHBlZCggZnVuYyApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG1lbW9pemUoIGZ1bmMsIGZ1bmN0aW9uICgga2V5ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBjYWNoZS5zaXplID09PSBNQVhfTUVNT0laRV9TSVpFICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlLmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICAgICAgICAgICAgICB9ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGNhY2hlID0gcmVzdWx0LmNhY2hlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gbWVtb2l6ZUNhcHBlZDtcblxuXG4gICAgICAgICAgICAgICAgLyoqKi9cbn0sXG4vKiAxMzMgKi9cbi8qKiovIGZ1bmN0aW9uICggbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGdldE5hdGl2ZSA9IF9fd2VicGFja19yZXF1aXJlX18oIDIgKTtcblxuICAgICAgICAgICAgICAgIC8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbiAgICAgICAgICAgICAgICB2YXIgbmF0aXZlRGVmaW5lUHJvcGVydHkgPSBnZXROYXRpdmUoIE9iamVjdCwgJ2RlZmluZVByb3BlcnR5JyApO1xuXG4gICAgICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBuYXRpdmVEZWZpbmVQcm9wZXJ0eTtcblxuXG4gICAgICAgICAgICAgICAgLyoqKi9cbn0sXG4vKiAxMzQgKi9cbi8qKiovIGZ1bmN0aW9uICggbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIG92ZXJBcmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCA0MyApO1xuXG4gICAgICAgICAgICAgICAgLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xuICAgICAgICAgICAgICAgIHZhciBuYXRpdmVLZXlzID0gb3ZlckFyZyggT2JqZWN0LmtleXMsIE9iamVjdCApO1xuXG4gICAgICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBuYXRpdmVLZXlzO1xuXG5cbiAgICAgICAgICAgICAgICAvKioqL1xufSxcbi8qIDEzNSAqL1xuLyoqKi8gZnVuY3Rpb24gKCBtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18gKSB7XG5cblx0LyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKCBmdW5jdGlvbiAoIG1vZHVsZSApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZyZWVHbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCAzOSApO1xuXG4gICAgICAgICAgICAgICAgICAgIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG4gICAgICAgICAgICAgICAgICAgIHZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuICAgICAgICAgICAgICAgICAgICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG4gICAgICAgICAgICAgICAgICAgIHZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbiAgICAgICAgICAgICAgICAgICAgLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbiAgICAgICAgICAgICAgICAgICAgdmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbiAgICAgICAgICAgICAgICAgICAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBwcm9jZXNzYCBmcm9tIE5vZGUuanMuICovXG4gICAgICAgICAgICAgICAgICAgIHZhciBmcmVlUHJvY2VzcyA9IG1vZHVsZUV4cG9ydHMgJiYgZnJlZUdsb2JhbC5wcm9jZXNzO1xuXG4gICAgICAgICAgICAgICAgICAgIC8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL1xuICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZVV0aWwgPSAoIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZyZWVQcm9jZXNzICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcoICd1dGlsJyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoIGUgKSB7IH1cbiAgICAgICAgICAgICAgICAgICAgfSgpICk7XG5cbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBub2RlVXRpbDtcblxuICAgICAgICAgICAgICAgICAgICAvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi9cbn0uY2FsbCggZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyggNTEgKSggbW9kdWxlICkgKSApXG5cbiAgICAgICAgICAgICAgICAvKioqL1xufSxcbi8qIDEzNiAqL1xuLyoqKi8gZnVuY3Rpb24gKCBtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18gKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgYXBwbHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCA3NCApO1xuXG4gICAgICAgICAgICAgICAgLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xuICAgICAgICAgICAgICAgIHZhciBuYXRpdmVNYXggPSBNYXRoLm1heDtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVJlc3RgIHdoaWNoIHRyYW5zZm9ybXMgdGhlIHJlc3QgYXJyYXkuXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgcmVzdCBhcnJheSB0cmFuc2Zvcm0uXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gb3ZlclJlc3QoIGZ1bmMsIHN0YXJ0LCB0cmFuc2Zvcm0gKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gbmF0aXZlTWF4KCBzdGFydCA9PT0gdW5kZWZpbmVkID8gKCBmdW5jLmxlbmd0aCAtIDEgKSA6IHN0YXJ0LCAwICk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heCggYXJncy5sZW5ndGggLSBzdGFydCwgMCApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5ID0gQXJyYXkoIGxlbmd0aCApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoICsraW5kZXggPCBsZW5ndGggKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlbaW5kZXhdID0gYXJnc1tzdGFydCArIGluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3RoZXJBcmdzID0gQXJyYXkoIHN0YXJ0ICsgMSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCArK2luZGV4IDwgc3RhcnQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3RoZXJBcmdzW2luZGV4XSA9IGFyZ3NbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgb3RoZXJBcmdzW3N0YXJ0XSA9IHRyYW5zZm9ybSggYXJyYXkgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhcHBseSggZnVuYywgdGhpcywgb3RoZXJBcmdzICk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBvdmVyUmVzdDtcblxuXG4gICAgICAgICAgICAgICAgLyoqKi9cbn0sXG4vKiAxMzcgKi9cbi8qKiovIGZ1bmN0aW9uICggbW9kdWxlLCBleHBvcnRzICkge1xuXG4gICAgICAgICAgICAgICAgLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xuICAgICAgICAgICAgICAgIHZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEFkZHMgYHZhbHVlYCB0byB0aGUgYXJyYXkgY2FjaGUuXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICAgICAqIEBuYW1lIGFkZFxuICAgICAgICAgICAgICAgICAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICAgICAgICAgICAgICAgICAqIEBhbGlhcyBwdXNoXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2FjaGUuXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2FjaGUgaW5zdGFuY2UuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gc2V0Q2FjaGVBZGQoIHZhbHVlICkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fZGF0YV9fLnNldCggdmFsdWUsIEhBU0hfVU5ERUZJTkVEICk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gc2V0Q2FjaGVBZGQ7XG5cblxuICAgICAgICAgICAgICAgIC8qKiovXG59LFxuLyogMTM4ICovXG4vKioqLyBmdW5jdGlvbiAoIG1vZHVsZSwgZXhwb3J0cyApIHtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGluIHRoZSBhcnJheSBjYWNoZS5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgICAgICogQG5hbWUgaGFzXG4gICAgICAgICAgICAgICAgICogQG1lbWJlck9mIFNldENhY2hlXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gc2V0Q2FjaGVIYXMoIHZhbHVlICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoIHZhbHVlICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBzZXRDYWNoZUhhcztcblxuXG4gICAgICAgICAgICAgICAgLyoqKi9cbn0sXG4vKiAxMzkgKi9cbi8qKiovIGZ1bmN0aW9uICggbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGJhc2VTZXRUb1N0cmluZyA9IF9fd2VicGFja19yZXF1aXJlX18oIDk4ICksXG4gICAgICAgICAgICAgICAgICAgIHNob3J0T3V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyggMTQwICk7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBTZXRzIHRoZSBgdG9TdHJpbmdgIG1ldGhvZCBvZiBgZnVuY2AgdG8gcmV0dXJuIGBzdHJpbmdgLlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5nIFRoZSBgdG9TdHJpbmdgIHJlc3VsdC5cbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHZhciBzZXRUb1N0cmluZyA9IHNob3J0T3V0KCBiYXNlU2V0VG9TdHJpbmcgKTtcblxuICAgICAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gc2V0VG9TdHJpbmc7XG5cblxuICAgICAgICAgICAgICAgIC8qKiovXG59LFxuLyogMTQwICovXG4vKioqLyBmdW5jdGlvbiAoIG1vZHVsZSwgZXhwb3J0cyApIHtcblxuICAgICAgICAgICAgICAgIC8qKiBVc2VkIHRvIGRldGVjdCBob3QgZnVuY3Rpb25zIGJ5IG51bWJlciBvZiBjYWxscyB3aXRoaW4gYSBzcGFuIG9mIG1pbGxpc2Vjb25kcy4gKi9cbiAgICAgICAgICAgICAgICB2YXIgSE9UX0NPVU5UID0gNTAwLFxuICAgICAgICAgICAgICAgICAgICBIT1RfU1BBTiA9IDE2O1xuXG4gICAgICAgICAgICAgICAgLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xuICAgICAgICAgICAgICAgIHZhciBuYXRpdmVOb3cgPSBEYXRlLm5vdztcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0J2xsIHNob3J0IG91dCBhbmQgaW52b2tlIGBpZGVudGl0eWAgaW5zdGVhZFxuICAgICAgICAgICAgICAgICAqIG9mIGBmdW5jYCB3aGVuIGl0J3MgY2FsbGVkIGBIT1RfQ09VTlRgIG9yIG1vcmUgdGltZXMgaW4gYEhPVF9TUEFOYFxuICAgICAgICAgICAgICAgICAqIG1pbGxpc2Vjb25kcy5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc2hvcnRhYmxlIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHNob3J0T3V0KCBmdW5jICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY291bnQgPSAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdENhbGxlZCA9IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdGFtcCA9IG5hdGl2ZU5vdygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbWFpbmluZyA9IEhPVF9TUEFOIC0gKCBzdGFtcCAtIGxhc3RDYWxsZWQgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdENhbGxlZCA9IHN0YW1wO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCByZW1haW5pbmcgPiAwICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggKytjb3VudCA+PSBIT1RfQ09VTlQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseSggdW5kZWZpbmVkLCBhcmd1bWVudHMgKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IHNob3J0T3V0O1xuXG5cbiAgICAgICAgICAgICAgICAvKioqL1xufSxcbi8qIDE0MSAqL1xuLyoqKi8gZnVuY3Rpb24gKCBtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18gKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgTGlzdENhY2hlID0gX193ZWJwYWNrX3JlcXVpcmVfXyggNSApO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgc3RhY2suXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICAgICAqIEBuYW1lIGNsZWFyXG4gICAgICAgICAgICAgICAgICogQG1lbWJlck9mIFN0YWNrXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gc3RhY2tDbGVhcigpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBzdGFja0NsZWFyO1xuXG5cbiAgICAgICAgICAgICAgICAvKioqL1xufSxcbi8qIDE0MiAqL1xuLyoqKi8gZnVuY3Rpb24gKCBtb2R1bGUsIGV4cG9ydHMgKSB7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgc3RhY2suXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICAgICAqIEBuYW1lIGRlbGV0ZVxuICAgICAgICAgICAgICAgICAqIEBtZW1iZXJPZiBTdGFja1xuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBzdGFja0RlbGV0ZSgga2V5ICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBkYXRhWydkZWxldGUnXSgga2V5ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gc3RhY2tEZWxldGU7XG5cblxuICAgICAgICAgICAgICAgIC8qKiovXG59LFxuLyogMTQzICovXG4vKioqLyBmdW5jdGlvbiAoIG1vZHVsZSwgZXhwb3J0cyApIHtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEdldHMgdGhlIHN0YWNrIHZhbHVlIGZvciBga2V5YC5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgICAgICogQG5hbWUgZ2V0XG4gICAgICAgICAgICAgICAgICogQG1lbWJlck9mIFN0YWNrXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHN0YWNrR2V0KCBrZXkgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9fZGF0YV9fLmdldCgga2V5ICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBzdGFja0dldDtcblxuXG4gICAgICAgICAgICAgICAgLyoqKi9cbn0sXG4vKiAxNDQgKi9cbi8qKiovIGZ1bmN0aW9uICggbW9kdWxlLCBleHBvcnRzICkge1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQ2hlY2tzIGlmIGEgc3RhY2sgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgICAgICogQG5hbWUgaGFzXG4gICAgICAgICAgICAgICAgICogQG1lbWJlck9mIFN0YWNrXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHN0YWNrSGFzKCBrZXkgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcygga2V5ICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBzdGFja0hhcztcblxuXG4gICAgICAgICAgICAgICAgLyoqKi9cbn0sXG4vKiAxNDUgKi9cbi8qKiovIGZ1bmN0aW9uICggbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIExpc3RDYWNoZSA9IF9fd2VicGFja19yZXF1aXJlX18oIDUgKSxcbiAgICAgICAgICAgICAgICAgICAgTWFwID0gX193ZWJwYWNrX3JlcXVpcmVfXyggMTMgKSxcbiAgICAgICAgICAgICAgICAgICAgTWFwQ2FjaGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCAxNCApO1xuXG4gICAgICAgICAgICAgICAgLyoqIFVzZWQgYXMgdGhlIHNpemUgdG8gZW5hYmxlIGxhcmdlIGFycmF5IG9wdGltaXphdGlvbnMuICovXG4gICAgICAgICAgICAgICAgdmFyIExBUkdFX0FSUkFZX1NJWkUgPSAyMDA7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBTZXRzIHRoZSBzdGFjayBga2V5YCB0byBgdmFsdWVgLlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAgICAgKiBAbmFtZSBzZXRcbiAgICAgICAgICAgICAgICAgKiBAbWVtYmVyT2YgU3RhY2tcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgc3RhY2sgY2FjaGUgaW5zdGFuY2UuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gc3RhY2tTZXQoIGtleSwgdmFsdWUgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBkYXRhIGluc3RhbmNlb2YgTGlzdENhY2hlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhaXJzID0gZGF0YS5fX2RhdGFfXztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggIU1hcCB8fCAoIHBhaXJzLmxlbmd0aCA8IExBUkdFX0FSUkFZX1NJWkUgLSAxICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFpcnMucHVzaCggW2tleSwgdmFsdWVdICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zaXplID0gKytkYXRhLnNpemU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZSggcGFpcnMgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkYXRhLnNldCgga2V5LCB2YWx1ZSApO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gc3RhY2tTZXQ7XG5cblxuICAgICAgICAgICAgICAgIC8qKiovXG59LFxuLyogMTQ2ICovXG4vKioqLyBmdW5jdGlvbiAoIG1vZHVsZSwgZXhwb3J0cyApIHtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5pbmRleE9mYCB3aGljaCBwZXJmb3JtcyBzdHJpY3QgZXF1YWxpdHlcbiAgICAgICAgICAgICAgICAgKiBjb21wYXJpc29ucyBvZiB2YWx1ZXMsIGkuZS4gYD09PWAuXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBzdHJpY3RJbmRleE9mKCBhcnJheSwgdmFsdWUsIGZyb21JbmRleCApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gZnJvbUluZGV4IC0gMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoICsraW5kZXggPCBsZW5ndGggKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGFycmF5W2luZGV4XSA9PT0gdmFsdWUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IHN0cmljdEluZGV4T2Y7XG5cblxuICAgICAgICAgICAgICAgIC8qKiovXG59LFxuLyogMTQ3ICovXG4vKioqLyBmdW5jdGlvbiAoIG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyApIHtcblxuICAgICAgICAgICAgICAgIHZhciBtZW1vaXplQ2FwcGVkID0gX193ZWJwYWNrX3JlcXVpcmVfXyggMTMyICksXG4gICAgICAgICAgICAgICAgICAgIHRvU3RyaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXyggMTU4ICk7XG5cbiAgICAgICAgICAgICAgICAvKiogVXNlZCB0byBtYXRjaCBwcm9wZXJ0eSBuYW1lcyB3aXRoaW4gcHJvcGVydHkgcGF0aHMuICovXG4gICAgICAgICAgICAgICAgdmFyIHJlTGVhZGluZ0RvdCA9IC9eXFwuLyxcbiAgICAgICAgICAgICAgICAgICAgcmVQcm9wTmFtZSA9IC9bXi5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXFxcXXxcXFxcLikqPylcXDIpXFxdfCg/PSg/OlxcLnxcXFtcXF0pKD86XFwufFxcW1xcXXwkKSkvZztcblxuICAgICAgICAgICAgICAgIC8qKiBVc2VkIHRvIG1hdGNoIGJhY2tzbGFzaGVzIGluIHByb3BlcnR5IHBhdGhzLiAqL1xuICAgICAgICAgICAgICAgIHZhciByZUVzY2FwZUNoYXIgPSAvXFxcXChcXFxcKT8vZztcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIGEgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHZhciBzdHJpbmdUb1BhdGggPSBtZW1vaXplQ2FwcGVkKCBmdW5jdGlvbiAoIHN0cmluZyApIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nID0gdG9TdHJpbmcoIHN0cmluZyApO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCByZUxlYWRpbmdEb3QudGVzdCggc3RyaW5nICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCggJycgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdHJpbmcucmVwbGFjZSggcmVQcm9wTmFtZSwgZnVuY3Rpb24gKCBtYXRjaCwgbnVtYmVyLCBxdW90ZSwgc3RyaW5nICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goIHF1b3RlID8gc3RyaW5nLnJlcGxhY2UoIHJlRXNjYXBlQ2hhciwgJyQxJyApIDogKCBudW1iZXIgfHwgbWF0Y2ggKSApO1xuICAgICAgICAgICAgICAgICAgICB9ICk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfSApO1xuXG4gICAgICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBzdHJpbmdUb1BhdGg7XG5cblxuICAgICAgICAgICAgICAgIC8qKiovXG59LFxuLyogMTQ4ICovXG4vKioqLyBmdW5jdGlvbiAoIG1vZHVsZSwgZXhwb3J0cyApIHtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYHZhbHVlYC5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAgICAgICAgICAgICAqIEBzaW5jZSAyLjQuMFxuICAgICAgICAgICAgICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcmV0dXJuIGZyb20gdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb25zdGFudCBmdW5jdGlvbi5cbiAgICAgICAgICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogdmFyIG9iamVjdHMgPSBfLnRpbWVzKDIsIF8uY29uc3RhbnQoeyAnYSc6IDEgfSkpO1xuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogY29uc29sZS5sb2cob2JqZWN0cyk7XG4gICAgICAgICAgICAgICAgICogLy8gPT4gW3sgJ2EnOiAxIH0sIHsgJ2EnOiAxIH1dXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBjb25zb2xlLmxvZyhvYmplY3RzWzBdID09PSBvYmplY3RzWzFdKTtcbiAgICAgICAgICAgICAgICAgKiAvLyA9PiB0cnVlXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gY29uc3RhbnQoIHZhbHVlICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gY29uc3RhbnQ7XG5cblxuICAgICAgICAgICAgICAgIC8qKiovXG59LFxuLyogMTQ5ICovXG4vKioqLyBmdW5jdGlvbiAoIG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyApIHtcblxuICAgICAgICAgICAgICAgIHZhciBiYXNlRGlmZmVyZW5jZSA9IF9fd2VicGFja19yZXF1aXJlX18oIDgwICksXG4gICAgICAgICAgICAgICAgICAgIGJhc2VGbGF0dGVuID0gX193ZWJwYWNrX3JlcXVpcmVfXyggMzIgKSxcbiAgICAgICAgICAgICAgICAgICAgYmFzZVJlc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCAzNSApLFxuICAgICAgICAgICAgICAgICAgICBpc0FycmF5TGlrZU9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oIDIxICk7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGBhcnJheWAgdmFsdWVzIG5vdCBpbmNsdWRlZCBpbiB0aGUgb3RoZXIgZ2l2ZW4gYXJyYXlzXG4gICAgICAgICAgICAgICAgICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgICAgICAgICAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuIFRoZSBvcmRlciBhbmQgcmVmZXJlbmNlcyBvZiByZXN1bHQgdmFsdWVzIGFyZVxuICAgICAgICAgICAgICAgICAqIGRldGVybWluZWQgYnkgdGhlIGZpcnN0IGFycmF5LlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogKipOb3RlOioqIFVubGlrZSBgXy5wdWxsQWxsYCwgdGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBhcnJheS5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAgICAgICAgICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAgICAgICAgICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gZXhjbHVkZS5cbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICAgICAgICAgICAgICogQHNlZSBfLndpdGhvdXQsIF8ueG9yXG4gICAgICAgICAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIF8uZGlmZmVyZW5jZShbMiwgMV0sIFsyLCAzXSk7XG4gICAgICAgICAgICAgICAgICogLy8gPT4gWzFdXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdmFyIGRpZmZlcmVuY2UgPSBiYXNlUmVzdCggZnVuY3Rpb24gKCBhcnJheSwgdmFsdWVzICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNBcnJheUxpa2VPYmplY3QoIGFycmF5IClcbiAgICAgICAgICAgICAgICAgICAgICAgID8gYmFzZURpZmZlcmVuY2UoIGFycmF5LCBiYXNlRmxhdHRlbiggdmFsdWVzLCAxLCBpc0FycmF5TGlrZU9iamVjdCwgdHJ1ZSApIClcbiAgICAgICAgICAgICAgICAgICAgICAgIDogW107XG4gICAgICAgICAgICAgICAgfSApO1xuXG4gICAgICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBkaWZmZXJlbmNlO1xuXG5cbiAgICAgICAgICAgICAgICAvKioqL1xufSxcbi8qIDE1MCAqL1xuLyoqKi8gZnVuY3Rpb24gKCBtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18gKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgYmFzZUdldCA9IF9fd2VicGFja19yZXF1aXJlX18oIDMzICk7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBHZXRzIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuIElmIHRoZSByZXNvbHZlZCB2YWx1ZSBpc1xuICAgICAgICAgICAgICAgICAqIGB1bmRlZmluZWRgLCB0aGUgYGRlZmF1bHRWYWx1ZWAgaXMgcmV0dXJuZWQgaW4gaXRzIHBsYWNlLlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICAgICAgICAgICAgICogQHNpbmNlIDMuNy4wXG4gICAgICAgICAgICAgICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRWYWx1ZV0gVGhlIHZhbHVlIHJldHVybmVkIGZvciBgdW5kZWZpbmVkYCByZXNvbHZlZCB2YWx1ZXMuXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICAgICAgICAgICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9XSB9O1xuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogXy5nZXQob2JqZWN0LCAnYVswXS5iLmMnKTtcbiAgICAgICAgICAgICAgICAgKiAvLyA9PiAzXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBfLmdldChvYmplY3QsIFsnYScsICcwJywgJ2InLCAnYyddKTtcbiAgICAgICAgICAgICAgICAgKiAvLyA9PiAzXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBfLmdldChvYmplY3QsICdhLmIuYycsICdkZWZhdWx0Jyk7XG4gICAgICAgICAgICAgICAgICogLy8gPT4gJ2RlZmF1bHQnXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZ2V0KCBvYmplY3QsIHBhdGgsIGRlZmF1bHRWYWx1ZSApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogYmFzZUdldCggb2JqZWN0LCBwYXRoICk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWx1ZSA6IHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGdldDtcblxuXG4gICAgICAgICAgICAgICAgLyoqKi9cbn0sXG4vKiAxNTEgKi9cbi8qKiovIGZ1bmN0aW9uICggbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGJhc2VIYXNJbiA9IF9fd2VicGFja19yZXF1aXJlX18oIDg1ICksXG4gICAgICAgICAgICAgICAgICAgIGhhc1BhdGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCAxMTEgKTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIENoZWNrcyBpZiBgcGF0aGAgaXMgYSBkaXJlY3Qgb3IgaW5oZXJpdGVkIHByb3BlcnR5IG9mIGBvYmplY3RgLlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICAgICAgICAgICAgICogQHNpbmNlIDQuMC4wXG4gICAgICAgICAgICAgICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAgICAgICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiB2YXIgb2JqZWN0ID0gXy5jcmVhdGUoeyAnYSc6IF8uY3JlYXRlKHsgJ2InOiAyIH0pIH0pO1xuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogXy5oYXNJbihvYmplY3QsICdhJyk7XG4gICAgICAgICAgICAgICAgICogLy8gPT4gdHJ1ZVxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogXy5oYXNJbihvYmplY3QsICdhLmInKTtcbiAgICAgICAgICAgICAgICAgKiAvLyA9PiB0cnVlXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBfLmhhc0luKG9iamVjdCwgWydhJywgJ2InXSk7XG4gICAgICAgICAgICAgICAgICogLy8gPT4gdHJ1ZVxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogXy5oYXNJbihvYmplY3QsICdiJyk7XG4gICAgICAgICAgICAgICAgICogLy8gPT4gZmFsc2VcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBoYXNJbiggb2JqZWN0LCBwYXRoICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgaGFzUGF0aCggb2JqZWN0LCBwYXRoLCBiYXNlSGFzSW4gKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGhhc0luO1xuXG5cbiAgICAgICAgICAgICAgICAvKioqL1xufSxcbi8qIDE1MiAqL1xuLyoqKi8gZnVuY3Rpb24gKCBtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18gKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgZ2V0UHJvdG90eXBlID0gX193ZWJwYWNrX3JlcXVpcmVfXyggMTA4ICksXG4gICAgICAgICAgICAgICAgICAgIGlzT2JqZWN0TGlrZSA9IF9fd2VicGFja19yZXF1aXJlX18oIDQgKTtcblxuICAgICAgICAgICAgICAgIC8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbiAgICAgICAgICAgICAgICB2YXIgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cbiAgICAgICAgICAgICAgICAvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG4gICAgICAgICAgICAgICAgdmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4gICAgICAgICAgICAgICAgLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xuICAgICAgICAgICAgICAgIHZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbiAgICAgICAgICAgICAgICAvKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbiAgICAgICAgICAgICAgICB2YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuICAgICAgICAgICAgICAgIC8qKiBVc2VkIHRvIGluZmVyIHRoZSBgT2JqZWN0YCBjb25zdHJ1Y3Rvci4gKi9cbiAgICAgICAgICAgICAgICB2YXIgb2JqZWN0Q3RvclN0cmluZyA9IGZ1bmNUb1N0cmluZy5jYWxsKCBPYmplY3QgKTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAgICAgICAgICAgICAgICAgKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAgICAgICAgICAgICAgICAgKiBvZiB2YWx1ZXMuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdmFyIG9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgdGhhdCBpcywgYW4gb2JqZWN0IGNyZWF0ZWQgYnkgdGhlXG4gICAgICAgICAgICAgICAgICogYE9iamVjdGAgY29uc3RydWN0b3Igb3Igb25lIHdpdGggYSBgW1tQcm90b3R5cGVdXWAgb2YgYG51bGxgLlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICAgICAgICAgICAgICogQHNpbmNlIDAuOC4wXG4gICAgICAgICAgICAgICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAgICAgICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICAgICAgICAgICAgICogICB0aGlzLmEgPSAxO1xuICAgICAgICAgICAgICAgICAqIH1cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIF8uaXNQbGFpbk9iamVjdChuZXcgRm9vKTtcbiAgICAgICAgICAgICAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogXy5pc1BsYWluT2JqZWN0KFsxLCAyLCAzXSk7XG4gICAgICAgICAgICAgICAgICogLy8gPT4gZmFsc2VcbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIF8uaXNQbGFpbk9iamVjdCh7ICd4JzogMCwgJ3knOiAwIH0pO1xuICAgICAgICAgICAgICAgICAqIC8vID0+IHRydWVcbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIF8uaXNQbGFpbk9iamVjdChPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAgICAgICAgICAgICAgICAgKiAvLyA9PiB0cnVlXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gaXNQbGFpbk9iamVjdCggdmFsdWUgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggIWlzT2JqZWN0TGlrZSggdmFsdWUgKSB8fCBvYmplY3RUb1N0cmluZy5jYWxsKCB2YWx1ZSApICE9IG9iamVjdFRhZyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvdG8gPSBnZXRQcm90b3R5cGUoIHZhbHVlICk7XG4gICAgICAgICAgICAgICAgICAgIGlmICggcHJvdG8gPT09IG51bGwgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgQ3RvciA9IGhhc093blByb3BlcnR5LmNhbGwoIHByb3RvLCAnY29uc3RydWN0b3InICkgJiYgcHJvdG8uY29uc3RydWN0b3I7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoIHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIEN0b3IgaW5zdGFuY2VvZiBDdG9yICYmIGZ1bmNUb1N0cmluZy5jYWxsKCBDdG9yICkgPT0gb2JqZWN0Q3RvclN0cmluZyApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gaXNQbGFpbk9iamVjdDtcblxuXG4gICAgICAgICAgICAgICAgLyoqKi9cbn0sXG4vKiAxNTMgKi9cbi8qKiovIGZ1bmN0aW9uICggbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGJhc2VJc1R5cGVkQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCA5MSApLFxuICAgICAgICAgICAgICAgICAgICBiYXNlVW5hcnkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCAzNiApLFxuICAgICAgICAgICAgICAgICAgICBub2RlVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oIDEzNSApO1xuXG4gICAgICAgICAgICAgICAgLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbiAgICAgICAgICAgICAgICB2YXIgbm9kZUlzVHlwZWRBcnJheSA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzVHlwZWRBcnJheTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAgICAgICAgICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAgICAgICAgICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICAgICAgICAgICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBfLmlzVHlwZWRBcnJheShuZXcgVWludDhBcnJheSk7XG4gICAgICAgICAgICAgICAgICogLy8gPT4gdHJ1ZVxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogXy5pc1R5cGVkQXJyYXkoW10pO1xuICAgICAgICAgICAgICAgICAqIC8vID0+IGZhbHNlXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdmFyIGlzVHlwZWRBcnJheSA9IG5vZGVJc1R5cGVkQXJyYXkgPyBiYXNlVW5hcnkoIG5vZGVJc1R5cGVkQXJyYXkgKSA6IGJhc2VJc1R5cGVkQXJyYXk7XG5cbiAgICAgICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGlzVHlwZWRBcnJheTtcblxuXG4gICAgICAgICAgICAgICAgLyoqKi9cbn0sXG4vKiAxNTQgKi9cbi8qKiovIGZ1bmN0aW9uICggbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGJhc2VBc3NpZ25WYWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18oIDc5ICksXG4gICAgICAgICAgICAgICAgICAgIGJhc2VGb3JPd24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCA4MyApLFxuICAgICAgICAgICAgICAgICAgICBiYXNlSXRlcmF0ZWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCA5MiApO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQ3JlYXRlcyBhbiBvYmplY3Qgd2l0aCB0aGUgc2FtZSBrZXlzIGFzIGBvYmplY3RgIGFuZCB2YWx1ZXMgZ2VuZXJhdGVkXG4gICAgICAgICAgICAgICAgICogYnkgcnVubmluZyBlYWNoIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0eSBvZiBgb2JqZWN0YCB0aHJ1XG4gICAgICAgICAgICAgICAgICogYGl0ZXJhdGVlYC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gICAgICAgICAgICAgICAgICogKHZhbHVlLCBrZXksIG9iamVjdCkuXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgICAgICogQG1lbWJlck9mIF9cbiAgICAgICAgICAgICAgICAgKiBAc2luY2UgMi40LjBcbiAgICAgICAgICAgICAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIG9iamVjdC5cbiAgICAgICAgICAgICAgICAgKiBAc2VlIF8ubWFwS2V5c1xuICAgICAgICAgICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiB2YXIgdXNlcnMgPSB7XG4gICAgICAgICAgICAgICAgICogICAnZnJlZCc6ICAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhZ2UnOiA0MCB9LFxuICAgICAgICAgICAgICAgICAqICAgJ3BlYmJsZXMnOiB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWdlJzogMSB9XG4gICAgICAgICAgICAgICAgICogfTtcbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIF8ubWFwVmFsdWVzKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLmFnZTsgfSk7XG4gICAgICAgICAgICAgICAgICogLy8gPT4geyAnZnJlZCc6IDQwLCAncGViYmxlcyc6IDEgfSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICAgICAgICAgICAgICogXy5tYXBWYWx1ZXModXNlcnMsICdhZ2UnKTtcbiAgICAgICAgICAgICAgICAgKiAvLyA9PiB7ICdmcmVkJzogNDAsICdwZWJibGVzJzogMSB9IChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gbWFwVmFsdWVzKCBvYmplY3QsIGl0ZXJhdGVlICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgICAgICAgICAgICAgIGl0ZXJhdGVlID0gYmFzZUl0ZXJhdGVlKCBpdGVyYXRlZSwgMyApO1xuXG4gICAgICAgICAgICAgICAgICAgIGJhc2VGb3JPd24oIG9iamVjdCwgZnVuY3Rpb24gKCB2YWx1ZSwga2V5LCBvYmplY3QgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiYXNlQXNzaWduVmFsdWUoIHJlc3VsdCwga2V5LCBpdGVyYXRlZSggdmFsdWUsIGtleSwgb2JqZWN0ICkgKTtcbiAgICAgICAgICAgICAgICAgICAgfSApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gbWFwVmFsdWVzO1xuXG5cbiAgICAgICAgICAgICAgICAvKioqL1xufSxcbi8qIDE1NSAqL1xuLyoqKi8gZnVuY3Rpb24gKCBtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18gKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgTWFwQ2FjaGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCAxNCApO1xuXG4gICAgICAgICAgICAgICAgLyoqIEVycm9yIG1lc3NhZ2UgY29uc3RhbnRzLiAqL1xuICAgICAgICAgICAgICAgIHZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBtZW1vaXplcyB0aGUgcmVzdWx0IG9mIGBmdW5jYC4gSWYgYHJlc29sdmVyYCBpc1xuICAgICAgICAgICAgICAgICAqIHByb3ZpZGVkLCBpdCBkZXRlcm1pbmVzIHRoZSBjYWNoZSBrZXkgZm9yIHN0b3JpbmcgdGhlIHJlc3VsdCBiYXNlZCBvbiB0aGVcbiAgICAgICAgICAgICAgICAgKiBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uLiBCeSBkZWZhdWx0LCB0aGUgZmlyc3QgYXJndW1lbnRcbiAgICAgICAgICAgICAgICAgKiBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24gaXMgdXNlZCBhcyB0aGUgbWFwIGNhY2hlIGtleS4gVGhlIGBmdW5jYFxuICAgICAgICAgICAgICAgICAqIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIG1lbW9pemVkIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogKipOb3RlOioqIFRoZSBjYWNoZSBpcyBleHBvc2VkIGFzIHRoZSBgY2FjaGVgIHByb3BlcnR5IG9uIHRoZSBtZW1vaXplZFxuICAgICAgICAgICAgICAgICAqIGZ1bmN0aW9uLiBJdHMgY3JlYXRpb24gbWF5IGJlIGN1c3RvbWl6ZWQgYnkgcmVwbGFjaW5nIHRoZSBgXy5tZW1vaXplLkNhY2hlYFxuICAgICAgICAgICAgICAgICAqIGNvbnN0cnVjdG9yIHdpdGggb25lIHdob3NlIGluc3RhbmNlcyBpbXBsZW1lbnQgdGhlXG4gICAgICAgICAgICAgICAgICogW2BNYXBgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wcm9wZXJ0aWVzLW9mLXRoZS1tYXAtcHJvdG90eXBlLW9iamVjdClcbiAgICAgICAgICAgICAgICAgKiBtZXRob2QgaW50ZXJmYWNlIG9mIGBkZWxldGVgLCBgZ2V0YCwgYGhhc2AsIGFuZCBgc2V0YC5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAgICAgICAgICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAgICAgICAgICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzb2x2ZXJdIFRoZSBmdW5jdGlvbiB0byByZXNvbHZlIHRoZSBjYWNoZSBrZXkuXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gICAgICAgICAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyIH07XG4gICAgICAgICAgICAgICAgICogdmFyIG90aGVyID0geyAnYyc6IDMsICdkJzogNCB9O1xuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogdmFyIHZhbHVlcyA9IF8ubWVtb2l6ZShfLnZhbHVlcyk7XG4gICAgICAgICAgICAgICAgICogdmFsdWVzKG9iamVjdCk7XG4gICAgICAgICAgICAgICAgICogLy8gPT4gWzEsIDJdXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiB2YWx1ZXMob3RoZXIpO1xuICAgICAgICAgICAgICAgICAqIC8vID0+IFszLCA0XVxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogb2JqZWN0LmEgPSAyO1xuICAgICAgICAgICAgICAgICAqIHZhbHVlcyhvYmplY3QpO1xuICAgICAgICAgICAgICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogLy8gTW9kaWZ5IHRoZSByZXN1bHQgY2FjaGUuXG4gICAgICAgICAgICAgICAgICogdmFsdWVzLmNhY2hlLnNldChvYmplY3QsIFsnYScsICdiJ10pO1xuICAgICAgICAgICAgICAgICAqIHZhbHVlcyhvYmplY3QpO1xuICAgICAgICAgICAgICAgICAqIC8vID0+IFsnYScsICdiJ11cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIC8vIFJlcGxhY2UgYF8ubWVtb2l6ZS5DYWNoZWAuXG4gICAgICAgICAgICAgICAgICogXy5tZW1vaXplLkNhY2hlID0gV2Vha01hcDtcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBtZW1vaXplKCBmdW5jLCByZXNvbHZlciApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCB0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nIHx8ICggcmVzb2x2ZXIgJiYgdHlwZW9mIHJlc29sdmVyICE9ICdmdW5jdGlvbicgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoIEZVTkNfRVJST1JfVEVYVCApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBtZW1vaXplZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IHJlc29sdmVyID8gcmVzb2x2ZXIuYXBwbHkoIHRoaXMsIGFyZ3MgKSA6IGFyZ3NbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUgPSBtZW1vaXplZC5jYWNoZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBjYWNoZS5oYXMoIGtleSApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZS5nZXQoIGtleSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkoIHRoaXMsIGFyZ3MgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lbW9pemVkLmNhY2hlID0gY2FjaGUuc2V0KCBrZXksIHJlc3VsdCApIHx8IGNhY2hlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgbWVtb2l6ZWQuY2FjaGUgPSBuZXcgKCBtZW1vaXplLkNhY2hlIHx8IE1hcENhY2hlICk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtZW1vaXplZDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBFeHBvc2UgYE1hcENhY2hlYC5cbiAgICAgICAgICAgICAgICBtZW1vaXplLkNhY2hlID0gTWFwQ2FjaGU7XG5cbiAgICAgICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IG1lbW9pemU7XG5cblxuICAgICAgICAgICAgICAgIC8qKiovXG59LFxuLyogMTU2ICovXG4vKioqLyBmdW5jdGlvbiAoIG1vZHVsZSwgZXhwb3J0cyApIHtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgYHVuZGVmaW5lZGAuXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgICAgICogQG1lbWJlck9mIF9cbiAgICAgICAgICAgICAgICAgKiBAc2luY2UgMi4zLjBcbiAgICAgICAgICAgICAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAgICAgICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBfLnRpbWVzKDIsIF8ubm9vcCk7XG4gICAgICAgICAgICAgICAgICogLy8gPT4gW3VuZGVmaW5lZCwgdW5kZWZpbmVkXVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIG5vb3AoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vIG9wZXJhdGlvbiBwZXJmb3JtZWQuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBub29wO1xuXG5cbiAgICAgICAgICAgICAgICAvKioqL1xufSxcbi8qIDE1NyAqL1xuLyoqKi8gZnVuY3Rpb24gKCBtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18gKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgYmFzZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyggOTYgKSxcbiAgICAgICAgICAgICAgICAgICAgYmFzZVByb3BlcnR5RGVlcCA9IF9fd2VicGFja19yZXF1aXJlX18oIDk3ICksXG4gICAgICAgICAgICAgICAgICAgIGlzS2V5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyggOCApLFxuICAgICAgICAgICAgICAgICAgICB0b0tleSA9IF9fd2VicGFja19yZXF1aXJlX18oIDEwICk7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYSBnaXZlbiBvYmplY3QuXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgICAgICogQG1lbWJlck9mIF9cbiAgICAgICAgICAgICAgICAgKiBAc2luY2UgMi40LjBcbiAgICAgICAgICAgICAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gICAgICAgICAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIHZhciBvYmplY3RzID0gW1xuICAgICAgICAgICAgICAgICAqICAgeyAnYSc6IHsgJ2InOiAyIH0gfSxcbiAgICAgICAgICAgICAgICAgKiAgIHsgJ2EnOiB7ICdiJzogMSB9IH1cbiAgICAgICAgICAgICAgICAgKiBdO1xuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogXy5tYXAob2JqZWN0cywgXy5wcm9wZXJ0eSgnYS5iJykpO1xuICAgICAgICAgICAgICAgICAqIC8vID0+IFsyLCAxXVxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogXy5tYXAoXy5zb3J0Qnkob2JqZWN0cywgXy5wcm9wZXJ0eShbJ2EnLCAnYiddKSksICdhLmInKTtcbiAgICAgICAgICAgICAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBwcm9wZXJ0eSggcGF0aCApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzS2V5KCBwYXRoICkgPyBiYXNlUHJvcGVydHkoIHRvS2V5KCBwYXRoICkgKSA6IGJhc2VQcm9wZXJ0eURlZXAoIHBhdGggKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IHByb3BlcnR5O1xuXG5cbiAgICAgICAgICAgICAgICAvKioqL1xufSxcbi8qIDE1OCAqL1xuLyoqKi8gZnVuY3Rpb24gKCBtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18gKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgYmFzZVRvU3RyaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXyggMTAwICk7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nLiBBbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWQgZm9yIGBudWxsYFxuICAgICAgICAgICAgICAgICAqIGFuZCBgdW5kZWZpbmVkYCB2YWx1ZXMuIFRoZSBzaWduIG9mIGAtMGAgaXMgcHJlc2VydmVkLlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICAgICAgICAgICAgICogQHNpbmNlIDQuMC4wXG4gICAgICAgICAgICAgICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cbiAgICAgICAgICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogXy50b1N0cmluZyhudWxsKTtcbiAgICAgICAgICAgICAgICAgKiAvLyA9PiAnJ1xuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogXy50b1N0cmluZygtMCk7XG4gICAgICAgICAgICAgICAgICogLy8gPT4gJy0wJ1xuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogXy50b1N0cmluZyhbMSwgMiwgM10pO1xuICAgICAgICAgICAgICAgICAqIC8vID0+ICcxLDIsMydcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiB0b1N0cmluZyggdmFsdWUgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiBiYXNlVG9TdHJpbmcoIHZhbHVlICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSB0b1N0cmluZztcblxuXG4gICAgICAgICAgICAgICAgLyoqKi9cbn0sXG4vKiAxNTkgKi9cbi8qKiovIGZ1bmN0aW9uICggbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGJhc2VGbGF0dGVuID0gX193ZWJwYWNrX3JlcXVpcmVfXyggMzIgKSxcbiAgICAgICAgICAgICAgICAgICAgYmFzZVJlc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCAzNSApLFxuICAgICAgICAgICAgICAgICAgICBiYXNlVW5pcSA9IF9fd2VicGFja19yZXF1aXJlX18oIDEwMSApLFxuICAgICAgICAgICAgICAgICAgICBpc0FycmF5TGlrZU9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oIDIxICk7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHVuaXF1ZSB2YWx1ZXMsIGluIG9yZGVyLCBmcm9tIGFsbCBnaXZlbiBhcnJheXMgdXNpbmdcbiAgICAgICAgICAgICAgICAgKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAgICAgICAgICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAgICAgICAgICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAgICAgICAgICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBjb21iaW5lZCB2YWx1ZXMuXG4gICAgICAgICAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIF8udW5pb24oWzJdLCBbMSwgMl0pO1xuICAgICAgICAgICAgICAgICAqIC8vID0+IFsyLCAxXVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHZhciB1bmlvbiA9IGJhc2VSZXN0KCBmdW5jdGlvbiAoIGFycmF5cyApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJhc2VVbmlxKCBiYXNlRmxhdHRlbiggYXJyYXlzLCAxLCBpc0FycmF5TGlrZU9iamVjdCwgdHJ1ZSApICk7XG4gICAgICAgICAgICAgICAgfSApO1xuXG4gICAgICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSB1bmlvbjtcblxuXG4gICAgICAgICAgICAgICAgLyoqKi9cbn0sXG4vKiAxNjAgKi9cbi8qKiovIGZ1bmN0aW9uICggbW9kdWxlLCBleHBvcnRzICkge1xuXG4gICAgICAgICAgICAgICAgLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuICAgICAgICAgICAgICAgIC8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbiAgICAgICAgICAgICAgICAvLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbiAgICAgICAgICAgICAgICAvLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4gICAgICAgICAgICAgICAgLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuICAgICAgICAgICAgICAgIC8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuICAgICAgICAgICAgICAgIC8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbiAgICAgICAgICAgICAgICAvLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1NcbiAgICAgICAgICAgICAgICAvLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gICAgICAgICAgICAgICAgLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuICAgICAgICAgICAgICAgIC8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuICAgICAgICAgICAgICAgIC8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuICAgICAgICAgICAgICAgIC8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbiAgICAgICAgICAgICAgICAvLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4gICAgICAgICAgICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgb2JqLmhhc093blByb3BlcnR5IGhhcyBiZWVuIG92ZXJyaWRkZW4sIHRoZW4gY2FsbGluZ1xuICAgICAgICAgICAgICAgIC8vIG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSB3aWxsIGJyZWFrLlxuICAgICAgICAgICAgICAgIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2pveWVudC9ub2RlL2lzc3Vlcy8xNzA3XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gaGFzT3duUHJvcGVydHkoIG9iaiwgcHJvcCApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCggb2JqLCBwcm9wICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoIHFzLCBzZXAsIGVxLCBvcHRpb25zICkge1xuICAgICAgICAgICAgICAgICAgICBzZXAgPSBzZXAgfHwgJyYnO1xuICAgICAgICAgICAgICAgICAgICBlcSA9IGVxIHx8ICc9JztcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9iaiA9IHt9O1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggdHlwZW9mIHFzICE9PSAnc3RyaW5nJyB8fCBxcy5sZW5ndGggPT09IDAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlZ2V4cCA9IC9cXCsvZztcbiAgICAgICAgICAgICAgICAgICAgcXMgPSBxcy5zcGxpdCggc2VwICk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIG1heEtleXMgPSAxMDAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMubWF4S2V5cyA9PT0gJ251bWJlcicgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhLZXlzID0gb3B0aW9ucy5tYXhLZXlzO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGxlbiA9IHFzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgLy8gbWF4S2V5cyA8PSAwIG1lYW5zIHRoYXQgd2Ugc2hvdWxkIG5vdCBsaW1pdCBrZXlzIGNvdW50XG4gICAgICAgICAgICAgICAgICAgIGlmICggbWF4S2V5cyA+IDAgJiYgbGVuID4gbWF4S2V5cyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbiA9IG1heEtleXM7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBsZW47ICsraSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4ID0gcXNbaV0ucmVwbGFjZSggcmVnZXhwLCAnJTIwJyApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkeCA9IHguaW5kZXhPZiggZXEgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrc3RyLCB2c3RyLCBrLCB2O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGlkeCA+PSAwICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtzdHIgPSB4LnN1YnN0ciggMCwgaWR4ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdnN0ciA9IHguc3Vic3RyKCBpZHggKyAxICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtzdHIgPSB4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZzdHIgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgayA9IGRlY29kZVVSSUNvbXBvbmVudCgga3N0ciApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdiA9IGRlY29kZVVSSUNvbXBvbmVudCggdnN0ciApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoICFoYXNPd25Qcm9wZXJ0eSggb2JqLCBrICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqW2tdID0gdjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIEFycmF5LmlzQXJyYXkoIG9ialtrXSApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ialtrXS5wdXNoKCB2ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ialtrXSA9IFtvYmpba10sIHZdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICAgICAgICB9O1xuXG5cbiAgICAgICAgICAgICAgICAvKioqL1xufSxcbi8qIDE2MSAqL1xuLyoqKi8gZnVuY3Rpb24gKCBtb2R1bGUsIGV4cG9ydHMgKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4gICAgICAgICAgICAgICAgLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuICAgICAgICAgICAgICAgIC8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuICAgICAgICAgICAgICAgIC8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbiAgICAgICAgICAgICAgICAvLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4gICAgICAgICAgICAgICAgLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4gICAgICAgICAgICAgICAgLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuICAgICAgICAgICAgICAgIC8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuICAgICAgICAgICAgICAgIC8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgICAgICAgICAgICAgICAvLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4gICAgICAgICAgICAgICAgLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4gICAgICAgICAgICAgICAgLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4gICAgICAgICAgICAgICAgLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuICAgICAgICAgICAgICAgIC8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbiAgICAgICAgICAgICAgICAndXNlIHN0cmljdCc7XG5cbiAgICAgICAgICAgICAgICB2YXIgc3RyaW5naWZ5UHJpbWl0aXZlID0gZnVuY3Rpb24gKCB2ICkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKCB0eXBlb2YgdiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHY7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2ID8gJ3RydWUnIDogJ2ZhbHNlJztcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNGaW5pdGUoIHYgKSA/IHYgOiAnJztcblxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoIG9iaiwgc2VwLCBlcSwgbmFtZSApIHtcbiAgICAgICAgICAgICAgICAgICAgc2VwID0gc2VwIHx8ICcmJztcbiAgICAgICAgICAgICAgICAgICAgZXEgPSBlcSB8fCAnPSc7XG4gICAgICAgICAgICAgICAgICAgIGlmICggb2JqID09PSBudWxsICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyggb2JqICkubWFwKCBmdW5jdGlvbiAoIGsgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtzID0gZW5jb2RlVVJJQ29tcG9uZW50KCBzdHJpbmdpZnlQcmltaXRpdmUoIGsgKSApICsgZXE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBBcnJheS5pc0FycmF5KCBvYmpba10gKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9ialtrXS5tYXAoIGZ1bmN0aW9uICggdiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudCggc3RyaW5naWZ5UHJpbWl0aXZlKCB2ICkgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSApLmpvaW4oIHNlcCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudCggc3RyaW5naWZ5UHJpbWl0aXZlKCBvYmpba10gKSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gKS5qb2luKCBzZXAgKTtcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhbmFtZSApIHJldHVybiAnJztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudCggc3RyaW5naWZ5UHJpbWl0aXZlKCBuYW1lICkgKSArIGVxICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudCggc3RyaW5naWZ5UHJpbWl0aXZlKCBvYmogKSApO1xuICAgICAgICAgICAgICAgIH07XG5cblxuICAgICAgICAgICAgICAgIC8qKiovXG59LFxuLyogMTYyICovXG4vKioqLyBmdW5jdGlvbiAoIG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyApIHtcblxuICAgICAgICAgICAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgICAgICAgICAgIGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgZXhwb3J0cy5JTklUX0FDVElPTiA9IGV4cG9ydHMuQWN0aW9uQ3JlYXRvcnMgPSBleHBvcnRzLkFjdGlvblR5cGVzID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICAgICAgdmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAoIHRhcmdldCApIHsgZm9yICggdmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrICkgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKCB2YXIga2V5IGluIHNvdXJjZSApIHsgaWYgKCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoIHNvdXJjZSwga2V5ICkgKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbiAgICAgICAgICAgICAgICB2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKCBvYmogKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKCBvYmogKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbiAgICAgICAgICAgICAgICBleHBvcnRzLmxpZnRBY3Rpb24gPSBsaWZ0QWN0aW9uO1xuICAgICAgICAgICAgICAgIGV4cG9ydHMubGlmdFJlZHVjZXJXaXRoID0gbGlmdFJlZHVjZXJXaXRoO1xuICAgICAgICAgICAgICAgIGV4cG9ydHMudW5saWZ0U3RhdGUgPSB1bmxpZnRTdGF0ZTtcbiAgICAgICAgICAgICAgICBleHBvcnRzLnVubGlmdFN0b3JlID0gdW5saWZ0U3RvcmU7XG4gICAgICAgICAgICAgICAgZXhwb3J0cy5kZWZhdWx0ID0gaW5zdHJ1bWVudDtcblxuICAgICAgICAgICAgICAgIHZhciBfZGlmZmVyZW5jZSA9IF9fd2VicGFja19yZXF1aXJlX18oIDE0OSApO1xuXG4gICAgICAgICAgICAgICAgdmFyIF9kaWZmZXJlbmNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoIF9kaWZmZXJlbmNlICk7XG5cbiAgICAgICAgICAgICAgICB2YXIgX3VuaW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXyggMTU5ICk7XG5cbiAgICAgICAgICAgICAgICB2YXIgX3VuaW9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoIF91bmlvbiApO1xuXG4gICAgICAgICAgICAgICAgdmFyIF9pc1BsYWluT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyggMTUyICk7XG5cbiAgICAgICAgICAgICAgICB2YXIgX2lzUGxhaW5PYmplY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdCggX2lzUGxhaW5PYmplY3QgKTtcblxuICAgICAgICAgICAgICAgIHZhciBfc3ltYm9sT2JzZXJ2YWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oIDE3NCApO1xuXG4gICAgICAgICAgICAgICAgdmFyIF9zeW1ib2xPYnNlcnZhYmxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoIF9zeW1ib2xPYnNlcnZhYmxlICk7XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KCBvYmogKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbiAgICAgICAgICAgICAgICB2YXIgQWN0aW9uVHlwZXMgPSBleHBvcnRzLkFjdGlvblR5cGVzID0ge1xuICAgICAgICAgICAgICAgICAgICBQRVJGT1JNX0FDVElPTjogJ1BFUkZPUk1fQUNUSU9OJyxcbiAgICAgICAgICAgICAgICAgICAgUkVTRVQ6ICdSRVNFVCcsXG4gICAgICAgICAgICAgICAgICAgIFJPTExCQUNLOiAnUk9MTEJBQ0snLFxuICAgICAgICAgICAgICAgICAgICBDT01NSVQ6ICdDT01NSVQnLFxuICAgICAgICAgICAgICAgICAgICBTV0VFUDogJ1NXRUVQJyxcbiAgICAgICAgICAgICAgICAgICAgVE9HR0xFX0FDVElPTjogJ1RPR0dMRV9BQ1RJT04nLFxuICAgICAgICAgICAgICAgICAgICBTRVRfQUNUSU9OU19BQ1RJVkU6ICdTRVRfQUNUSU9OU19BQ1RJVkUnLFxuICAgICAgICAgICAgICAgICAgICBKVU1QX1RPX1NUQVRFOiAnSlVNUF9UT19TVEFURScsXG4gICAgICAgICAgICAgICAgICAgIElNUE9SVF9TVEFURTogJ0lNUE9SVF9TVEFURScsXG4gICAgICAgICAgICAgICAgICAgIExPQ0tfQ0hBTkdFUzogJ0xPQ0tfQ0hBTkdFUycsXG4gICAgICAgICAgICAgICAgICAgIFBBVVNFX1JFQ09SRElORzogJ1BBVVNFX1JFQ09SRElORydcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQWN0aW9uIGNyZWF0b3JzIHRvIGNoYW5nZSB0aGUgSGlzdG9yeSBzdGF0ZS5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB2YXIgQWN0aW9uQ3JlYXRvcnMgPSBleHBvcnRzLkFjdGlvbkNyZWF0b3JzID0ge1xuICAgICAgICAgICAgICAgICAgICBwZXJmb3JtQWN0aW9uOiBmdW5jdGlvbiBwZXJmb3JtQWN0aW9uKCBhY3Rpb24gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoICEoIDAsIF9pc1BsYWluT2JqZWN0Mi5kZWZhdWx0ICkoIGFjdGlvbiApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvciggJ0FjdGlvbnMgbXVzdCBiZSBwbGFpbiBvYmplY3RzLiAnICsgJ1VzZSBjdXN0b20gbWlkZGxld2FyZSBmb3IgYXN5bmMgYWN0aW9ucy4nICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdHlwZW9mIGFjdGlvbi50eXBlID09PSAndW5kZWZpbmVkJyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoICdBY3Rpb25zIG1heSBub3QgaGF2ZSBhbiB1bmRlZmluZWQgXCJ0eXBlXCIgcHJvcGVydHkuICcgKyAnSGF2ZSB5b3UgbWlzc3BlbGxlZCBhIGNvbnN0YW50PycgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogQWN0aW9uVHlwZXMuUEVSRk9STV9BQ1RJT04sIGFjdGlvbjogYWN0aW9uLCB0aW1lc3RhbXA6IERhdGUubm93KCkgfTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogQWN0aW9uVHlwZXMuUkVTRVQsIHRpbWVzdGFtcDogRGF0ZS5ub3coKSB9O1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICByb2xsYmFjazogZnVuY3Rpb24gcm9sbGJhY2soKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB0eXBlOiBBY3Rpb25UeXBlcy5ST0xMQkFDSywgdGltZXN0YW1wOiBEYXRlLm5vdygpIH07XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGNvbW1pdDogZnVuY3Rpb24gY29tbWl0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogQWN0aW9uVHlwZXMuQ09NTUlULCB0aW1lc3RhbXA6IERhdGUubm93KCkgfTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgc3dlZXA6IGZ1bmN0aW9uIHN3ZWVwKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogQWN0aW9uVHlwZXMuU1dFRVAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgdG9nZ2xlQWN0aW9uOiBmdW5jdGlvbiB0b2dnbGVBY3Rpb24oIGlkICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogQWN0aW9uVHlwZXMuVE9HR0xFX0FDVElPTiwgaWQ6IGlkIH07XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHNldEFjdGlvbnNBY3RpdmU6IGZ1bmN0aW9uIHNldEFjdGlvbnNBY3RpdmUoIHN0YXJ0LCBlbmQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWN0aXZlID0gYXJndW1lbnRzLmxlbmd0aCA8PSAyIHx8IGFyZ3VtZW50c1syXSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGFyZ3VtZW50c1syXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogQWN0aW9uVHlwZXMuU0VUX0FDVElPTlNfQUNUSVZFLCBzdGFydDogc3RhcnQsIGVuZDogZW5kLCBhY3RpdmU6IGFjdGl2ZSB9O1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBqdW1wVG9TdGF0ZTogZnVuY3Rpb24ganVtcFRvU3RhdGUoIGluZGV4ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogQWN0aW9uVHlwZXMuSlVNUF9UT19TVEFURSwgaW5kZXg6IGluZGV4IH07XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGltcG9ydFN0YXRlOiBmdW5jdGlvbiBpbXBvcnRTdGF0ZSggbmV4dExpZnRlZFN0YXRlLCBub1JlY29tcHV0ZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IEFjdGlvblR5cGVzLklNUE9SVF9TVEFURSwgbmV4dExpZnRlZFN0YXRlOiBuZXh0TGlmdGVkU3RhdGUsIG5vUmVjb21wdXRlOiBub1JlY29tcHV0ZSB9O1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBsb2NrQ2hhbmdlczogZnVuY3Rpb24gbG9ja0NoYW5nZXMoIHN0YXR1cyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IEFjdGlvblR5cGVzLkxPQ0tfQ0hBTkdFUywgc3RhdHVzOiBzdGF0dXMgfTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcGF1c2VSZWNvcmRpbmc6IGZ1bmN0aW9uIHBhdXNlUmVjb3JkaW5nKCBzdGF0dXMgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB0eXBlOiBBY3Rpb25UeXBlcy5QQVVTRV9SRUNPUkRJTkcsIHN0YXR1czogc3RhdHVzIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgdmFyIElOSVRfQUNUSU9OID0gZXhwb3J0cy5JTklUX0FDVElPTiA9IHsgdHlwZTogJ0BASU5JVCcgfTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIENvbXB1dGVzIHRoZSBuZXh0IGVudHJ5IHdpdGggZXhjZXB0aW9ucyBjYXRjaGluZy5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBjb21wdXRlV2l0aFRyeUNhdGNoKCByZWR1Y2VyLCBhY3Rpb24sIHN0YXRlICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dFN0YXRlID0gc3RhdGU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0RXJyb3IgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0U3RhdGUgPSByZWR1Y2VyKCBzdGF0ZSwgYWN0aW9uICk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKCBlcnIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0RXJyb3IgPSBlcnIudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggKCB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZiggd2luZG93ICkgKSA9PT0gJ29iamVjdCcgJiYgKCB0eXBlb2Ygd2luZG93LmNocm9tZSAhPT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIHdpbmRvdy5wcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucHJvY2Vzcy50eXBlID09PSAncmVuZGVyZXInICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW4gQ2hyb21lLCByZXRocm93aW5nIHByb3ZpZGVzIGJldHRlciBzb3VyY2UgbWFwIHN1cHBvcnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoIGVyciApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlOiBuZXh0U3RhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogbmV4dEVycm9yXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQ29tcHV0ZXMgdGhlIG5leHQgZW50cnkgaW4gdGhlIGxvZyBieSBhcHBseWluZyBhbiBhY3Rpb24uXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gY29tcHV0ZU5leHRFbnRyeSggcmVkdWNlciwgYWN0aW9uLCBzdGF0ZSwgc2hvdWxkQ2F0Y2hFcnJvcnMgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggIXNob3VsZENhdGNoRXJyb3JzICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgc3RhdGU6IHJlZHVjZXIoIHN0YXRlLCBhY3Rpb24gKSB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb21wdXRlV2l0aFRyeUNhdGNoKCByZWR1Y2VyLCBhY3Rpb24sIHN0YXRlICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogUnVucyB0aGUgcmVkdWNlciBvbiBpbnZhbGlkYXRlZCBhY3Rpb25zIHRvIGdldCBhIGZyZXNoIGNvbXB1dGF0aW9uIGxvZy5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiByZWNvbXB1dGVTdGF0ZXMoIGNvbXB1dGVkU3RhdGVzLCBtaW5JbnZhbGlkYXRlZFN0YXRlSW5kZXgsIHJlZHVjZXIsIGNvbW1pdHRlZFN0YXRlLCBhY3Rpb25zQnlJZCwgc3RhZ2VkQWN0aW9uSWRzLCBza2lwcGVkQWN0aW9uSWRzLCBzaG91bGRDYXRjaEVycm9ycyApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gT3B0aW1pemF0aW9uOiBleGl0IGVhcmx5IGFuZCByZXR1cm4gdGhlIHNhbWUgcmVmZXJlbmNlXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHdlIGtub3cgbm90aGluZyBjb3VsZCBoYXZlIGNoYW5nZWQuXG4gICAgICAgICAgICAgICAgICAgIGlmICggIWNvbXB1dGVkU3RhdGVzIHx8IG1pbkludmFsaWRhdGVkU3RhdGVJbmRleCA9PT0gLTEgfHwgbWluSW52YWxpZGF0ZWRTdGF0ZUluZGV4ID49IGNvbXB1dGVkU3RhdGVzLmxlbmd0aCAmJiBjb21wdXRlZFN0YXRlcy5sZW5ndGggPT09IHN0YWdlZEFjdGlvbklkcy5sZW5ndGggKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29tcHV0ZWRTdGF0ZXM7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dENvbXB1dGVkU3RhdGVzID0gY29tcHV0ZWRTdGF0ZXMuc2xpY2UoIDAsIG1pbkludmFsaWRhdGVkU3RhdGVJbmRleCApO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IG1pbkludmFsaWRhdGVkU3RhdGVJbmRleDsgaSA8IHN0YWdlZEFjdGlvbklkcy5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhY3Rpb25JZCA9IHN0YWdlZEFjdGlvbklkc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhY3Rpb24gPSBhY3Rpb25zQnlJZFthY3Rpb25JZF0uYWN0aW9uO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJldmlvdXNFbnRyeSA9IG5leHRDb21wdXRlZFN0YXRlc1tpIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJldmlvdXNTdGF0ZSA9IHByZXZpb3VzRW50cnkgPyBwcmV2aW91c0VudHJ5LnN0YXRlIDogY29tbWl0dGVkU3RhdGU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzaG91bGRTa2lwID0gc2tpcHBlZEFjdGlvbklkcy5pbmRleE9mKCBhY3Rpb25JZCApID4gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW50cnkgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHNob3VsZFNraXAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50cnkgPSBwcmV2aW91c0VudHJ5O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHNob3VsZENhdGNoRXJyb3JzICYmIHByZXZpb3VzRW50cnkgJiYgcHJldmlvdXNFbnRyeS5lcnJvciApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50cnkgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZTogcHJldmlvdXNTdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiAnSW50ZXJydXB0ZWQgYnkgYW4gZXJyb3IgdXAgdGhlIGNoYWluJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5ID0gY29tcHV0ZU5leHRFbnRyeSggcmVkdWNlciwgYWN0aW9uLCBwcmV2aW91c1N0YXRlLCBzaG91bGRDYXRjaEVycm9ycyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRDb21wdXRlZFN0YXRlcy5wdXNoKCBlbnRyeSApO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5leHRDb21wdXRlZFN0YXRlcztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBMaWZ0cyBhbiBhcHAncyBhY3Rpb24gaW50byBhbiBhY3Rpb24gb24gdGhlIGxpZnRlZCBzdG9yZS5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBsaWZ0QWN0aW9uKCBhY3Rpb24gKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBBY3Rpb25DcmVhdG9ycy5wZXJmb3JtQWN0aW9uKCBhY3Rpb24gKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBDcmVhdGVzIGEgaGlzdG9yeSBzdGF0ZSByZWR1Y2VyIGZyb20gYW4gYXBwJ3MgcmVkdWNlci5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBsaWZ0UmVkdWNlcldpdGgoIHJlZHVjZXIsIGluaXRpYWxDb21taXR0ZWRTdGF0ZSwgbW9uaXRvclJlZHVjZXIsIG9wdGlvbnMgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbml0aWFsTGlmdGVkU3RhdGUgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb25pdG9yU3RhdGU6IG1vbml0b3JSZWR1Y2VyKCB1bmRlZmluZWQsIHt9ICksXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0QWN0aW9uSWQ6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb25zQnlJZDogeyAwOiBsaWZ0QWN0aW9uKCBJTklUX0FDVElPTiApIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFnZWRBY3Rpb25JZHM6IFswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNraXBwZWRBY3Rpb25JZHM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWl0dGVkU3RhdGU6IGluaXRpYWxDb21taXR0ZWRTdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTdGF0ZUluZGV4OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcHV0ZWRTdGF0ZXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNMb2NrZWQ6IG9wdGlvbnMuc2hvdWxkU3RhcnRMb2NrZWQgPT09IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1BhdXNlZDogb3B0aW9ucy5zaG91bGRSZWNvcmRDaGFuZ2VzID09PSBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBNYW5hZ2VzIGhvdyB0aGUgaGlzdG9yeSBhY3Rpb25zIG1vZGlmeSB0aGUgaGlzdG9yeSBzdGF0ZS5cbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoIGxpZnRlZFN0YXRlLCBsaWZ0ZWRBY3Rpb24gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3JlZiA9IGxpZnRlZFN0YXRlIHx8IGluaXRpYWxMaWZ0ZWRTdGF0ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1vbml0b3JTdGF0ZSA9IF9yZWYubW9uaXRvclN0YXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFjdGlvbnNCeUlkID0gX3JlZi5hY3Rpb25zQnlJZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXh0QWN0aW9uSWQgPSBfcmVmLm5leHRBY3Rpb25JZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdGFnZWRBY3Rpb25JZHMgPSBfcmVmLnN0YWdlZEFjdGlvbklkcztcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBza2lwcGVkQWN0aW9uSWRzID0gX3JlZi5za2lwcGVkQWN0aW9uSWRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbW1pdHRlZFN0YXRlID0gX3JlZi5jb21taXR0ZWRTdGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50U3RhdGVJbmRleCA9IF9yZWYuY3VycmVudFN0YXRlSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29tcHV0ZWRTdGF0ZXMgPSBfcmVmLmNvbXB1dGVkU3RhdGVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlzTG9ja2VkID0gX3JlZi5pc0xvY2tlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpc1BhdXNlZCA9IF9yZWYuaXNQYXVzZWQ7XG5cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhbGlmdGVkU3RhdGUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHJldmVudCBtdXRhdGluZyBpbml0aWFsTGlmdGVkU3RhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb25zQnlJZCA9IF9leHRlbmRzKCB7fSwgYWN0aW9uc0J5SWQgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gY29tbWl0RXhjZXNzQWN0aW9ucyggbiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBdXRvLWNvbW1pdHMgbi1udW1iZXIgb2YgZXhjZXNzIGFjdGlvbnMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV4Y2VzcyA9IG47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlkc1RvRGVsZXRlID0gc3RhZ2VkQWN0aW9uSWRzLnNsaWNlKCAxLCBleGNlc3MgKyAxICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBpZHNUb0RlbGV0ZS5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBjb21wdXRlZFN0YXRlc1tpICsgMV0uZXJyb3IgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdG9wIGlmIGVycm9yIGlzIGZvdW5kLiBDb21taXQgYWN0aW9ucyB1cCB0byBlcnJvci5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4Y2VzcyA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZHNUb0RlbGV0ZSA9IHN0YWdlZEFjdGlvbklkcy5zbGljZSggMSwgZXhjZXNzICsgMSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgYWN0aW9uc0J5SWRbaWRzVG9EZWxldGVbaV1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2tpcHBlZEFjdGlvbklkcyA9IHNraXBwZWRBY3Rpb25JZHMuZmlsdGVyKCBmdW5jdGlvbiAoIGlkICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWRzVG9EZWxldGUuaW5kZXhPZiggaWQgKSA9PT0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWdlZEFjdGlvbklkcyA9IFswXS5jb25jYXQoIHN0YWdlZEFjdGlvbklkcy5zbGljZSggZXhjZXNzICsgMSApICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tbWl0dGVkU3RhdGUgPSBjb21wdXRlZFN0YXRlc1tleGNlc3NdLnN0YXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXB1dGVkU3RhdGVzID0gY29tcHV0ZWRTdGF0ZXMuc2xpY2UoIGV4Y2VzcyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTdGF0ZUluZGV4ID0gY3VycmVudFN0YXRlSW5kZXggPiBleGNlc3MgPyBjdXJyZW50U3RhdGVJbmRleCAtIGV4Y2VzcyA6IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGNvbXB1dGVQYXVzZWRBY3Rpb24oIHNob3VsZEluaXQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9leHRlbmRzMjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb21wdXRlZFN0YXRlID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggc2hvdWxkSW5pdCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcHV0ZWRTdGF0ZSA9IGNvbXB1dGVkU3RhdGVzW2N1cnJlbnRTdGF0ZUluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9uaXRvclN0YXRlID0gbW9uaXRvclJlZHVjZXIoIG1vbml0b3JTdGF0ZSwgbGlmdGVkQWN0aW9uICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcHV0ZWRTdGF0ZSA9IGNvbXB1dGVOZXh0RW50cnkoIHJlZHVjZXIsIGxpZnRlZEFjdGlvbi5hY3Rpb24sIGNvbXB1dGVkU3RhdGVzW2N1cnJlbnRTdGF0ZUluZGV4XS5zdGF0ZSwgZmFsc2UgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhb3B0aW9ucy5wYXVzZUFjdGlvblR5cGUgfHwgbmV4dEFjdGlvbklkID09PSAxICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9uaXRvclN0YXRlOiBtb25pdG9yU3RhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb25zQnlJZDogeyAwOiBsaWZ0QWN0aW9uKCBJTklUX0FDVElPTiApIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0QWN0aW9uSWQ6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFnZWRBY3Rpb25JZHM6IFswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNraXBwZWRBY3Rpb25JZHM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tbWl0dGVkU3RhdGU6IGNvbXB1dGVkU3RhdGUuc3RhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50U3RhdGVJbmRleDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXB1dGVkU3RhdGVzOiBbY29tcHV0ZWRTdGF0ZV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0xvY2tlZDogaXNMb2NrZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1BhdXNlZDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHNob3VsZEluaXQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWdlZEFjdGlvbklkcyA9IFtdLmNvbmNhdCggc3RhZ2VkQWN0aW9uSWRzLCBbbmV4dEFjdGlvbklkXSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0QWN0aW9uSWQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFN0YXRlSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9uaXRvclN0YXRlOiBtb25pdG9yU3RhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbnNCeUlkOiBfZXh0ZW5kcygge30sIGFjdGlvbnNCeUlkLCAoIF9leHRlbmRzMiA9IHt9LCBfZXh0ZW5kczJbbmV4dEFjdGlvbklkIC0gMV0gPSBsaWZ0QWN0aW9uKCB7IHR5cGU6IG9wdGlvbnMucGF1c2VBY3Rpb25UeXBlIH0gKSwgX2V4dGVuZHMyICkgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dEFjdGlvbklkOiBuZXh0QWN0aW9uSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWdlZEFjdGlvbklkczogc3RhZ2VkQWN0aW9uSWRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBza2lwcGVkQWN0aW9uSWRzOiBza2lwcGVkQWN0aW9uSWRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21taXR0ZWRTdGF0ZTogY29tbWl0dGVkU3RhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTdGF0ZUluZGV4OiBjdXJyZW50U3RhdGVJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcHV0ZWRTdGF0ZXM6IFtdLmNvbmNhdCggY29tcHV0ZWRTdGF0ZXMuc2xpY2UoIDAsIGN1cnJlbnRTdGF0ZUluZGV4ICksIFtjb21wdXRlZFN0YXRlXSApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0xvY2tlZDogaXNMb2NrZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzUGF1c2VkOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQnkgZGVmYXVsdCwgYWdyZXNzaXZlbHkgcmVjb21wdXRlIGV2ZXJ5IHN0YXRlIHdoYXRldmVyIGhhcHBlbnMuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGhhcyBPKG4pIHBlcmZvcm1hbmNlLCBzbyB3ZSdsbCBvdmVycmlkZSB0aGlzIHRvIGEgc2Vuc2libGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHZhbHVlIHdoZW5ldmVyIHdlIGZlZWwgbGlrZSB3ZSBkb24ndCBoYXZlIHRvIHJlY29tcHV0ZSB0aGUgc3RhdGVzLlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1pbkludmFsaWRhdGVkU3RhdGVJbmRleCA9IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoIGxpZnRlZEFjdGlvbi50eXBlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQWN0aW9uVHlwZXMuUEVSRk9STV9BQ1RJT046XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggaXNMb2NrZWQgKSByZXR1cm4gbGlmdGVkU3RhdGUgfHwgaW5pdGlhbExpZnRlZFN0YXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBpc1BhdXNlZCApIHJldHVybiBjb21wdXRlUGF1c2VkQWN0aW9uKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEF1dG8tY29tbWl0IGFzIG5ldyBhY3Rpb25zIGNvbWUgaW4uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG9wdGlvbnMubWF4QWdlICYmIHN0YWdlZEFjdGlvbklkcy5sZW5ndGggPT09IG9wdGlvbnMubWF4QWdlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1pdEV4Y2Vzc0FjdGlvbnMoIDEgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBjdXJyZW50U3RhdGVJbmRleCA9PT0gc3RhZ2VkQWN0aW9uSWRzLmxlbmd0aCAtIDEgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFN0YXRlSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhY3Rpb25JZCA9IG5leHRBY3Rpb25JZCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTXV0YXRpb24hIFRoaXMgaXMgdGhlIGhvdHRlc3QgcGF0aCwgYW5kIHdlIG9wdGltaXplIG9uIHB1cnBvc2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJdCBpcyBzYWZlIGJlY2F1c2Ugd2Ugc2V0IGEgbmV3IGtleSBpbiBhIGNhY2hlIGRpY3Rpb25hcnkuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb25zQnlJZFthY3Rpb25JZF0gPSBsaWZ0ZWRBY3Rpb247XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFnZWRBY3Rpb25JZHMgPSBbXS5jb25jYXQoIHN0YWdlZEFjdGlvbklkcywgW2FjdGlvbklkXSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3B0aW1pemF0aW9uOiB3ZSBrbm93IHRoYXQgb25seSB0aGUgbmV3IGFjdGlvbiBuZWVkcyBjb21wdXRpbmcuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5JbnZhbGlkYXRlZFN0YXRlSW5kZXggPSBzdGFnZWRBY3Rpb25JZHMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBBY3Rpb25UeXBlcy5SRVNFVDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IGJhY2sgdG8gdGhlIHN0YXRlIHRoZSBzdG9yZSB3YXMgY3JlYXRlZCB3aXRoLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uc0J5SWQgPSB7IDA6IGxpZnRBY3Rpb24oIElOSVRfQUNUSU9OICkgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRBY3Rpb25JZCA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFnZWRBY3Rpb25JZHMgPSBbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBza2lwcGVkQWN0aW9uSWRzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21taXR0ZWRTdGF0ZSA9IGluaXRpYWxDb21taXR0ZWRTdGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTdGF0ZUluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXB1dGVkU3RhdGVzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQWN0aW9uVHlwZXMuQ09NTUlUOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDb25zaWRlciB0aGUgbGFzdCBjb21taXR0ZWQgc3RhdGUgdGhlIG5ldyBzdGFydGluZyBwb2ludC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNxdWFzaCBhbnkgc3RhZ2VkIGFjdGlvbnMgaW50byBhIHNpbmdsZSBjb21taXR0ZWQgc3RhdGUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb25zQnlJZCA9IHsgMDogbGlmdEFjdGlvbiggSU5JVF9BQ1RJT04gKSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dEFjdGlvbklkID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWdlZEFjdGlvbklkcyA9IFswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNraXBwZWRBY3Rpb25JZHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1pdHRlZFN0YXRlID0gY29tcHV0ZWRTdGF0ZXNbY3VycmVudFN0YXRlSW5kZXhdLnN0YXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFN0YXRlSW5kZXggPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcHV0ZWRTdGF0ZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBBY3Rpb25UeXBlcy5ST0xMQkFDSzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRm9yZ2V0IGFib3V0IGFueSBzdGFnZWQgYWN0aW9ucy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN0YXJ0IGFnYWluIGZyb20gdGhlIGxhc3QgY29tbWl0dGVkIHN0YXRlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uc0J5SWQgPSB7IDA6IGxpZnRBY3Rpb24oIElOSVRfQUNUSU9OICkgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRBY3Rpb25JZCA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFnZWRBY3Rpb25JZHMgPSBbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBza2lwcGVkQWN0aW9uSWRzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50U3RhdGVJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wdXRlZFN0YXRlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEFjdGlvblR5cGVzLlRPR0dMRV9BQ1RJT046XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfcmV0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRvZ2dsZSB3aGV0aGVyIGFuIGFjdGlvbiB3aXRoIGdpdmVuIElEIGlzIHNraXBwZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQmVpbmcgc2tpcHBlZCBtZWFucyBpdCBpcyBhIG5vLW9wIGR1cmluZyB0aGUgY29tcHV0YXRpb24uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFjdGlvbklkID0gbGlmdGVkQWN0aW9uLmlkO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gc2tpcHBlZEFjdGlvbklkcy5pbmRleE9mKCBhY3Rpb25JZCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggaW5kZXggPT09IC0xICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBza2lwcGVkQWN0aW9uSWRzID0gW2FjdGlvbklkXS5jb25jYXQoIHNraXBwZWRBY3Rpb25JZHMgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBza2lwcGVkQWN0aW9uSWRzID0gc2tpcHBlZEFjdGlvbklkcy5maWx0ZXIoIGZ1bmN0aW9uICggaWQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWQgIT09IGFjdGlvbklkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9wdGltaXphdGlvbjogd2Uga25vdyBoaXN0b3J5IGJlZm9yZSB0aGlzIGFjdGlvbiBoYXNuJ3QgY2hhbmdlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbkludmFsaWRhdGVkU3RhdGVJbmRleCA9IHN0YWdlZEFjdGlvbklkcy5pbmRleE9mKCBhY3Rpb25JZCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnYnJlYWsnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIF9yZXQgPT09ICdicmVhaycgKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQWN0aW9uVHlwZXMuU0VUX0FDVElPTlNfQUNUSVZFOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUb2dnbGUgd2hldGhlciBhbiBhY3Rpb24gd2l0aCBnaXZlbiBJRCBpcyBza2lwcGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQmVpbmcgc2tpcHBlZCBtZWFucyBpdCBpcyBhIG5vLW9wIGR1cmluZyB0aGUgY29tcHV0YXRpb24uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSBsaWZ0ZWRBY3Rpb24uc3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5kID0gbGlmdGVkQWN0aW9uLmVuZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhY3RpdmUgPSBsaWZ0ZWRBY3Rpb24uYWN0aXZlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWN0aW9uSWRzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uSWRzLnB1c2goIGkgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gaWYgKCBhY3RpdmUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2tpcHBlZEFjdGlvbklkcyA9ICggMCwgX2RpZmZlcmVuY2UyLmRlZmF1bHQgKSggc2tpcHBlZEFjdGlvbklkcywgYWN0aW9uSWRzICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNraXBwZWRBY3Rpb25JZHMgPSAoIDAsIF91bmlvbjIuZGVmYXVsdCApKCBza2lwcGVkQWN0aW9uSWRzLCBhY3Rpb25JZHMgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3B0aW1pemF0aW9uOiB3ZSBrbm93IGhpc3RvcnkgYmVmb3JlIHRoaXMgYWN0aW9uIGhhc24ndCBjaGFuZ2VkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5JbnZhbGlkYXRlZFN0YXRlSW5kZXggPSBzdGFnZWRBY3Rpb25JZHMuaW5kZXhPZiggc3RhcnQgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBBY3Rpb25UeXBlcy5KVU1QX1RPX1NUQVRFOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXaXRob3V0IHJlY29tcHV0aW5nIGFueXRoaW5nLCBtb3ZlIHRoZSBwb2ludGVyIHRoYXQgdGVsbCB1c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2hpY2ggc3RhdGUgaXMgY29uc2lkZXJlZCB0aGUgY3VycmVudCBvbmUuIFVzZWZ1bCBmb3Igc2xpZGVycy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTdGF0ZUluZGV4ID0gbGlmdGVkQWN0aW9uLmluZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3B0aW1pemF0aW9uOiB3ZSBrbm93IHRoZSBoaXN0b3J5IGhhcyBub3QgY2hhbmdlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbkludmFsaWRhdGVkU3RhdGVJbmRleCA9IEluZmluaXR5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEFjdGlvblR5cGVzLlNXRUVQOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGb3JnZXQgYW55IGFjdGlvbnMgdGhhdCBhcmUgY3VycmVudGx5IGJlaW5nIHNraXBwZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFnZWRBY3Rpb25JZHMgPSAoIDAsIF9kaWZmZXJlbmNlMi5kZWZhdWx0ICkoIHN0YWdlZEFjdGlvbklkcywgc2tpcHBlZEFjdGlvbklkcyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2tpcHBlZEFjdGlvbklkcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFN0YXRlSW5kZXggPSBNYXRoLm1pbiggY3VycmVudFN0YXRlSW5kZXgsIHN0YWdlZEFjdGlvbklkcy5sZW5ndGggLSAxICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQWN0aW9uVHlwZXMuSU1QT1JUX1NUQVRFOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIEFycmF5LmlzQXJyYXkoIGxpZnRlZEFjdGlvbi5uZXh0TGlmdGVkU3RhdGUgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZWNvbXB1dGUgYXJyYXkgb2YgYWN0aW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbnNCeUlkID0geyAwOiBsaWZ0QWN0aW9uKCBJTklUX0FDVElPTiApIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dEFjdGlvbklkID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFnZWRBY3Rpb25JZHMgPSBbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2tpcHBlZEFjdGlvbklkcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTdGF0ZUluZGV4ID0gbGlmdGVkQWN0aW9uLm5leHRMaWZ0ZWRTdGF0ZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcHV0ZWRTdGF0ZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21taXR0ZWRTdGF0ZSA9IGxpZnRlZEFjdGlvbi5wcmVsb2FkZWRTdGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5JbnZhbGlkYXRlZFN0YXRlSW5kZXggPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0ZXJhdGUgdGhyb3VnaCBhY3Rpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlmdGVkQWN0aW9uLm5leHRMaWZ0ZWRTdGF0ZS5mb3JFYWNoKCBmdW5jdGlvbiAoIGFjdGlvbiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uc0J5SWRbbmV4dEFjdGlvbklkXSA9IGxpZnRBY3Rpb24oIGFjdGlvbiApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFnZWRBY3Rpb25JZHMucHVzaCggbmV4dEFjdGlvbklkICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRBY3Rpb25JZCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9saWZ0ZWRBY3Rpb24kbmV4dExpZiA9IGxpZnRlZEFjdGlvbi5uZXh0TGlmdGVkU3RhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29tcGxldGVseSByZXBsYWNlIGV2ZXJ5dGhpbmcuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb25pdG9yU3RhdGUgPSBfbGlmdGVkQWN0aW9uJG5leHRMaWYubW9uaXRvclN0YXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbnNCeUlkID0gX2xpZnRlZEFjdGlvbiRuZXh0TGlmLmFjdGlvbnNCeUlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRBY3Rpb25JZCA9IF9saWZ0ZWRBY3Rpb24kbmV4dExpZi5uZXh0QWN0aW9uSWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhZ2VkQWN0aW9uSWRzID0gX2xpZnRlZEFjdGlvbiRuZXh0TGlmLnN0YWdlZEFjdGlvbklkcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBza2lwcGVkQWN0aW9uSWRzID0gX2xpZnRlZEFjdGlvbiRuZXh0TGlmLnNraXBwZWRBY3Rpb25JZHM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tbWl0dGVkU3RhdGUgPSBfbGlmdGVkQWN0aW9uJG5leHRMaWYuY29tbWl0dGVkU3RhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFN0YXRlSW5kZXggPSBfbGlmdGVkQWN0aW9uJG5leHRMaWYuY3VycmVudFN0YXRlSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcHV0ZWRTdGF0ZXMgPSBfbGlmdGVkQWN0aW9uJG5leHRMaWYuY29tcHV0ZWRTdGF0ZXM7XG5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggbGlmdGVkQWN0aW9uLm5vUmVjb21wdXRlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5JbnZhbGlkYXRlZFN0YXRlSW5kZXggPSBJbmZpbml0eTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBBY3Rpb25UeXBlcy5MT0NLX0NIQU5HRVM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzTG9ja2VkID0gbGlmdGVkQWN0aW9uLnN0YXR1cztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbkludmFsaWRhdGVkU3RhdGVJbmRleCA9IEluZmluaXR5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEFjdGlvblR5cGVzLlBBVVNFX1JFQ09SRElORzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNQYXVzZWQgPSBsaWZ0ZWRBY3Rpb24uc3RhdHVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBpc1BhdXNlZCApIHJldHVybiBjb21wdXRlUGF1c2VkQWN0aW9uKCB0cnVlICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5JbnZhbGlkYXRlZFN0YXRlSW5kZXggPSBJbmZpbml0eTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnQEByZWR1eC9JTklUJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBvcHRpb25zLnNob3VsZEhvdFJlbG9hZCA9PT0gZmFsc2UgJiYgbGlmdGVkU3RhdGUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxpZnRlZFN0YXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZWNvbXB1dGUgc3RhdGVzIG9uIGhvdCByZWxvYWQgYW5kIGluaXQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5JbnZhbGlkYXRlZFN0YXRlSW5kZXggPSAwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG9wdGlvbnMubWF4QWdlICYmIHN0YWdlZEFjdGlvbklkcy5sZW5ndGggPiBvcHRpb25zLm1heEFnZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdGF0ZXMgbXVzdCBiZSByZWNvbXB1dGVkIGJlZm9yZSBjb21taXR0aW5nIGV4Y2Vzcy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wdXRlZFN0YXRlcyA9IHJlY29tcHV0ZVN0YXRlcyggY29tcHV0ZWRTdGF0ZXMsIG1pbkludmFsaWRhdGVkU3RhdGVJbmRleCwgcmVkdWNlciwgY29tbWl0dGVkU3RhdGUsIGFjdGlvbnNCeUlkLCBzdGFnZWRBY3Rpb25JZHMsIHNraXBwZWRBY3Rpb25JZHMsIG9wdGlvbnMuc2hvdWxkQ2F0Y2hFcnJvcnMgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1pdEV4Y2Vzc0FjdGlvbnMoIHN0YWdlZEFjdGlvbklkcy5sZW5ndGggLSBvcHRpb25zLm1heEFnZSApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXZvaWQgZG91YmxlIGNvbXB1dGF0aW9uLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbkludmFsaWRhdGVkU3RhdGVJbmRleCA9IEluZmluaXR5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBhY3Rpb24gaXMgbm90IHJlY29nbml6ZWQsIGl0J3MgYSBtb25pdG9yIGFjdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9wdGltaXphdGlvbjogYSBtb25pdG9yIGFjdGlvbiBjYW4ndCBjaGFuZ2UgaGlzdG9yeS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbkludmFsaWRhdGVkU3RhdGVJbmRleCA9IEluZmluaXR5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcHV0ZWRTdGF0ZXMgPSByZWNvbXB1dGVTdGF0ZXMoIGNvbXB1dGVkU3RhdGVzLCBtaW5JbnZhbGlkYXRlZFN0YXRlSW5kZXgsIHJlZHVjZXIsIGNvbW1pdHRlZFN0YXRlLCBhY3Rpb25zQnlJZCwgc3RhZ2VkQWN0aW9uSWRzLCBza2lwcGVkQWN0aW9uSWRzLCBvcHRpb25zLnNob3VsZENhdGNoRXJyb3JzICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb25pdG9yU3RhdGUgPSBtb25pdG9yUmVkdWNlciggbW9uaXRvclN0YXRlLCBsaWZ0ZWRBY3Rpb24gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9uaXRvclN0YXRlOiBtb25pdG9yU3RhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uc0J5SWQ6IGFjdGlvbnNCeUlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRBY3Rpb25JZDogbmV4dEFjdGlvbklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWdlZEFjdGlvbklkczogc3RhZ2VkQWN0aW9uSWRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNraXBwZWRBY3Rpb25JZHM6IHNraXBwZWRBY3Rpb25JZHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tbWl0dGVkU3RhdGU6IGNvbW1pdHRlZFN0YXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTdGF0ZUluZGV4OiBjdXJyZW50U3RhdGVJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wdXRlZFN0YXRlczogY29tcHV0ZWRTdGF0ZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNMb2NrZWQ6IGlzTG9ja2VkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzUGF1c2VkOiBpc1BhdXNlZFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBQcm92aWRlcyBhbiBhcHAncyB2aWV3IGludG8gdGhlIHN0YXRlIG9mIHRoZSBsaWZ0ZWQgc3RvcmUuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gdW5saWZ0U3RhdGUoIGxpZnRlZFN0YXRlICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29tcHV0ZWRTdGF0ZXMgPSBsaWZ0ZWRTdGF0ZS5jb21wdXRlZFN0YXRlcztcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRTdGF0ZUluZGV4ID0gbGlmdGVkU3RhdGUuY3VycmVudFN0YXRlSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGF0ZSA9IGNvbXB1dGVkU3RhdGVzW2N1cnJlbnRTdGF0ZUluZGV4XS5zdGF0ZTtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogUHJvdmlkZXMgYW4gYXBwJ3MgdmlldyBpbnRvIHRoZSBsaWZ0ZWQgc3RvcmUuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gdW5saWZ0U3RvcmUoIGxpZnRlZFN0b3JlLCBsaWZ0UmVkdWNlciApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9leHRlbmRzMztcblxuICAgICAgICAgICAgICAgICAgICB2YXIgbGFzdERlZmluZWRTdGF0ZSA9IHZvaWQgMDtcblxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBnZXRTdGF0ZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdGF0ZSA9IHVubGlmdFN0YXRlKCBsaWZ0ZWRTdG9yZS5nZXRTdGF0ZSgpICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHN0YXRlICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdERlZmluZWRTdGF0ZSA9IHN0YXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxhc3REZWZpbmVkU3RhdGU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2V4dGVuZHMoIHt9LCBsaWZ0ZWRTdG9yZSwgKCBfZXh0ZW5kczMgPSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxpZnRlZFN0b3JlOiBsaWZ0ZWRTdG9yZSxcblxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2g6IGZ1bmN0aW9uIGRpc3BhdGNoKCBhY3Rpb24gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlmdGVkU3RvcmUuZGlzcGF0Y2goIGxpZnRBY3Rpb24oIGFjdGlvbiApICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG5cblxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0U3RhdGU6IGdldFN0YXRlLFxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlUmVkdWNlcjogZnVuY3Rpb24gcmVwbGFjZVJlZHVjZXIoIG5leHRSZWR1Y2VyICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpZnRlZFN0b3JlLnJlcGxhY2VSZWR1Y2VyKCBsaWZ0UmVkdWNlciggbmV4dFJlZHVjZXIgKSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCBfZXh0ZW5kczNbX3N5bWJvbE9ic2VydmFibGUyLmRlZmF1bHRdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9leHRlbmRzKCB7fSwgbGlmdGVkU3RvcmVbX3N5bWJvbE9ic2VydmFibGUyLmRlZmF1bHRdKCksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmU6IGZ1bmN0aW9uIHN1YnNjcmliZSggb2JzZXJ2ZXIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggKCB0eXBlb2Ygb2JzZXJ2ZXIgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKCBvYnNlcnZlciApICkgIT09ICdvYmplY3QnICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvciggJ0V4cGVjdGVkIHRoZSBvYnNlcnZlciB0byBiZSBhbiBvYmplY3QuJyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gb2JzZXJ2ZVN0YXRlKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBvYnNlcnZlci5uZXh0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLm5leHQoIGdldFN0YXRlKCkgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmVTdGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdW5zdWJzY3JpYmUgPSBsaWZ0ZWRTdG9yZS5zdWJzY3JpYmUoIG9ic2VydmVTdGF0ZSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB1bnN1YnNjcmliZTogdW5zdWJzY3JpYmUgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9ICk7XG4gICAgICAgICAgICAgICAgICAgIH0sIF9leHRlbmRzMyApICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogUmVkdXggaW5zdHJ1bWVudGF0aW9uIHN0b3JlIGVuaGFuY2VyLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGluc3RydW1lbnQoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtb25pdG9yUmVkdWNlciA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9IDogYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzFdO1xuXG4gICAgICAgICAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWVxLW51bGwgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBvcHRpb25zLm1heEFnZSAhPSBudWxsICYmIG9wdGlvbnMubWF4QWdlIDwgMiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvciggJ0RldlRvb2xzLmluc3RydW1lbnQoeyBtYXhBZ2UgfSkgb3B0aW9uLCBpZiBzcGVjaWZpZWQsICcgKyAnbWF5IG5vdCBiZSBsZXNzIHRoYW4gMi4nICk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCBjcmVhdGVTdG9yZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoIHJlZHVjZXIsIGluaXRpYWxTdGF0ZSwgZW5oYW5jZXIgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBsaWZ0UmVkdWNlciggciApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB0eXBlb2YgciAhPT0gJ2Z1bmN0aW9uJyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggciAmJiB0eXBlb2Ygci5kZWZhdWx0ID09PSAnZnVuY3Rpb24nICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvciggJ0V4cGVjdGVkIHRoZSByZWR1Y2VyIHRvIGJlIGEgZnVuY3Rpb24uICcgKyAnSW5zdGVhZCBnb3QgYW4gb2JqZWN0IHdpdGggYSBcImRlZmF1bHRcIiBmaWVsZC4gJyArICdEaWQgeW91IHBhc3MgYSBtb2R1bGUgaW5zdGVhZCBvZiB0aGUgZGVmYXVsdCBleHBvcnQ/ICcgKyAnVHJ5IHBhc3NpbmcgcmVxdWlyZSguLi4pLmRlZmF1bHQgaW5zdGVhZC4nICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoICdFeHBlY3RlZCB0aGUgcmVkdWNlciB0byBiZSBhIGZ1bmN0aW9uLicgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGlmdFJlZHVjZXJXaXRoKCByLCBpbml0aWFsU3RhdGUsIG1vbml0b3JSZWR1Y2VyLCBvcHRpb25zICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxpZnRlZFN0b3JlID0gY3JlYXRlU3RvcmUoIGxpZnRSZWR1Y2VyKCByZWR1Y2VyICksIGVuaGFuY2VyICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBsaWZ0ZWRTdG9yZS5saWZ0ZWRTdG9yZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCAnRGV2VG9vbHMgaW5zdHJ1bWVudGF0aW9uIHNob3VsZCBub3QgYmUgYXBwbGllZCBtb3JlIHRoYW4gb25jZS4gJyArICdDaGVjayB5b3VyIHN0b3JlIGNvbmZpZ3VyYXRpb24uJyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmxpZnRTdG9yZSggbGlmdGVkU3RvcmUsIGxpZnRSZWR1Y2VyICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8qKiovXG59LFxuLyogMTYzICovXG4vKioqLyBmdW5jdGlvbiAoIG1vZHVsZSwgZXhwb3J0cyApIHtcblxuXHQvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oIGZ1bmN0aW9uICggZ2xvYmFsICkge1xuICAgICAgICAgICAgICAgICAgICAndXNlIHN0cmljdCc7XG5cbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICggdGFyZ2V0ICkgeyBmb3IgKCB2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKysgKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAoIHZhciBrZXkgaW4gc291cmNlICkgeyBpZiAoIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCggc291cmNlLCBrZXkgKSApIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKCBvYmogKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKCBvYmogKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0cy5kZWZhdWx0ID0gY2F0Y2hFcnJvcnM7XG4gICAgICAgICAgICAgICAgICAgIHZhciBFUlJPUiA9ICdAQHJlbW90ZWRldi9FUlJPUic7XG5cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gY2F0Y2hFcnJvcnMoIHNlbmRFcnJvciApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggKCB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZiggd2luZG93ICkgKSA9PT0gJ29iamVjdCcgJiYgX3R5cGVvZiggd2luZG93Lm9uZXJyb3IgKSA9PT0gJ29iamVjdCcgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93Lm9uZXJyb3IgPSBmdW5jdGlvbiAoIG1lc3NhZ2UsIHVybCwgbGluZU5vLCBjb2x1bW5ObywgZXJyb3IgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlcnJvckFjdGlvbiA9IHsgdHlwZTogRVJST1IsIG1lc3NhZ2U6IG1lc3NhZ2UsIHVybDogdXJsLCBsaW5lTm86IGxpbmVObywgY29sdW1uTm86IGNvbHVtbk5vIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZXJyb3IgJiYgZXJyb3Iuc3RhY2sgKSBlcnJvckFjdGlvbi5zdGFjayA9IGVycm9yLnN0YWNrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZW5kRXJyb3IoIGVycm9yQWN0aW9uICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICggdHlwZW9mIEVycm9yVXRpbHMgIT09ICd1bmRlZmluZWQnICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEVycm9yVXRpbHMuc2V0R2xvYmFsSGFuZGxlciggZnVuY3Rpb24gKCBlcnJvciwgaXNGYXRhbCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VuZEVycm9yKCB7IHR5cGU6IEVSUk9SLCBlcnJvcjogZXJyb3IsIGlzRmF0YWw6IGlzRmF0YWwgfSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAoIHR5cGVvZiBjb25zb2xlID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZiggY29uc29sZSApICkgPT09ICdvYmplY3QnICYmIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSAnZnVuY3Rpb24nICYmICFjb25zb2xlLmJlZm9yZVJlbW90ZWRldiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmJlZm9yZVJlbW90ZWRldiA9IGNvbnNvbGUuZXJyb3IuYmluZCggY29uc29sZSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlcnJvckFjdGlvbiA9IHsgdHlwZTogRVJST1IgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvckFjdGlvbi5tZXNzYWdlID0gZXJyb3IubWVzc2FnZSA/IGVycm9yLm1lc3NhZ2UgOiBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBlcnJvci5zb3VyY2VVUkwgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvckFjdGlvbiA9IF9leHRlbmRzKCB7fSwgZXJyb3JBY3Rpb24sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VVUkw6IGVycm9yLnNvdXJjZVVSTCwgbGluZTogZXJyb3IubGluZSwgY29sdW1uOiBlcnJvci5jb2x1bW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGVycm9yLnN0YWNrICkgZXJyb3JBY3Rpb24uc3RhY2sgPSBlcnJvci5zdGFjaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VuZEVycm9yKCBlcnJvckFjdGlvbiApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmJlZm9yZVJlbW90ZWRldi5hcHBseSggbnVsbCwgYXJndW1lbnRzICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi9cbn0uY2FsbCggZXhwb3J0cywgKCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KCkgKSApIClcblxuICAgICAgICAgICAgICAgIC8qKiovXG59LFxuLyogMTY0ICovXG4vKioqLyBmdW5jdGlvbiAoIG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyApIHtcblxuICAgICAgICAgICAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgICAgICAgICAgIGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICB2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKCBvYmogKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKCBvYmogKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbiAgICAgICAgICAgICAgICB2YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICggdGFyZ2V0ICkgeyBmb3IgKCB2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKysgKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAoIHZhciBrZXkgaW4gc291cmNlICkgeyBpZiAoIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCggc291cmNlLCBrZXkgKSApIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuICAgICAgICAgICAgICAgIGV4cG9ydHMuYXJyVG9SZWdleCA9IGFyclRvUmVnZXg7XG4gICAgICAgICAgICAgICAgZXhwb3J0cy5pc0ZpbHRlcmVkID0gaXNGaWx0ZXJlZDtcbiAgICAgICAgICAgICAgICBleHBvcnRzLmZpbHRlclN0YWdlZEFjdGlvbnMgPSBmaWx0ZXJTdGFnZWRBY3Rpb25zO1xuICAgICAgICAgICAgICAgIGV4cG9ydHMuZmlsdGVyU3RhdGUgPSBmaWx0ZXJTdGF0ZTtcblxuICAgICAgICAgICAgICAgIHZhciBfbWFwVmFsdWVzID0gX193ZWJwYWNrX3JlcXVpcmVfXyggMTU0ICk7XG5cbiAgICAgICAgICAgICAgICB2YXIgX21hcFZhbHVlczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KCBfbWFwVmFsdWVzICk7XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KCBvYmogKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBhcnJUb1JlZ2V4KCB2ICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIHYgPT09ICdzdHJpbmcnID8gdiA6IHYuam9pbiggJ3wnICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZmlsdGVyQWN0aW9ucyggYWN0aW9uc0J5SWQsIGFjdGlvbnNGaWx0ZXIgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggIWFjdGlvbnNGaWx0ZXIgKSByZXR1cm4gYWN0aW9uc0J5SWQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoIDAsIF9tYXBWYWx1ZXMyLmRlZmF1bHQgKSggYWN0aW9uc0J5SWQsIGZ1bmN0aW9uICggYWN0aW9uLCBpZCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfZXh0ZW5kcygge30sIGFjdGlvbiwgeyBhY3Rpb246IGFjdGlvbnNGaWx0ZXIoIGFjdGlvbi5hY3Rpb24sIGlkICkgfSApO1xuICAgICAgICAgICAgICAgICAgICB9ICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZmlsdGVyU3RhdGVzKCBjb21wdXRlZFN0YXRlcywgc3RhdGVzRmlsdGVyICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoICFzdGF0ZXNGaWx0ZXIgKSByZXR1cm4gY29tcHV0ZWRTdGF0ZXM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb21wdXRlZFN0YXRlcy5tYXAoIGZ1bmN0aW9uICggc3RhdGUsIGlkeCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfZXh0ZW5kcygge30sIHN0YXRlLCB7IHN0YXRlOiBzdGF0ZXNGaWx0ZXIoIHN0YXRlLnN0YXRlLCBpZHggKSB9ICk7XG4gICAgICAgICAgICAgICAgICAgIH0gKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBpc0ZpbHRlcmVkKCBhY3Rpb24sIGZpbHRlcnMgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggIWZpbHRlcnMgfHwgIWFjdGlvbiApIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgd2hpdGVsaXN0ID0gZmlsdGVycy53aGl0ZWxpc3Q7XG4gICAgICAgICAgICAgICAgICAgIHZhciBibGFja2xpc3QgPSBmaWx0ZXJzLmJsYWNrbGlzdDtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgX3JlZiA9IGFjdGlvbi5hY3Rpb24gfHwgYWN0aW9uO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciB0eXBlID0gX3JlZi50eXBlO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB3aGl0ZWxpc3QgJiYgIXR5cGUubWF0Y2goIHdoaXRlbGlzdCApIHx8IGJsYWNrbGlzdCAmJiB0eXBlLm1hdGNoKCBibGFja2xpc3QgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBmaWx0ZXJTdGFnZWRBY3Rpb25zKCBzdGF0ZSwgZmlsdGVycyApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhZmlsdGVycyApIHJldHVybiBzdGF0ZTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgZmlsdGVyZWRTdGFnZWRBY3Rpb25JZHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpbHRlcmVkQ29tcHV0ZWRTdGF0ZXMgPSBbXTtcblxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5zdGFnZWRBY3Rpb25JZHMuZm9yRWFjaCggZnVuY3Rpb24gKCBpZCwgaWR4ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhaXNGaWx0ZXJlZCggc3RhdGUuYWN0aW9uc0J5SWRbaWRdLCBmaWx0ZXJzICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyZWRTdGFnZWRBY3Rpb25JZHMucHVzaCggaWQgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJlZENvbXB1dGVkU3RhdGVzLnB1c2goIHN0YXRlLmNvbXB1dGVkU3RhdGVzW2lkeF0gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSApO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfZXh0ZW5kcygge30sIHN0YXRlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFnZWRBY3Rpb25JZHM6IGZpbHRlcmVkU3RhZ2VkQWN0aW9uSWRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcHV0ZWRTdGF0ZXM6IGZpbHRlcmVkQ29tcHV0ZWRTdGF0ZXNcbiAgICAgICAgICAgICAgICAgICAgfSApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGZpbHRlclN0YXRlKCBzdGF0ZSwgdHlwZSwgbG9jYWxGaWx0ZXIsIHN0YXRlc0ZpbHRlciwgYWN0aW9uc0ZpbHRlciwgbmV4dEFjdGlvbklkICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIHR5cGUgPT09ICdBQ1RJT04nICkgcmV0dXJuICFzdGF0ZXNGaWx0ZXIgPyBzdGF0ZSA6IHN0YXRlc0ZpbHRlciggc3RhdGUsIG5leHRBY3Rpb25JZCAtIDEgKTsgZWxzZSBpZiAoIHR5cGUgIT09ICdTVEFURScgKSByZXR1cm4gc3RhdGU7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBsb2NhbEZpbHRlciApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfcmV0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaWx0ZXJlZFN0YWdlZEFjdGlvbklkcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaWx0ZXJlZENvbXB1dGVkU3RhdGVzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpbHRlcmVkQWN0aW9uc0J5SWQgPSBhY3Rpb25zRmlsdGVyICYmIHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhY3Rpb25zQnlJZCA9IHN0YXRlLmFjdGlvbnNCeUlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb21wdXRlZFN0YXRlcyA9IHN0YXRlLmNvbXB1dGVkU3RhdGVzO1xuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5zdGFnZWRBY3Rpb25JZHMuZm9yRWFjaCggZnVuY3Rpb24gKCBpZCwgaWR4ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoICFpc0ZpbHRlcmVkKCBhY3Rpb25zQnlJZFtpZF0sIGxvY2FsRmlsdGVyICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJlZFN0YWdlZEFjdGlvbklkcy5wdXNoKCBpZCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyZWRDb21wdXRlZFN0YXRlcy5wdXNoKCBzdGF0ZXNGaWx0ZXIgPyBfZXh0ZW5kcygge30sIGNvbXB1dGVkU3RhdGVzW2lkeF0sIHsgc3RhdGU6IHN0YXRlc0ZpbHRlciggY29tcHV0ZWRTdGF0ZXNbaWR4XS5zdGF0ZSwgaWR4ICkgfSApIDogY29tcHV0ZWRTdGF0ZXNbaWR4XSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBhY3Rpb25zRmlsdGVyICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlcmVkQWN0aW9uc0J5SWRbaWRdID0gX2V4dGVuZHMoIHt9LCBhY3Rpb25zQnlJZFtpZF0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBhY3Rpb25zRmlsdGVyKCBhY3Rpb25zQnlJZFtpZF0uYWN0aW9uLCBpZCApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdjogX2V4dGVuZHMoIHt9LCBzdGF0ZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uc0J5SWQ6IGZpbHRlcmVkQWN0aW9uc0J5SWQgfHwgYWN0aW9uc0J5SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFnZWRBY3Rpb25JZHM6IGZpbHRlcmVkU3RhZ2VkQWN0aW9uSWRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcHV0ZWRTdGF0ZXM6IGZpbHRlcmVkQ29tcHV0ZWRTdGF0ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0oKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAoIHR5cGVvZiBfcmV0ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZiggX3JldCApICkgPT09IFwib2JqZWN0XCIgKSByZXR1cm4gX3JldC52O1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhc3RhdGVzRmlsdGVyICYmICFhY3Rpb25zRmlsdGVyICkgcmV0dXJuIHN0YXRlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2V4dGVuZHMoIHt9LCBzdGF0ZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uc0J5SWQ6IGZpbHRlckFjdGlvbnMoIHN0YXRlLmFjdGlvbnNCeUlkLCBhY3Rpb25zRmlsdGVyICksXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wdXRlZFN0YXRlczogZmlsdGVyU3RhdGVzKCBzdGF0ZS5jb21wdXRlZFN0YXRlcywgc3RhdGVzRmlsdGVyIClcbiAgICAgICAgICAgICAgICAgICAgfSApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8qKiovXG59LFxuLyogMTY1ICovXG4vKioqLyBmdW5jdGlvbiAoIG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyApIHtcblxuICAgICAgICAgICAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgICAgICAgICAgIGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICB2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKCBvYmogKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKCBvYmogKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbiAgICAgICAgICAgICAgICBleHBvcnRzLmdlbmVyYXRlSWQgPSBnZW5lcmF0ZUlkO1xuICAgICAgICAgICAgICAgIGV4cG9ydHMuZ2V0TWV0aG9kcyA9IGdldE1ldGhvZHM7XG4gICAgICAgICAgICAgICAgZXhwb3J0cy5nZXRBY3Rpb25zQXJyYXkgPSBnZXRBY3Rpb25zQXJyYXk7XG4gICAgICAgICAgICAgICAgZXhwb3J0cy5ldmFsQWN0aW9uID0gZXZhbEFjdGlvbjtcbiAgICAgICAgICAgICAgICBleHBvcnRzLmV2YWxNZXRob2QgPSBldmFsTWV0aG9kO1xuXG4gICAgICAgICAgICAgICAgdmFyIF9nZXRQYXJhbXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCA2MCApO1xuXG4gICAgICAgICAgICAgICAgdmFyIF9nZXRQYXJhbXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdCggX2dldFBhcmFtcyApO1xuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdCggb2JqICkgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZ2VuZXJhdGVJZCgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoIDM2ICkuc3Vic3RyKCAyICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZmxhdFRyZWUoIG9iaiApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWVzcGFjZSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/ICcnIDogYXJndW1lbnRzWzFdO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBmdW5jdGlvbnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoIG9iaiApLmZvckVhY2goIGZ1bmN0aW9uICgga2V5ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb3AgPSBvYmpba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdHlwZW9mIHByb3AgPT09ICdmdW5jdGlvbicgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25zLnB1c2goIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZXNwYWNlICsgKCBrZXkgfHwgcHJvcC5uYW1lIHx8ICdhbm9ueW1vdXMnICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmM6IHByb3AsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6ICggMCwgX2dldFBhcmFtczIuZGVmYXVsdCApKCBwcm9wIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCAoIHR5cGVvZiBwcm9wID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZiggcHJvcCApICkgPT09ICdvYmplY3QnICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9ucyA9IGZ1bmN0aW9ucy5jb25jYXQoIGZsYXRUcmVlKCBwcm9wLCBuYW1lc3BhY2UgKyBrZXkgKyAnLicgKSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9ICk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbnM7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZ2V0TWV0aG9kcyggb2JqICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoICggdHlwZW9mIG9iaiA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoIG9iaiApICkgIT09ICdvYmplY3QnICkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZ1bmN0aW9ucyA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG0gPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgIGlmICggb2JqLl9fcHJvdG9fXyApIG0gPSBvYmouX19wcm90b19fLl9fcHJvdG9fXztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhbSApIG0gPSBvYmo7XG5cbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoIG0gKS5mb3JFYWNoKCBmdW5jdGlvbiAoIGtleSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm9wID0gbVtrZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB0eXBlb2YgcHJvcCA9PT0gJ2Z1bmN0aW9uJyAmJiBrZXkgIT09ICdjb25zdHJ1Y3RvcicgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhZnVuY3Rpb25zICkgZnVuY3Rpb25zID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25zLnB1c2goIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZToga2V5IHx8IHByb3AubmFtZSB8fCAnYW5vbnltb3VzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogKCAwLCBfZ2V0UGFyYW1zMi5kZWZhdWx0ICkoIHByb3AgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb25zO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGdldEFjdGlvbnNBcnJheSggYWN0aW9uQ3JlYXRvcnMgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggQXJyYXkuaXNBcnJheSggYWN0aW9uQ3JlYXRvcnMgKSApIHJldHVybiBhY3Rpb25DcmVhdG9ycztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZsYXRUcmVlKCBhY3Rpb25DcmVhdG9ycyApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLW5ldy1mdW5jICovXG4gICAgICAgICAgICAgICAgdmFyIGludGVycHJldEFyZyA9IGZ1bmN0aW9uIGludGVycHJldEFyZyggYXJnICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKCAncmV0dXJuICcgKyBhcmcgKSgpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBldmFsQXJncyggaW5BcmdzLCByZXN0QXJncyApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBpbkFyZ3MubWFwKCBpbnRlcnByZXRBcmcgKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhcmVzdEFyZ3MgKSByZXR1cm4gYXJncztcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3QgPSBpbnRlcnByZXRBcmcoIHJlc3RBcmdzICk7XG4gICAgICAgICAgICAgICAgICAgIGlmICggQXJyYXkuaXNBcnJheSggcmVzdCApICkgcmV0dXJuIGFyZ3MuY29uY2F0LmFwcGx5KCBhcmdzLCByZXN0ICk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvciggJ3Jlc3QgbXVzdCBiZSBhbiBhcnJheScgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBldmFsQWN0aW9uKCBhY3Rpb24sIGFjdGlvbkNyZWF0b3JzICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIHR5cGVvZiBhY3Rpb24gPT09ICdzdHJpbmcnICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbiggJ3JldHVybiAnICsgYWN0aW9uICkoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciBhY3Rpb25DcmVhdG9yID0gYWN0aW9uQ3JlYXRvcnNbYWN0aW9uLnNlbGVjdGVkXS5mdW5jO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IGV2YWxBcmdzKCBhY3Rpb24uYXJncywgYWN0aW9uLnJlc3QgKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjdGlvbkNyZWF0b3IuYXBwbHkoIHVuZGVmaW5lZCwgYXJncyApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGV2YWxNZXRob2QoIGFjdGlvbiwgb2JqICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIHR5cGVvZiBhY3Rpb24gPT09ICdzdHJpbmcnICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbiggJ3JldHVybiAnICsgYWN0aW9uICkuY2FsbCggb2JqICk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IGV2YWxBcmdzKCBhY3Rpb24uYXJncywgYWN0aW9uLnJlc3QgKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbiggJ2FyZ3MnLCAncmV0dXJuIHRoaXMuJyArIGFjdGlvbi5uYW1lICsgJyhhcmdzKScgKS5hcHBseSggb2JqLCBhcmdzICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgKi9cblxuICAgICAgICAgICAgICAgIC8qKiovXG59LFxuLyogMTY2ICovXG4vKioqLyBmdW5jdGlvbiAoIG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyApIHtcblxuICAgICAgICAgICAgICAgIHZhciBTQ0VtaXR0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCAxMiApLlNDRW1pdHRlcjtcblxuICAgICAgICAgICAgICAgIHZhciBTQ0NoYW5uZWwgPSBmdW5jdGlvbiAoIG5hbWUsIGNsaWVudCwgb3B0aW9ucyApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgICAgICAgICAgICAgIFNDRW1pdHRlci5jYWxsKCB0aGlzICk7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5QRU5ESU5HID0gJ3BlbmRpbmcnO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLlNVQlNDUklCRUQgPSAnc3Vic2NyaWJlZCc7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuVU5TVUJTQ1JJQkVEID0gJ3Vuc3Vic2NyaWJlZCc7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMuVU5TVUJTQ1JJQkVEO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldE9wdGlvbnMoIHRoaXMub3B0aW9ucyApO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBTQ0NoYW5uZWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggU0NFbWl0dGVyLnByb3RvdHlwZSApO1xuXG4gICAgICAgICAgICAgICAgU0NDaGFubmVsLnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24gKCBvcHRpb25zICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoICFvcHRpb25zICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMud2FpdEZvckF1dGggPSBvcHRpb25zLndhaXRGb3JBdXRoIHx8IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIG9wdGlvbnMuZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRhID0gb3B0aW9ucy5kYXRhO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIFNDQ2hhbm5lbC5wcm90b3R5cGUuZ2V0U3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXRlO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBTQ0NoYW5uZWwucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uICggb3B0aW9ucyApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGllbnQuc3Vic2NyaWJlKCB0aGlzLm5hbWUsIG9wdGlvbnMgKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgU0NDaGFubmVsLnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGllbnQudW5zdWJzY3JpYmUoIHRoaXMubmFtZSApO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBTQ0NoYW5uZWwucHJvdG90eXBlLmlzU3Vic2NyaWJlZCA9IGZ1bmN0aW9uICggaW5jbHVkZVBlbmRpbmcgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5pc1N1YnNjcmliZWQoIHRoaXMubmFtZSwgaW5jbHVkZVBlbmRpbmcgKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgU0NDaGFubmVsLnByb3RvdHlwZS5wdWJsaXNoID0gZnVuY3Rpb24gKCBkYXRhLCBjYWxsYmFjayApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGllbnQucHVibGlzaCggdGhpcy5uYW1lLCBkYXRhLCBjYWxsYmFjayApO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBTQ0NoYW5uZWwucHJvdG90eXBlLndhdGNoID0gZnVuY3Rpb24gKCBoYW5kbGVyICkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsaWVudC53YXRjaCggdGhpcy5uYW1lLCBoYW5kbGVyICk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIFNDQ2hhbm5lbC5wcm90b3R5cGUudW53YXRjaCA9IGZ1bmN0aW9uICggaGFuZGxlciApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGllbnQudW53YXRjaCggdGhpcy5uYW1lLCBoYW5kbGVyICk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIFNDQ2hhbm5lbC5wcm90b3R5cGUud2F0Y2hlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNsaWVudC53YXRjaGVycyggdGhpcy5uYW1lICk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIFNDQ2hhbm5lbC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGllbnQuZGVzdHJveUNoYW5uZWwoIHRoaXMubmFtZSApO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBtb2R1bGUuZXhwb3J0cy5TQ0NoYW5uZWwgPSBTQ0NoYW5uZWw7XG5cblxuICAgICAgICAgICAgICAgIC8qKiovXG59LFxuLyogMTY3ICovXG4vKioqLyBmdW5jdGlvbiAoIG1vZHVsZSwgZXhwb3J0cyApIHtcblxuICAgICAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzLmNyZWF0ZSA9ICggZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBGKCkgeyB9O1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoIG8gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGFyZ3VtZW50cy5sZW5ndGggIT0gMSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoICdPYmplY3QuY3JlYXRlIGltcGxlbWVudGF0aW9uIG9ubHkgYWNjZXB0cyBvbmUgcGFyYW1ldGVyLicgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIEYucHJvdG90eXBlID0gbztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSApKCk7XG5cbiAgICAgICAgICAgICAgICAvKioqL1xufSxcbi8qIDE2OCAqL1xuLyoqKi8gZnVuY3Rpb24gKCBtb2R1bGUsIGV4cG9ydHMgKSB7XG5cblx0LyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKCBmdW5jdGlvbiAoIGdsb2JhbCApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJhc2U2NENoYXJzID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXCI7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGFycmF5QnVmZmVyVG9CYXNlNjQgPSBmdW5jdGlvbiAoIGFycmF5YnVmZmVyICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoIGFycmF5YnVmZmVyICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJhc2U2NCA9ICcnO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXNlNjQgKz0gYmFzZTY0Q2hhcnNbYnl0ZXNbaV0gPj4gMl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFzZTY0ICs9IGJhc2U2NENoYXJzWyggKCBieXRlc1tpXSAmIDMgKSA8PCA0ICkgfCAoIGJ5dGVzW2kgKyAxXSA+PiA0ICldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2U2NCArPSBiYXNlNjRDaGFyc1soICggYnl0ZXNbaSArIDFdICYgMTUgKSA8PCAyICkgfCAoIGJ5dGVzW2kgKyAyXSA+PiA2ICldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2U2NCArPSBiYXNlNjRDaGFyc1tieXRlc1tpICsgMl0gJiA2M107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggKCBsZW4gJSAzICkgPT09IDIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFzZTY0ID0gYmFzZTY0LnN1YnN0cmluZyggMCwgYmFzZTY0Lmxlbmd0aCAtIDEgKSArICc9JztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIGxlbiAlIDMgPT09IDEgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFzZTY0ID0gYmFzZTY0LnN1YnN0cmluZyggMCwgYmFzZTY0Lmxlbmd0aCAtIDIgKSArICc9PSc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBiYXNlNjQ7XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGJpbmFyeVRvQmFzZTY0UmVwbGFjZXIgPSBmdW5jdGlvbiAoIGtleSwgdmFsdWUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXNlNjQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGFycmF5QnVmZmVyVG9CYXNlNjQoIHZhbHVlIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICggdHlwZW9mIEJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB2YWx1ZSBpbnN0YW5jZW9mIEJ1ZmZlciApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2U2NDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHZhbHVlLnRvU3RyaW5nKCAnYmFzZTY0JyApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgTm9kZS5qcyBjb252ZXJ0IEJ1ZmZlcnMgdG8gT2JqZWN0cyBiZWZvcmUgdGhleSBhcmUgcGFzc2VkIHRvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHJlcGxhY2VyIGZ1bmN0aW9uIC0gQmVjYXVzZSBvZiB0aGlzLCB3ZSBuZWVkIHRvIHJlaHlkcmF0ZSBCdWZmZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYmVmb3JlIHdlIGNhbiBjb252ZXJ0IHRoZW0gdG8gYmFzZTY0IHN0cmluZ3MuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB2YWx1ZSAmJiB2YWx1ZS50eXBlID09ICdCdWZmZXInICYmIHZhbHVlLmRhdGEgaW5zdGFuY2VvZiBBcnJheSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlaHlkcmF0ZWRCdWZmZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggQnVmZmVyLmZyb20gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWh5ZHJhdGVkQnVmZmVyID0gQnVmZmVyLmZyb20oIHZhbHVlLmRhdGEgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlaHlkcmF0ZWRCdWZmZXIgPSBuZXcgQnVmZmVyKCB2YWx1ZS5kYXRhICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2U2NDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHJlaHlkcmF0ZWRCdWZmZXIudG9TdHJpbmcoICdiYXNlNjQnIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRGVjb2RlIHRoZSBkYXRhIHdoaWNoIHdhcyB0cmFuc21pdHRlZCBvdmVyIHRoZSB3aXJlIHRvIGEgSmF2YVNjcmlwdCBPYmplY3QgaW4gYSBmb3JtYXQgd2hpY2ggU0MgdW5kZXJzdGFuZHMuXG4gICAgICAgICAgICAgICAgICAgIC8vIFNlZSBlbmNvZGUgZnVuY3Rpb24gYmVsb3cgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMuZGVjb2RlID0gZnVuY3Rpb24gKCBpbnB1dCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggaW5wdXQgPT0gbnVsbCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gaW5wdXQudG9TdHJpbmcoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZSggbWVzc2FnZSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoIGVyciApIHsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgIH07XG5cblxuICAgICAgICAgICAgICAgICAgICAvLyBFbmNvZGUgYSByYXcgSmF2YVNjcmlwdCBvYmplY3QgKHdoaWNoIGlzIGluIHRoZSBTQyBwcm90b2NvbCBmb3JtYXQpIGludG8gYSBmb3JtYXQgZm9yXG4gICAgICAgICAgICAgICAgICAgIC8vIHRyYW5zZmVyaW5nIGl0IG92ZXIgdGhlIHdpcmUuIEluIHRoaXMgY2FzZSwgd2UganVzdCBjb252ZXJ0IGl0IGludG8gYSBzaW1wbGUgSlNPTiBzdHJpbmcuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHlvdSB3YW50IHRvIGNyZWF0ZSB5b3VyIG93biBjdXN0b20gY29kZWMsIHlvdSBjYW4gZW5jb2RlIHRoZSBvYmplY3QgaW50byBhbnkgZm9ybWF0XG4gICAgICAgICAgICAgICAgICAgIC8vIChlLmcuIGJpbmFyeSBBcnJheUJ1ZmZlciBvciBzdHJpbmcgd2l0aCBhbnkga2luZCBvZiBjb21wcmVzc2lvbikgc28gbG9uZyBhcyB5b3VyIGRlY29kZVxuICAgICAgICAgICAgICAgICAgICAvLyBmdW5jdGlvbiBpcyBhYmxlIHRvIHJlaHlkcmF0ZSB0aGF0IG9iamVjdCBiYWNrIGludG8gaXRzIG9yaWdpbmFsIEphdmFTY3JpcHQgT2JqZWN0IGZvcm1hdFxuICAgICAgICAgICAgICAgICAgICAvLyAod2hpY2ggYWRoZXJlcyB0byB0aGUgU0MgcHJvdG9jb2wpLlxuICAgICAgICAgICAgICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL1NvY2tldENsdXN0ZXIvc29ja2V0Y2x1c3Rlci9ibG9iL21hc3Rlci9zb2NrZXRjbHVzdGVyLXByb3RvY29sLm1kXG4gICAgICAgICAgICAgICAgICAgIC8vIGZvciBkZXRhaWxzIGFib3V0IHRoZSBTQyBwcm90b2NvbC5cbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24gKCBvYmplY3QgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoIG9iamVjdCwgYmluYXJ5VG9CYXNlNjRSZXBsYWNlciApO1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL1xufS5jYWxsKCBleHBvcnRzLCAoIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0oKSApICkgKVxuXG4gICAgICAgICAgICAgICAgLyoqKi9cbn0sXG4vKiAxNjkgKi9cbi8qKiovIGZ1bmN0aW9uICggbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIFNDU29ja2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyggNTAgKTtcbiAgICAgICAgICAgICAgICB2YXIgU0NTb2NrZXRDcmVhdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyggMTcxICk7XG5cbiAgICAgICAgICAgICAgICBtb2R1bGUuZXhwb3J0cy5TQ1NvY2tldENyZWF0b3IgPSBTQ1NvY2tldENyZWF0b3I7XG4gICAgICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMuU0NTb2NrZXQgPSBTQ1NvY2tldDtcblxuICAgICAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzLlNDRW1pdHRlciA9IF9fd2VicGFja19yZXF1aXJlX18oIDEyICkuU0NFbWl0dGVyO1xuXG4gICAgICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMuY29ubmVjdCA9IGZ1bmN0aW9uICggb3B0aW9ucyApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFNDU29ja2V0Q3JlYXRvci5jb25uZWN0KCBvcHRpb25zICk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzLmRlc3Ryb3kgPSBmdW5jdGlvbiAoIG9wdGlvbnMgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTQ1NvY2tldENyZWF0b3IuZGVzdHJveSggb3B0aW9ucyApO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBtb2R1bGUuZXhwb3J0cy52ZXJzaW9uID0gJzUuMC4xMyc7XG5cblxuICAgICAgICAgICAgICAgIC8qKiovXG59LFxuLyogMTcwICovXG4vKioqLyBmdW5jdGlvbiAoIG1vZHVsZSwgZXhwb3J0cyApIHtcblxuXHQvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oIGZ1bmN0aW9uICggZ2xvYmFsICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgQXV0aEVuZ2luZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2ludGVybmFsU3RvcmFnZSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIEF1dGhFbmdpbmUucHJvdG90eXBlLl9pc0xvY2FsU3RvcmFnZUVuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXJyO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTb21lIGJyb3dzZXJzIHdpbGwgdGhyb3cgYW4gZXJyb3IgaGVyZSBpZiBsb2NhbFN0b3JhZ2UgaXMgZGlzYWJsZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2xvYmFsLmxvY2FsU3RvcmFnZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNhZmFyaSwgaW4gUHJpdmF0ZSBCcm93c2luZyBNb2RlLCBsb29rcyBsaWtlIGl0IHN1cHBvcnRzIGxvY2FsU3RvcmFnZSBidXQgYWxsIGNhbGxzIHRvIHNldEl0ZW1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aHJvdyBRdW90YUV4Y2VlZGVkRXJyb3IuIFdlJ3JlIGdvaW5nIHRvIGRldGVjdCB0aGlzIGFuZCBhdm9pZCBoYXJkIHRvIGRlYnVnIGVkZ2UgY2FzZXMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2xvYmFsLmxvY2FsU3RvcmFnZS5zZXRJdGVtKCAnX19zY0xvY2FsU3RvcmFnZVRlc3QnLCAxICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2xvYmFsLmxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCAnX19zY0xvY2FsU3RvcmFnZVRlc3QnICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoICggZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnIgPSBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFlcnI7XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgQXV0aEVuZ2luZS5wcm90b3R5cGUuc2F2ZVRva2VuID0gZnVuY3Rpb24gKCBuYW1lLCB0b2tlbiwgb3B0aW9ucywgY2FsbGJhY2sgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHRoaXMuX2lzTG9jYWxTdG9yYWdlRW5hYmxlZCgpICYmIGdsb2JhbC5sb2NhbFN0b3JhZ2UgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2xvYmFsLmxvY2FsU3RvcmFnZS5zZXRJdGVtKCBuYW1lLCB0b2tlbiApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbnRlcm5hbFN0b3JhZ2VbbmFtZV0gPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCBudWxsLCB0b2tlbiApO1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIEF1dGhFbmdpbmUucHJvdG90eXBlLnJlbW92ZVRva2VuID0gZnVuY3Rpb24gKCBuYW1lLCBjYWxsYmFjayApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0b2tlbjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2FkVG9rZW4oIG5hbWUsIGZ1bmN0aW9uICggZXJyLCBhdXRoVG9rZW4gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSBhdXRoVG9rZW47XG4gICAgICAgICAgICAgICAgICAgICAgICB9ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdGhpcy5faXNMb2NhbFN0b3JhZ2VFbmFibGVkKCkgJiYgZ2xvYmFsLmxvY2FsU3RvcmFnZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnbG9iYWwubG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oIG5hbWUgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9pbnRlcm5hbFN0b3JhZ2VbbmFtZV07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCBudWxsLCB0b2tlbiApO1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIEF1dGhFbmdpbmUucHJvdG90eXBlLmxvYWRUb2tlbiA9IGZ1bmN0aW9uICggbmFtZSwgY2FsbGJhY2sgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG9rZW47XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdGhpcy5faXNMb2NhbFN0b3JhZ2VFbmFibGVkKCkgJiYgZ2xvYmFsLmxvY2FsU3RvcmFnZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IGdsb2JhbC5sb2NhbFN0b3JhZ2UuZ2V0SXRlbSggbmFtZSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMuX2ludGVybmFsU3RvcmFnZVtuYW1lXSB8fCBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soIG51bGwsIHRva2VuICk7XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMuQXV0aEVuZ2luZSA9IEF1dGhFbmdpbmU7XG5cbiAgICAgICAgICAgICAgICAgICAgLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovXG59LmNhbGwoIGV4cG9ydHMsICggZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSgpICkgKSApXG5cbiAgICAgICAgICAgICAgICAvKioqL1xufSxcbi8qIDE3MSAqL1xuLyoqKi8gZnVuY3Rpb24gKCBtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18gKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgU0NTb2NrZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCA1MCApO1xuXG4gICAgICAgICAgICAgICAgdmFyIF9jb25uZWN0aW9ucyA9IHt9O1xuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZ2V0TXVsdGlwbGV4SWQoIG9wdGlvbnMgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm90b2NvbFByZWZpeCA9IG9wdGlvbnMuc2VjdXJlID8gJ2h0dHBzOi8vJyA6ICdodHRwOi8vJztcbiAgICAgICAgICAgICAgICAgICAgdmFyIHF1ZXJ5U3RyaW5nID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIGlmICggb3B0aW9ucy5xdWVyeSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdHlwZW9mIG9wdGlvbnMucXVlcnkgPT0gJ3N0cmluZycgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnlTdHJpbmcgPSBvcHRpb25zLnF1ZXJ5O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcXVlcnlBcnJheSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBxdWVyeU1hcCA9IG9wdGlvbnMucXVlcnk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggdmFyIGtleSBpbiBxdWVyeU1hcCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBxdWVyeU1hcC5oYXNPd25Qcm9wZXJ0eSgga2V5ICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeUFycmF5LnB1c2goIGtleSArICc9JyArIHF1ZXJ5TWFwW2tleV0gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHF1ZXJ5QXJyYXkubGVuZ3RoICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeVN0cmluZyA9ICc/JyArIHF1ZXJ5QXJyYXkuam9pbiggJyYnICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm90b2NvbFByZWZpeCArIG9wdGlvbnMuaG9zdG5hbWUgKyAnOicgKyBvcHRpb25zLnBvcnQgKyBvcHRpb25zLnBhdGggKyBxdWVyeVN0cmluZztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBjb25uZWN0KCBvcHRpb25zICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wdHMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3J0OiA4ODg4LFxuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdG5hbWU6ICdsb2NhbGhvc3QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogJy9zb2NrZXRjbHVzdGVyLycsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWN1cmU6IG9wdGlvbnMuc2VjdXJlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXV0b1JlY29ubmVjdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF1dG9Qcm9jZXNzU3Vic2NyaXB0aW9uczogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3RUaW1lb3V0OiAyMDAwMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFja1RpbWVvdXQ6IDEwMDAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wUmVxdWVzdHM6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wUGFyYW06ICd0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF1dGhFbmdpbmU6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBhdXRoVG9rZW5OYW1lOiAnc29ja2V0Q2x1c3Rlci5hdXRoVG9rZW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgYmluYXJ5VHlwZTogJ2FycmF5YnVmZmVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpcGxleDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSBpbiBvcHRpb25zICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBvcHRpb25zLmhhc093blByb3BlcnR5KCBpICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0c1tpXSA9IG9wdGlvbnNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIG11bHRpcGxleElkID0gZ2V0TXVsdGlwbGV4SWQoIG9wdHMgKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBvcHRzLm11bHRpcGxleCA9PT0gZmFsc2UgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFNDU29ja2V0KCBvcHRzICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBfY29ubmVjdGlvbnNbbXVsdGlwbGV4SWRdICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2Nvbm5lY3Rpb25zW211bHRpcGxleElkXS5jb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfY29ubmVjdGlvbnNbbXVsdGlwbGV4SWRdID0gbmV3IFNDU29ja2V0KCBvcHRzICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb25uZWN0aW9uc1ttdWx0aXBsZXhJZF07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZGVzdHJveSggb3B0aW9ucyApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBvcHRzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9ydDogODg4OCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvc3RuYW1lOiAnbG9jYWxob3N0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6ICcvc29ja2V0Y2x1c3Rlci8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VjdXJlOiBvcHRpb25zLnNlY3VyZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSBpbiBvcHRpb25zICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBvcHRpb25zLmhhc093blByb3BlcnR5KCBpICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0c1tpXSA9IG9wdGlvbnNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIG11bHRpcGxleElkID0gZ2V0TXVsdGlwbGV4SWQoIG9wdHMgKTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIF9jb25uZWN0aW9uc1ttdWx0aXBsZXhJZF07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Q6IGNvbm5lY3QsXG4gICAgICAgICAgICAgICAgICAgIGRlc3Ryb3k6IGRlc3Ryb3lcbiAgICAgICAgICAgICAgICB9O1xuXG5cbiAgICAgICAgICAgICAgICAvKioqL1xufSxcbi8qIDE3MiAqL1xuLyoqKi8gZnVuY3Rpb24gKCBtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18gKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgU0NFbWl0dGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyggMTIgKS5TQ0VtaXR0ZXI7XG4gICAgICAgICAgICAgICAgdmFyIFJlc3BvbnNlID0gX193ZWJwYWNrX3JlcXVpcmVfXyggNDkgKS5SZXNwb25zZTtcbiAgICAgICAgICAgICAgICB2YXIgcXVlcnlzdHJpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCA0OCApO1xuICAgICAgICAgICAgICAgIHZhciBXZWJTb2NrZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCAxNzMgKTtcblxuICAgICAgICAgICAgICAgIHZhciBzY0Vycm9ycyA9IF9fd2VicGFja19yZXF1aXJlX18oIDI1ICk7XG4gICAgICAgICAgICAgICAgdmFyIFRpbWVvdXRFcnJvciA9IHNjRXJyb3JzLlRpbWVvdXRFcnJvcjtcblxuXG4gICAgICAgICAgICAgICAgdmFyIFNDVHJhbnNwb3J0ID0gZnVuY3Rpb24gKCBhdXRoRW5naW5lLCBjb2RlY0VuZ2luZSwgb3B0aW9ucyApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMuQ0xPU0VEO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF1dGggPSBhdXRoRW5naW5lO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvZGVjID0gY29kZWNFbmdpbmU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdFRpbWVvdXQgPSBvcHRpb25zLmNvbm5lY3RUaW1lb3V0O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBpbmdUaW1lb3V0ID0gb3B0aW9ucy5hY2tUaW1lb3V0O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGxJZEdlbmVyYXRvciA9IG9wdGlvbnMuY2FsbElkR2VuZXJhdG9yO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BpbmdUaW1lb3V0VGlja2VyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2tNYXAgPSB7fTtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wZW4oKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgU0NUcmFuc3BvcnQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggU0NFbWl0dGVyLnByb3RvdHlwZSApO1xuXG4gICAgICAgICAgICAgICAgU0NUcmFuc3BvcnQuQ09OTkVDVElORyA9IFNDVHJhbnNwb3J0LnByb3RvdHlwZS5DT05ORUNUSU5HID0gJ2Nvbm5lY3RpbmcnO1xuICAgICAgICAgICAgICAgIFNDVHJhbnNwb3J0Lk9QRU4gPSBTQ1RyYW5zcG9ydC5wcm90b3R5cGUuT1BFTiA9ICdvcGVuJztcbiAgICAgICAgICAgICAgICBTQ1RyYW5zcG9ydC5DTE9TRUQgPSBTQ1RyYW5zcG9ydC5wcm90b3R5cGUuQ0xPU0VEID0gJ2Nsb3NlZCc7XG5cbiAgICAgICAgICAgICAgICBTQ1RyYW5zcG9ydC5wcm90b3R5cGUudXJpID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcXVlcnkgPSB0aGlzLm9wdGlvbnMucXVlcnkgfHwge307XG4gICAgICAgICAgICAgICAgICAgIHZhciBzY2hlbWEgPSB0aGlzLm9wdGlvbnMuc2VjdXJlID8gJ3dzcycgOiAnd3MnO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcG9ydCA9ICcnO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggdGhpcy5vcHRpb25zLnBvcnQgJiYgKCAoICd3c3MnID09IHNjaGVtYSAmJiB0aGlzLm9wdGlvbnMucG9ydCAhPSA0NDMgKVxuICAgICAgICAgICAgICAgICAgICAgICAgfHwgKCAnd3MnID09IHNjaGVtYSAmJiB0aGlzLm9wdGlvbnMucG9ydCAhPSA4MCApICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3J0ID0gJzonICsgdGhpcy5vcHRpb25zLnBvcnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoIHRoaXMub3B0aW9ucy50aW1lc3RhbXBSZXF1ZXN0cyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5W3RoaXMub3B0aW9ucy50aW1lc3RhbXBQYXJhbV0gPSAoIG5ldyBEYXRlKCkgKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBxdWVyeSA9IHF1ZXJ5c3RyaW5nLmVuY29kZSggcXVlcnkgKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIHF1ZXJ5Lmxlbmd0aCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5ID0gJz8nICsgcXVlcnk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2NoZW1hICsgJzovLycgKyB0aGlzLm9wdGlvbnMuaG9zdG5hbWUgKyBwb3J0ICsgdGhpcy5vcHRpb25zLnBhdGggKyBxdWVyeTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgU0NUcmFuc3BvcnQucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gdGhpcy5DT05ORUNUSU5HO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdXJpID0gdGhpcy51cmkoKTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgd3NTb2NrZXQgPSBuZXcgV2ViU29ja2V0KCB1cmksIG51bGwsIHRoaXMub3B0aW9ucyApO1xuICAgICAgICAgICAgICAgICAgICB3c1NvY2tldC5iaW5hcnlUeXBlID0gdGhpcy5vcHRpb25zLmJpbmFyeVR5cGU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc29ja2V0ID0gd3NTb2NrZXQ7XG5cbiAgICAgICAgICAgICAgICAgICAgd3NTb2NrZXQub25vcGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fb25PcGVuKCk7XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgd3NTb2NrZXQub25jbG9zZSA9IGZ1bmN0aW9uICggZXZlbnQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9vbkNsb3NlKCBldmVudC5jb2RlLCBldmVudC5yZWFzb24gKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICB3c1NvY2tldC5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoIG1lc3NhZ2UsIGZsYWdzICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fb25NZXNzYWdlKCBtZXNzYWdlLmRhdGEgKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICB3c1NvY2tldC5vbmVycm9yID0gZnVuY3Rpb24gKCBlcnJvciApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBvbmNsb3NlIGV2ZW50IHdpbGwgYmUgY2FsbGVkIGF1dG9tYXRpY2FsbHkgYWZ0ZXIgdGhlIG9uZXJyb3IgZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBzb2NrZXQgaXMgY29ubmVjdGVkIC0gT3RoZXJ3aXNlLCBpZiBpdCdzIGluIHRoZSBtaWRkbGUgb2ZcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbm5lY3RpbmcsIHdlIHdhbnQgdG8gY2xvc2UgaXQgbWFudWFsbHkgd2l0aCBhIDEwMDYgLSBUaGlzIGlzIG5lY2Vzc2FyeVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG8gcHJldmVudCBpbmNvbnNpc3RlbnQgYmVoYXZpb3Igd2hlbiBydW5uaW5nIHRoZSBjbGllbnQgaW4gTm9kZS5qc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdnMgaW4gYSBicm93c2VyLlxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHNlbGYuc3RhdGUgPT09IHNlbGYuQ09OTkVDVElORyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9vbkNsb3NlKCAxMDA2ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29ubmVjdFRpbWVvdXRSZWYgPSBzZXRUaW1lb3V0KCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9vbkNsb3NlKCA0MDA3ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnNvY2tldC5jbG9zZSggNDAwNyApO1xuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzLmNvbm5lY3RUaW1lb3V0ICk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIFNDVHJhbnNwb3J0LnByb3RvdHlwZS5fb25PcGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KCB0aGlzLl9jb25uZWN0VGltZW91dFJlZiApO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXNldFBpbmdUaW1lb3V0KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faGFuZHNoYWtlKCBmdW5jdGlvbiAoIGVyciwgc3RhdHVzICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBlcnIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fb25FcnJvciggZXJyICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fb25DbG9zZSggNDAwMyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuc29ja2V0LmNsb3NlKCA0MDAzICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuc3RhdGUgPSBzZWxmLk9QRU47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgU0NFbWl0dGVyLnByb3RvdHlwZS5lbWl0LmNhbGwoIHNlbGYsICdvcGVuJywgc3RhdHVzICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fcmVzZXRQaW5nVGltZW91dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9ICk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIFNDVHJhbnNwb3J0LnByb3RvdHlwZS5faGFuZHNoYWtlID0gZnVuY3Rpb24gKCBjYWxsYmFjayApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF1dGgubG9hZFRva2VuKCB0aGlzLm9wdGlvbnMuYXV0aFRva2VuTmFtZSwgZnVuY3Rpb24gKCBlcnIsIHRva2VuICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBlcnIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soIGVyciApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCB3YWl0IGZvciB0aGlzLnN0YXRlIHRvIGJlICdvcGVuJy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgdW5kZXJseWluZyBXZWJTb2NrZXQgKHRoaXMuc29ja2V0KSBpcyBhbHJlYWR5IG9wZW4uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcmNlOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmVtaXQoICcjaGFuZHNoYWtlJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdXRoVG9rZW46IHRva2VuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgb3B0aW9ucywgZnVuY3Rpb24gKCBlcnIsIHN0YXR1cyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBzdGF0dXMgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIHRva2VuIHdoaWNoIHdhcyB1c2VkIGFzIHBhcnQgb2YgYXV0aGVudGljYXRpb24gYXR0ZW1wdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG8gdGhlIHN0YXR1cyBvYmplY3QuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMuYXV0aFRva2VuID0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHN0YXR1cy5hdXRoRXJyb3IgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmF1dGhFcnJvciA9IHNjRXJyb3JzLmh5ZHJhdGVFcnJvciggc3RhdHVzLmF1dGhFcnJvciApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCBlcnIsIHN0YXR1cyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSApO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBTQ1RyYW5zcG9ydC5wcm90b3R5cGUuX29uQ2xvc2UgPSBmdW5jdGlvbiAoIGNvZGUsIGRhdGEgKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnNvY2tldC5vbm9wZW47XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnNvY2tldC5vbmNsb3NlO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5zb2NrZXQub25tZXNzYWdlO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5zb2NrZXQub25lcnJvcjtcblxuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoIHRoaXMuX2Nvbm5lY3RUaW1lb3V0UmVmICk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCB0aGlzLnN0YXRlID09IHRoaXMuT1BFTiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLkNMT1NFRDtcbiAgICAgICAgICAgICAgICAgICAgICAgIFNDRW1pdHRlci5wcm90b3R5cGUuZW1pdC5jYWxsKCB0aGlzLCAnY2xvc2UnLCBjb2RlLCBkYXRhICk7XG5cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICggdGhpcy5zdGF0ZSA9PSB0aGlzLkNPTk5FQ1RJTkcgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gdGhpcy5DTE9TRUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBTQ0VtaXR0ZXIucHJvdG90eXBlLmVtaXQuY2FsbCggdGhpcywgJ29wZW5BYm9ydCcsIGNvZGUsIGRhdGEgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBTQ1RyYW5zcG9ydC5wcm90b3R5cGUuX29uTWVzc2FnZSA9IGZ1bmN0aW9uICggbWVzc2FnZSApIHtcbiAgICAgICAgICAgICAgICAgICAgU0NFbWl0dGVyLnByb3RvdHlwZS5lbWl0LmNhbGwoIHRoaXMsICdldmVudCcsICdtZXNzYWdlJywgbWVzc2FnZSApO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHBpbmdcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBtZXNzYWdlID09ICcjMScgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXNldFBpbmdUaW1lb3V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHRoaXMuc29ja2V0LnJlYWR5U3RhdGUgPT0gdGhpcy5zb2NrZXQuT1BFTiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNvY2tldC5zZW5kKCAnIzInICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2JqID0gdGhpcy5kZWNvZGUoIG1lc3NhZ2UgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBldmVudCA9IG9iai5ldmVudDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBldmVudCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UoIHRoaXMsIG9iai5jaWQgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTQ0VtaXR0ZXIucHJvdG90eXBlLmVtaXQuY2FsbCggdGhpcywgJ2V2ZW50JywgZXZlbnQsIG9iai5kYXRhLCByZXNwb25zZSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICggb2JqLnJpZCAhPSBudWxsICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV2ZW50T2JqZWN0ID0gdGhpcy5fY2FsbGJhY2tNYXBbb2JqLnJpZF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBldmVudE9iamVjdCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KCBldmVudE9iamVjdC50aW1lb3V0ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9jYWxsYmFja01hcFtvYmoucmlkXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGV2ZW50T2JqZWN0LmNhbGxiYWNrICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlaHlkcmF0ZWRFcnJvciA9IHNjRXJyb3JzLmh5ZHJhdGVFcnJvciggb2JqLmVycm9yICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudE9iamVjdC5jYWxsYmFjayggcmVoeWRyYXRlZEVycm9yLCBvYmouZGF0YSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTQ0VtaXR0ZXIucHJvdG90eXBlLmVtaXQuY2FsbCggdGhpcywgJ2V2ZW50JywgJ3JhdycsIG9iaiApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIFNDVHJhbnNwb3J0LnByb3RvdHlwZS5fb25FcnJvciA9IGZ1bmN0aW9uICggZXJyICkge1xuICAgICAgICAgICAgICAgICAgICBTQ0VtaXR0ZXIucHJvdG90eXBlLmVtaXQuY2FsbCggdGhpcywgJ2Vycm9yJywgZXJyICk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIFNDVHJhbnNwb3J0LnByb3RvdHlwZS5fcmVzZXRQaW5nVGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBub3cgPSAoIG5ldyBEYXRlKCkgKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCggdGhpcy5fcGluZ1RpbWVvdXRUaWNrZXIgKTtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9waW5nVGltZW91dFRpY2tlciA9IHNldFRpbWVvdXQoIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX29uQ2xvc2UoIDQwMDAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuc29ja2V0LmNsb3NlKCA0MDAwICk7XG4gICAgICAgICAgICAgICAgICAgIH0sIHRoaXMucGluZ1RpbWVvdXQgKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgU0NUcmFuc3BvcnQucHJvdG90eXBlLmdldEJ5dGVzUmVjZWl2ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNvY2tldC5ieXRlc1JlY2VpdmVkO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBTQ1RyYW5zcG9ydC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoIGNvZGUsIGRhdGEgKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGUgPSBjb2RlIHx8IDEwMDA7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCB0aGlzLnN0YXRlID09IHRoaXMuT1BFTiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYWNrZXQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogY29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCAnI2Rpc2Nvbm5lY3QnLCBwYWNrZXQgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb25DbG9zZSggY29kZSwgZGF0YSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zb2NrZXQuY2xvc2UoIGNvZGUgKTtcblxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCB0aGlzLnN0YXRlID09IHRoaXMuQ09OTkVDVElORyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29uQ2xvc2UoIGNvZGUsIGRhdGEgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc29ja2V0LmNsb3NlKCBjb2RlICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgU0NUcmFuc3BvcnQucHJvdG90eXBlLmVtaXRSYXcgPSBmdW5jdGlvbiAoIGV2ZW50T2JqZWN0ICkge1xuICAgICAgICAgICAgICAgICAgICBldmVudE9iamVjdC5jaWQgPSB0aGlzLmNhbGxJZEdlbmVyYXRvcigpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggZXZlbnRPYmplY3QuY2FsbGJhY2sgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWxsYmFja01hcFtldmVudE9iamVjdC5jaWRdID0gZXZlbnRPYmplY3Q7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgc2ltcGxlRXZlbnRPYmplY3QgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudDogZXZlbnRPYmplY3QuZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBldmVudE9iamVjdC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2lkOiBldmVudE9iamVjdC5jaWRcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbmRPYmplY3QoIHNpbXBsZUV2ZW50T2JqZWN0ICk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBldmVudE9iamVjdC5jaWQ7XG4gICAgICAgICAgICAgICAgfTtcblxuXG4gICAgICAgICAgICAgICAgU0NUcmFuc3BvcnQucHJvdG90eXBlLl9oYW5kbGVFdmVudEFja1RpbWVvdXQgPSBmdW5jdGlvbiAoIGV2ZW50T2JqZWN0ICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3JNZXNzYWdlID0gXCJFdmVudCByZXNwb25zZSBmb3IgJ1wiICsgZXZlbnRPYmplY3QuZXZlbnQgKyBcIicgdGltZWQgb3V0XCI7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBUaW1lb3V0RXJyb3IoIGVycm9yTWVzc2FnZSApO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggZXZlbnRPYmplY3QuY2lkICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2NhbGxiYWNrTWFwW2V2ZW50T2JqZWN0LmNpZF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gZXZlbnRPYmplY3QuY2FsbGJhY2s7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBldmVudE9iamVjdC5jYWxsYmFjaztcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbCggZXZlbnRPYmplY3QsIGVycm9yLCBldmVudE9iamVjdCApO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAvLyBUaGUgbGFzdCB0d28gb3B0aW9uYWwgYXJndW1lbnRzIChhIGFuZCBiKSBjYW4gYmUgb3B0aW9ucyBhbmQvb3IgY2FsbGJhY2tcbiAgICAgICAgICAgICAgICBTQ1RyYW5zcG9ydC5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uICggZXZlbnQsIGRhdGEsIGEsIGIgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAgICAgICAgICAgICB2YXIgY2FsbGJhY2ssIG9wdGlvbnM7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBiICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IGE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGI7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGEgaW5zdGFuY2VvZiBGdW5jdGlvbiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBhO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0gYTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciBldmVudE9iamVjdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIGNhbGxiYWNrICYmICFvcHRpb25zLm5vVGltZW91dCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50T2JqZWN0LnRpbWVvdXQgPSBzZXRUaW1lb3V0KCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5faGFuZGxlRXZlbnRBY2tUaW1lb3V0KCBldmVudE9iamVjdCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgdGhpcy5vcHRpb25zLmFja1RpbWVvdXQgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciBjaWQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIHRoaXMuc3RhdGUgPT0gdGhpcy5PUEVOIHx8IG9wdGlvbnMuZm9yY2UgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaWQgPSB0aGlzLmVtaXRSYXcoIGV2ZW50T2JqZWN0ICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNpZDtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgU0NUcmFuc3BvcnQucHJvdG90eXBlLmNhbmNlbFBlbmRpbmdSZXNwb25zZSA9IGZ1bmN0aW9uICggY2lkICkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fY2FsbGJhY2tNYXBbY2lkXTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgU0NUcmFuc3BvcnQucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uICggbWVzc2FnZSApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29kZWMuZGVjb2RlKCBtZXNzYWdlICk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIFNDVHJhbnNwb3J0LnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbiAoIG9iamVjdCApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29kZWMuZW5jb2RlKCBvYmplY3QgKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgU0NUcmFuc3BvcnQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAoIGRhdGEgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggdGhpcy5zb2NrZXQucmVhZHlTdGF0ZSAhPSB0aGlzLnNvY2tldC5PUEVOICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb25DbG9zZSggMTAwNSApO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zb2NrZXQuc2VuZCggZGF0YSApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIFNDVHJhbnNwb3J0LnByb3RvdHlwZS5zZW5kT2JqZWN0ID0gZnVuY3Rpb24gKCBvYmplY3QgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHIsIGZvcm1hdEVycm9yO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyID0gdGhpcy5lbmNvZGUoIG9iamVjdCApO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoICggZXJyICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0RXJyb3IgPSBlcnI7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vbkVycm9yKCBmb3JtYXRFcnJvciApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICggIWZvcm1hdEVycm9yICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZW5kKCBzdHIgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBtb2R1bGUuZXhwb3J0cy5TQ1RyYW5zcG9ydCA9IFNDVHJhbnNwb3J0O1xuXG5cbiAgICAgICAgICAgICAgICAvKioqL1xufSxcbi8qIDE3MyAqL1xuLyoqKi8gZnVuY3Rpb24gKCBtb2R1bGUsIGV4cG9ydHMgKSB7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBXZWJTb2NrZXQgY29uc3RydWN0b3IuXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBUaGUgdGhpcmQgYG9wdHNgIG9wdGlvbnMgb2JqZWN0IGdldHMgaWdub3JlZCBpbiB3ZWIgYnJvd3NlcnMsIHNpbmNlIGl0J3NcbiAgICAgICAgICAgICAgICAgKiBub24tc3RhbmRhcmQsIGFuZCB0aHJvd3MgYSBUeXBlRXJyb3IgaWYgcGFzc2VkIHRvIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICAgICAgICAgKiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9laW5hcm9zL3dzL2lzc3Vlcy8yMjdcbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmlcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBwcm90b2NvbHMgKG9wdGlvbmFsKVxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIChvcHRpb25hbClcbiAgICAgICAgICAgICAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gd3MoIHVyaSwgcHJvdG9jb2xzLCBvcHRzICkge1xuICAgICAgICAgICAgICAgICAgICB3eC5vblNvY2tldE9wZW4oIHRoaXMuaGFuZGxlU29ja2V0T3Blbi5iaW5kKCB0aGlzICkgKVxuICAgICAgICAgICAgICAgICAgICB3eC5vblNvY2tldENsb3NlKCB0aGlzLmhhbmRsZVNvY2tldENsb3NlLmJpbmQoIHRoaXMgKSApXG4gICAgICAgICAgICAgICAgICAgIHd4Lm9uU29ja2V0TWVzc2FnZSggdGhpcy5oYW5kbGVNZXNzYWdlLmJpbmQoIHRoaXMgKSApXG4gICAgICAgICAgICAgICAgICAgIHd4Lm9uU29ja2V0RXJyb3IoIHRoaXMuaGFuZGxlU29ja2V0RXJyb3IuYmluZCggdGhpcyApIClcbiAgICAgICAgICAgICAgICAgICAgd3guY29ubmVjdFNvY2tldCggeyB1cmw6IHVyaSB9IClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgd3MucHJvdG90eXBlID0ge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVTb2NrZXRPcGVuTGF0ZXI6IGZ1bmN0aW9uICggcmVzICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB0aGlzLmhhbmRsZVNvY2tldE9wZW5MYXRlckhhbmRsZXIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KCB0aGlzLmhhbmRsZVNvY2tldE9wZW5MYXRlckhhbmRsZXIgKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVNvY2tldE9wZW5MYXRlckhhbmRsZXIgPSBzZXRUaW1lb3V0KCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5oYW5kbGVTb2NrZXRPcGVuKCByZXMgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIDEwMDAgKVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVTb2NrZXRPcGVuOiBmdW5jdGlvbiAoIHJlcyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdGhpcy5vbm9wZW4gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbm9wZW4oIHJlcyApXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlU29ja2V0T3BlbkxhdGVyKCByZXMgKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVNZXNzYWdlOiBmdW5jdGlvbiAoIHJlcyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdGhpcy5vbm1lc3NhZ2UgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbm1lc3NhZ2UoIHJlcyApXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlTWVzc2FnZUxhdGVyKCByZXMgKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVNZXNzYWdlTGF0ZXI6IGZ1bmN0aW9uICggcmVzICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB0aGlzLmhhbmRsZU1lc3NhZ2VMYXRlckhhbmRsZXIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KCB0aGlzLmhhbmRsZU1lc3NhZ2VMYXRlckhhbmRsZXIgKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZU1lc3NhZ2VMYXRlckhhbmRsZXIgPSBzZXRUaW1lb3V0KCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5oYW5kbGVNZXNzYWdlKCByZXMgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIDEwMDAgKVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVTb2NrZXRFcnJvcjogZnVuY3Rpb24gKCByZXMgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHRoaXMub25lcnJvciApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uZXJyb3IoIHJlcyApXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlU29ja2V0RXJyb3JMYXRlciggcmVzIClcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlU29ja2V0RXJyb3JMYXRlcjogZnVuY3Rpb24gKCByZXMgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHRoaXMuaGFuZGxlU29ja2V0RXJyb3JMYXRlckhhbmRsZXIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KCB0aGlzLmhhbmRsZVNvY2tldEVycm9yTGF0ZXJIYW5kbGVyIClcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVTb2NrZXRFcnJvckxhdGVySGFuZGxlciA9IHNldFRpbWVvdXQoIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmhhbmRsZVNvY2tldEVycm9yKCByZXMgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIDEwMDAgKVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVTb2NrZXRDbG9zZTogZnVuY3Rpb24gKCByZXMgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHRoaXMub25jbG9zZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uY2xvc2UoIHJlcyApXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlU29ja2V0Q2xvc2VMYXRlciggcmVzIClcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlU29ja2V0Q2xvc2VMYXRlcjogZnVuY3Rpb24gKCByZXMgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHRoaXMuaGFuZGxlU29ja2V0Q2xvc2VMYXRlckhhbmRsZXIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KCB0aGlzLmhhbmRsZVNvY2tldENsb3NlTGF0ZXJIYW5kbGVyIClcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVTb2NrZXRDbG9zZUxhdGVySGFuZGxlciA9IHNldFRpbWVvdXQoIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmhhbmRsZVNvY2tldENsb3NlKCByZXMgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gKVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBzZW5kOiBmdW5jdGlvbiAoIGRhdGEgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3eC5zZW5kU29ja2V0TWVzc2FnZSgge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEsIGZhaWw6IGZ1bmN0aW9uICggcmVzICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyggXCJ3eCB3ZWIgc29ja2V0IHNlbmQgZmFpbGVkOiBcIiArIHJlcyApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSApXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGNsb3NlOiB3eC5jbG9zZVNvY2tldFxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IHdzO1xuICAgICAgICAgICAgICAgIC8qKiovXG59LFxuLyogMTc0ICovXG4vKioqLyBmdW5jdGlvbiAoIG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyApIHtcblxuXHQvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oIGZ1bmN0aW9uICggZ2xvYmFsICkgey8qIGdsb2JhbCB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyggMTc1ICkoIGdsb2JhbCB8fCB3aW5kb3cgfHwgdGhpcyApO1xuXG4gICAgICAgICAgICAgICAgICAgIC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL1xufS5jYWxsKCBleHBvcnRzLCAoIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0oKSApICkgKVxuXG4gICAgICAgICAgICAgICAgLyoqKi9cbn0sXG4vKiAxNzUgKi9cbi8qKiovIGZ1bmN0aW9uICggbW9kdWxlLCBleHBvcnRzICkge1xuXG4gICAgICAgICAgICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzeW1ib2xPYnNlcnZhYmxlUG9ueWZpbGwoIHJvb3QgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciBTeW1ib2wgPSByb290LlN5bWJvbDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIFN5bWJvbC5vYnNlcnZhYmxlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IFN5bWJvbC5vYnNlcnZhYmxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBTeW1ib2woICdvYnNlcnZhYmxlJyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFN5bWJvbC5vYnNlcnZhYmxlID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gJ0BAb2JzZXJ2YWJsZSc7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH07XG5cblxuICAgICAgICAgICAgICAgIC8qKiovXG59XG4vKioqKioqL10gKVxufSApO1xuOyJdfQ==